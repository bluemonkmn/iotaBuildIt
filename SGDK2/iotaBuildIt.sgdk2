<?xml version="1.0" standalone="yes"?>
<ProjectDataset>
  <xs:schema id="ProjectDataset" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" xmlns:msprop="urn:schemas-microsoft-com:xml-msprop">
    <xs:element name="ProjectDataset" msdata:IsDataSet="true" msdata:UseCurrentLocale="true" msprop:SchemaVersion="1">
      <xs:complexType>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element name="GraphicSheet">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Image" type="xs:base64Binary" minOccurs="0" msdata:Ordinal="5" />
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="Columns" type="xs:short" default="16" />
              <xs:attribute name="Rows" type="xs:short" default="8" />
              <xs:attribute name="CellWidth" msdata:Caption="Cell Width" type="xs:short" default="32" />
              <xs:attribute name="CellHeight" msdata:Caption="Cell Height" type="xs:short" default="32" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Frameset">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Frame" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="FrameValue" type="xs:int" use="required" />
                    <xs:attribute name="GraphicSheet" type="xs:string" use="required" />
                    <xs:attribute name="CellIndex" type="xs:short" use="required" />
                    <xs:attribute name="m11" type="xs:float" default="1" />
                    <xs:attribute name="m12" type="xs:float" default="0" />
                    <xs:attribute name="m21" type="xs:float" default="0" />
                    <xs:attribute name="m22" type="xs:float" default="1" />
                    <xs:attribute name="dx" type="xs:float" default="0" />
                    <xs:attribute name="dy" type="xs:float" default="0" />
                    <xs:attribute name="Name" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="color" type="xs:int" default="-1" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Tileset">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Tile" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="TileFrame" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:attribute name="Sequence" type="xs:short" use="required" />
                          <xs:attribute name="FrameValue" type="xs:int" />
                          <xs:attribute name="Duration" type="xs:short" />
                          <xs:attribute name="Name" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="TileValue" type="xs:int" msdata:AllowDBNull="false" use="prohibited" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="TileValue" type="xs:int" use="required" />
                    <xs:attribute name="Counter" type="xs:string" />
                    <xs:attribute name="Name" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="Frameset" type="xs:string" />
              <xs:attribute name="TileWidth" type="xs:short" use="required" />
              <xs:attribute name="TileHeight" type="xs:short" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Counter">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Min" type="xs:int" default="0" msdata:Ordinal="3" />
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="Value" type="xs:int" />
              <xs:attribute name="Max" type="xs:int" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Map">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Layer" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="Tiles" type="xs:base64Binary" minOccurs="0" msdata:Ordinal="14" />
                      <xs:element name="Sprite" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="ParameterValue" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="SpriteName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="ParameterName" type="xs:string" use="required" />
                                <xs:attribute name="Value" type="xs:int" />
                                <xs:attribute name="DefinitionName" type="xs:string" use="prohibited" />
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Name" type="xs:string" use="required" />
                          <xs:attribute name="DefinitionName" type="xs:string" use="required" />
                          <xs:attribute name="StateName" type="xs:string" />
                          <xs:attribute name="CurrentFrame" type="xs:short" />
                          <xs:attribute name="X" type="xs:int" />
                          <xs:attribute name="Y" type="xs:int" />
                          <xs:attribute name="DX" type="xs:float" />
                          <xs:attribute name="DY" type="xs:float" />
                          <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Priority" type="xs:int" />
                          <xs:attribute name="Active" type="xs:boolean" default="true" />
                          <xs:attribute name="Solidity" type="xs:string" />
                          <xs:attribute name="Color" type="xs:int" default="-1" />
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="SpritePlan" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="BaseClass" type="xs:string" default="PlanBase" msdata:Ordinal="4" />
                            <xs:element name="Coordinate" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="PlanName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Sequence" type="xs:short" use="required" />
                                <xs:attribute name="X" type="xs:int" />
                                <xs:attribute name="Y" type="xs:int" />
                                <xs:attribute name="Weight" type="xs:int" />
                              </xs:complexType>
                            </xs:element>
                            <xs:element name="PlanRule" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="PlanName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Name" type="xs:string" use="required" />
                                <xs:attribute name="Sequence" type="xs:int" use="required" />
                                <xs:attribute name="Type" type="xs:string" use="required" />
                                <xs:attribute name="Function" type="xs:string" use="required" />
                                <xs:attribute name="Parameter1" type="xs:string" />
                                <xs:attribute name="Parameter2" type="xs:string" />
                                <xs:attribute name="Parameter3" type="xs:string" />
                                <xs:attribute name="ResultParameter" type="xs:string" />
                                <xs:attribute name="EndIf" type="xs:boolean" default="false" />
                                <xs:attribute name="Suspended" type="xs:boolean" default="false" />
                              </xs:complexType>
                            </xs:element>
                            <xs:element name="PlanParameterValue" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="PlanName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Name" type="xs:string" use="required" />
                                <xs:attribute name="Value" type="xs:string" />
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Name" type="xs:string" use="required" />
                          <xs:attribute name="Priority" type="xs:int" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="Name" type="xs:string" use="required" />
                    <xs:attribute name="Width" type="xs:int" use="required" />
                    <xs:attribute name="Height" type="xs:int" use="required" />
                    <xs:attribute name="Tileset" type="xs:string" />
                    <xs:attribute name="BytesPerTile" type="xs:unsignedByte" use="required" />
                    <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="OffsetX" type="xs:int" default="0" />
                    <xs:attribute name="OffsetY" type="xs:int" default="0" />
                    <xs:attribute name="ScrollRateX" type="xs:float" default="1" />
                    <xs:attribute name="ScrollRateY" type="xs:float" default="1" />
                    <xs:attribute name="ZIndex" type="xs:int" />
                    <xs:attribute name="Priority" type="xs:int" default="0" />
                    <xs:attribute name="VirtualWidth" type="xs:int" default="0" />
                    <xs:attribute name="VirtualHeight" type="xs:int" default="0" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="ScrollMarginLeft" type="xs:short" use="required" />
              <xs:attribute name="ScrollMarginTop" type="xs:short" use="required" />
              <xs:attribute name="ScrollMarginRight" type="xs:short" use="required" />
              <xs:attribute name="ScrollMarginBottom" type="xs:short" use="required" />
              <xs:attribute name="ScrollWidth" msdata:Caption="Scrollable pixel width of the map independent of its layers" type="xs:int" />
              <xs:attribute name="ScrollHeight" msdata:Caption="Scrollable pixel height of the map independent of its layers" type="xs:int" />
              <xs:attribute name="ViewLeft" type="xs:short" />
              <xs:attribute name="ViewTop" type="xs:short" />
              <xs:attribute name="ViewWidth" type="xs:short" />
              <xs:attribute name="ViewHeight" type="xs:short" />
            </xs:complexType>
          </xs:element>
          <xs:element name="SpriteDefinition">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="BaseClass" type="xs:string" default="SpriteBase" msdata:Ordinal="1" />
                <xs:element name="SpriteRule" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                    <xs:attribute name="Sequence" type="xs:int" use="required" />
                    <xs:attribute name="Type" type="xs:string" use="required" />
                    <xs:attribute name="Function" type="xs:string" use="required" />
                    <xs:attribute name="Parameter1" type="xs:string" />
                    <xs:attribute name="Parameter2" type="xs:string" />
                    <xs:attribute name="Parameter3" type="xs:string" />
                    <xs:attribute name="ResultParameter" type="xs:string" />
                    <xs:attribute name="EndIf" type="xs:boolean" default="false" />
                    <xs:attribute name="Suspended" type="xs:boolean" default="false" />
                  </xs:complexType>
                </xs:element>
                <xs:element name="SpriteParameter" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                  </xs:complexType>
                </xs:element>
                <xs:element name="SpriteState" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="SpriteFrame" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="StateName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Sequence" type="xs:short" use="required" />
                          <xs:attribute name="FrameValue" type="xs:int" />
                          <xs:attribute name="Duration" type="xs:short" />
                          <xs:attribute name="MaskAlphaLevel" type="xs:unsignedByte" default="0" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                    <xs:attribute name="FramesetName" type="xs:string" use="required" />
                    <xs:attribute name="SolidWidth" type="xs:short" use="required" />
                    <xs:attribute name="SolidHeight" type="xs:short" use="required" />
                    <xs:attribute name="Sequence" type="xs:short" use="required" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="SpriteCategory">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SpriteCategorySprite" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="CategoryName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="DefinitionName" type="xs:string" use="required" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Solidity">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SolidityShape" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="SolidityName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="CategoryName" type="xs:string" use="required" />
                    <xs:attribute name="ShapeName" type="xs:string" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="SourceCode">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Text" type="xs:string" minOccurs="0" msdata:Ordinal="3" />
                <xs:element name="CustomObjectData" type="xs:base64Binary" minOccurs="0" msdata:Ordinal="4" />
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="IsCustomObject" type="xs:boolean" default="false" />
              <xs:attribute name="DependsOn" type="xs:string" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Project">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Comments" type="xs:string" default="" msdata:Ordinal="8" />
              </xs:sequence>
              <xs:attribute name="DisplayMode" type="xs:string" use="required" />
              <xs:attribute name="Windowed" type="xs:boolean" use="required" />
              <xs:attribute name="TitleText" type="xs:string" />
              <xs:attribute name="StartMap" type="xs:string" />
              <xs:attribute name="OverlayMap" type="xs:string" />
              <xs:attribute name="MaxPlayers" type="xs:unsignedByte" default="1" />
              <xs:attribute name="MaxViews" type="xs:unsignedByte" default="1" />
              <xs:attribute name="Credits" type="xs:string" />
            </xs:complexType>
          </xs:element>
          <xs:element name="TileCategory">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="CategorizedTileset" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="CategoryTile" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="CategoryFrame" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="Tileset" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Category" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="TileValue" type="xs:int" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Frame" type="xs:short" use="required" />
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attribute name="Tileset" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Category" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="TileValue" type="xs:int" use="required" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="Tileset" type="xs:string" use="required" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
        </xs:choice>
      </xs:complexType>
      <xs:unique name="GraphicSheetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//GraphicSheet" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="FrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Frame" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@FrameValue" />
      </xs:unique>
      <xs:unique name="FramesetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Frameset" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="TileFrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//TileFrame" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@TileValue" />
        <xs:field xpath="@Sequence" />
      </xs:unique>
      <xs:unique name="TileKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Tile" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@TileValue" />
      </xs:unique>
      <xs:unique name="TilesetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Tileset" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="CounterKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Counter" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="ParameterValueKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//ParameterValue" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@SpriteName" />
        <xs:field xpath="@ParameterName" />
        <xs:field xpath="@MapName" />
      </xs:unique>
      <xs:unique name="SpriteKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@MapName" />
      </xs:unique>
      <xs:unique name="SpriteKeyWithDefinition">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@MapName" />
      </xs:unique>
      <xs:unique name="CoordinateKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Coordinate" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
        <xs:field xpath="@Sequence" />
      </xs:unique>
      <xs:unique name="PlanRuleKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//PlanRule" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="PlanParameterValueKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//PlanParameterValue" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpritePlanKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpritePlan" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="LayerKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Layer" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="MapKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Map" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteRuleKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteRule" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteParameterKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteParameter" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteFrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteFrame" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@StateName" />
        <xs:field xpath="@Sequence" />
      </xs:unique>
      <xs:unique name="SpriteStateKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteStateFramesetKey">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@FramesetName" />
      </xs:unique>
      <xs:unique name="SpriteDefinitionKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteDefinition" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteCategorySpriteKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteCategorySprite" />
        <xs:field xpath="@CategoryName" />
        <xs:field xpath="@DefinitionName" />
      </xs:unique>
      <xs:unique name="SpriteCategoryKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteCategory" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SolidityShapeKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SolidityShape" />
        <xs:field xpath="@SolidityName" />
        <xs:field xpath="@CategoryName" />
      </xs:unique>
      <xs:unique name="SolidityKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Solidity" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SourceCodeKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SourceCode" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="CategoryFrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//CategoryFrame" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
        <xs:field xpath="@TileValue" />
        <xs:field xpath="@Frame" />
      </xs:unique>
      <xs:unique name="CategoryTileKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//CategoryTile" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
        <xs:field xpath="@TileValue" />
      </xs:unique>
      <xs:unique name="CategorizedTilesetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//CategorizedTileset" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="CategoryKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//TileCategory" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:keyref name="TilesetCategory" refer="TilesetKey">
        <xs:selector xpath=".//CategorizedTileset" />
        <xs:field xpath="@Tileset" />
      </xs:keyref>
      <xs:keyref name="TileCategoryCategorizedTileset" refer="CategoryKey" msdata:IsNested="true">
        <xs:selector xpath=".//CategorizedTileset" />
        <xs:field xpath="@Name" />
      </xs:keyref>
      <xs:keyref name="CategoryCategoryTile" refer="CategorizedTilesetKey" msdata:IsNested="true">
        <xs:selector xpath=".//CategoryTile" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
      </xs:keyref>
      <xs:keyref name="CategoryTileCategoryFrame" refer="CategoryTileKey" msdata:IsNested="true">
        <xs:selector xpath=".//CategoryFrame" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
        <xs:field xpath="@TileValue" />
      </xs:keyref>
      <xs:keyref name="MapProject" refer="MapKey" msdata:ConstraintOnly="true" msdata:DeleteRule="SetNull">
        <xs:selector xpath=".//Project" />
        <xs:field xpath="@StartMap" />
      </xs:keyref>
      <xs:keyref name="CategorySolidityShape" refer="CategoryKey">
        <xs:selector xpath=".//SolidityShape" />
        <xs:field xpath="@CategoryName" />
      </xs:keyref>
      <xs:keyref name="SoliditySolidityShape" refer="SolidityKey" msdata:IsNested="true">
        <xs:selector xpath=".//SolidityShape" />
        <xs:field xpath="@SolidityName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionCategory" refer="SpriteDefinitionKey">
        <xs:selector xpath=".//SpriteCategorySprite" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="SpriteCategorySpriteCategorySprite" refer="SpriteCategoryKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteCategorySprite" />
        <xs:field xpath="@CategoryName" />
      </xs:keyref>
      <xs:keyref name="FramesetSpriteState" refer="FramesetKey">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@FramesetName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionState" refer="SpriteDefinitionKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="SpriteStateFrame" refer="SpriteStateKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteFrame" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@StateName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionSpriteParameter" refer="SpriteDefinitionKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteParameter" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionSpriteRule" refer="SpriteDefinitionKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteRule" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="TilesetLayer" refer="TilesetKey">
        <xs:selector xpath=".//Layer" />
        <xs:field xpath="@Tileset" />
      </xs:keyref>
      <xs:keyref name="MapLayer" refer="MapKey" msdata:IsNested="true">
        <xs:selector xpath=".//Layer" />
        <xs:field xpath="@MapName" />
      </xs:keyref>
      <xs:keyref name="LayerSpritePlan" refer="LayerKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpritePlan" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
      </xs:keyref>
      <xs:keyref name="SpritePlanPlanParameterValue" refer="SpritePlanKey" msdata:IsNested="true">
        <xs:selector xpath=".//PlanParameterValue" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
      </xs:keyref>
      <xs:keyref name="SpritePlanPlanRule" refer="SpritePlanKey" msdata:IsNested="true">
        <xs:selector xpath=".//PlanRule" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
      </xs:keyref>
      <xs:keyref name="SpritePlanCoordinate" refer="SpritePlanKey" msdata:IsNested="true">
        <xs:selector xpath=".//Coordinate" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionSprite" refer="SpriteStateKey">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@StateName" />
      </xs:keyref>
      <xs:keyref name="LayerSprite" refer="LayerKey" msdata:IsNested="true">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
      </xs:keyref>
      <xs:keyref name="SpriteParameterParameterValue" refer="SpriteParameterKey">
        <xs:selector xpath=".//ParameterValue" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@ParameterName" />
      </xs:keyref>
      <xs:keyref name="SpriteParameterValue" refer="SpriteKeyWithDefinition" msdata:IsNested="true">
        <xs:selector xpath=".//ParameterValue" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@SpriteName" />
        <xs:field xpath="@MapName" />
      </xs:keyref>
      <xs:keyref name="FramesetTileset" refer="FramesetKey">
        <xs:selector xpath=".//Tileset" />
        <xs:field xpath="@Frameset" />
      </xs:keyref>
      <xs:keyref name="CounterTile" refer="CounterKey" msdata:DeleteRule="SetNull">
        <xs:selector xpath=".//Tile" />
        <xs:field xpath="@Counter" />
      </xs:keyref>
      <xs:keyref name="TilesetTile" refer="TilesetKey" msdata:IsNested="true">
        <xs:selector xpath=".//Tile" />
        <xs:field xpath="@Name" />
      </xs:keyref>
      <xs:keyref name="TileTileFrame" refer="TileKey" msdata:IsNested="true">
        <xs:selector xpath=".//TileFrame" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@TileValue" />
      </xs:keyref>
      <xs:keyref name="GraphicSheetFrame" refer="GraphicSheetKey" msdata:ConstraintOnly="true" msdata:DeleteRule="None">
        <xs:selector xpath=".//Frame" />
        <xs:field xpath="@GraphicSheet" />
      </xs:keyref>
      <xs:keyref name="FramesetFrame" refer="FramesetKey" msdata:IsNested="true">
        <xs:selector xpath=".//Frame" />
        <xs:field xpath="@Name" />
      </xs:keyref>
    </xs:element>
  </xs:schema>
  <GraphicSheet Name="CoolFont" Columns="24" Rows="5" CellWidth="13" CellHeight="18">
    <Image>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</Image>
  </GraphicSheet>
  <GraphicSheet Name="FireFont" Columns="24" Rows="4" CellWidth="13" CellHeight="18">
    <Image>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</Image>
  </GraphicSheet>
  <GraphicSheet Name="Main" Columns="16" Rows="10" CellWidth="32" CellHeight="32">
    <Image>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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</Image>
  </GraphicSheet>
  <GraphicSheet Name="NanoBots" Columns="16" Rows="8" CellWidth="16" CellHeight="16">
    <Image>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/48tWbLElgKIajOcXSgyyC7QPqMJRkb3RPewNHCfCMo9JPizqFSHffRgpvBjQpLJ74jXAohudiqlBp3kGvhIIeCdcdHvM8CN5CEdSHOJXVqKT9+Ilin4I1kHsBJMFR7y/DWU6vt40Ap/TYLXtzfB59k36I9uGvmff/4nif8SfZR/xCkmgNl+4YBeBZUNyqhfZD0zj0ZUTPLZgHQflTxE++n/xltMr8bqiHYB6A2mEIRYk3xsRfetSCDtKIeR0L9E5WEq11B5lwrtM0tJWrXZ3+MUC7g/LU20I2tAbRTo28GIv4Ry/voUn9F1YA08LoSfZgc+ZHRcmQqMPP8O8ah/h+j0bRNd3u1iUVeNOIunAvf3yXE9WwQg9FSm4mRNAdDXFAr67YgOAlIM4AaLRm1F961uTL2PXaEhwi8dJPgZVIYowl8TwwUYaAtAf5sOpADpLcM+etuQMt+fZvs9QoJ9NDrFZ/bbcB4pC8P/nAQzAmmCz4hAlfil72XxhZ+Kr0rc3bZFZPFiIKvewscHjAAUQVS6DbP5itViNb1X1SGx1/gju2DnhumkHMxDoPupRlEtFDv3YKf5/p6D6yMlKB6lT6MUX38aVmIC9SKl46/iIsoOzELBd+zjqb/9Icp1mAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACcRP4P8BVu5LdA1b9tIAAAAASUVORK5CYII=</Image>
  </GraphicSheet>
  <Frameset Name="CoolFontFrames">
    <Frame FrameValue="6" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="7" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="8" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="9" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="10" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="11" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="12" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="13" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="14" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="15" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="16" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="17" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="18" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="19" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="20" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="21" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="22" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="23" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="24" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="25" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="26" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="27" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="28" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="29" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="30" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="31" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="33" GraphicSheet="CoolFont" CellIndex="0" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="34" GraphicSheet="CoolFont" CellIndex="1" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="35" GraphicSheet="CoolFont" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="36" GraphicSheet="CoolFont" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="37" GraphicSheet="CoolFont" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="38" GraphicSheet="CoolFont" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="39" GraphicSheet="CoolFont" CellIndex="6" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="40" GraphicSheet="CoolFont" CellIndex="7" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="41" GraphicSheet="CoolFont" CellIndex="8" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="42" GraphicSheet="CoolFont" CellIndex="9" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="43" GraphicSheet="CoolFont" CellIndex="10" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="44" GraphicSheet="CoolFont" CellIndex="11" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="45" GraphicSheet="CoolFont" CellIndex="12" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="46" GraphicSheet="CoolFont" CellIndex="13" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="47" GraphicSheet="CoolFont" CellIndex="14" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="48" GraphicSheet="CoolFont" CellIndex="15" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="49" GraphicSheet="CoolFont" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="50" GraphicSheet="CoolFont" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="51" GraphicSheet="CoolFont" CellIndex="18" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="52" GraphicSheet="CoolFont" CellIndex="19" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="53" GraphicSheet="CoolFont" CellIndex="20" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="54" GraphicSheet="CoolFont" CellIndex="21" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="55" GraphicSheet="CoolFont" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="56" GraphicSheet="CoolFont" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="57" GraphicSheet="CoolFont" CellIndex="24" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="58" GraphicSheet="CoolFont" CellIndex="25" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="59" GraphicSheet="CoolFont" CellIndex="26" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="60" GraphicSheet="CoolFont" CellIndex="27" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="61" GraphicSheet="CoolFont" CellIndex="28" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="62" GraphicSheet="CoolFont" CellIndex="29" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="63" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="64" GraphicSheet="CoolFont" CellIndex="31" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="65" GraphicSheet="CoolFont" CellIndex="32" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="66" GraphicSheet="CoolFont" CellIndex="33" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="67" GraphicSheet="CoolFont" CellIndex="34" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="68" GraphicSheet="CoolFont" CellIndex="35" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="69" GraphicSheet="CoolFont" CellIndex="36" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="70" GraphicSheet="CoolFont" CellIndex="37" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="71" GraphicSheet="CoolFont" CellIndex="38" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="72" GraphicSheet="CoolFont" CellIndex="39" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="73" GraphicSheet="CoolFont" CellIndex="40" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="74" GraphicSheet="CoolFont" CellIndex="41" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="75" GraphicSheet="CoolFont" CellIndex="42" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="76" GraphicSheet="CoolFont" CellIndex="43" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="77" GraphicSheet="CoolFont" CellIndex="44" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="78" GraphicSheet="CoolFont" CellIndex="45" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="79" GraphicSheet="CoolFont" CellIndex="46" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="80" GraphicSheet="CoolFont" CellIndex="47" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="81" GraphicSheet="CoolFont" CellIndex="48" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="82" GraphicSheet="CoolFont" CellIndex="49" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="83" GraphicSheet="CoolFont" CellIndex="50" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="84" GraphicSheet="CoolFont" CellIndex="51" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="85" GraphicSheet="CoolFont" CellIndex="52" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="86" GraphicSheet="CoolFont" CellIndex="53" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="87" GraphicSheet="CoolFont" CellIndex="54" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="88" GraphicSheet="CoolFont" CellIndex="55" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="89" GraphicSheet="CoolFont" CellIndex="56" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="90" GraphicSheet="CoolFont" CellIndex="57" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="91" GraphicSheet="CoolFont" CellIndex="58" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="92" GraphicSheet="CoolFont" CellIndex="59" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="93" GraphicSheet="CoolFont" CellIndex="60" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="94" GraphicSheet="CoolFont" CellIndex="61" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="95" GraphicSheet="CoolFont" CellIndex="62" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="96" GraphicSheet="CoolFont" CellIndex="63" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="97" GraphicSheet="CoolFont" CellIndex="64" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="98" GraphicSheet="CoolFont" CellIndex="65" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="99" GraphicSheet="CoolFont" CellIndex="66" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="100" GraphicSheet="CoolFont" CellIndex="67" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="101" GraphicSheet="CoolFont" CellIndex="68" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="102" GraphicSheet="CoolFont" CellIndex="69" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="103" GraphicSheet="CoolFont" CellIndex="70" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="104" GraphicSheet="CoolFont" CellIndex="71" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="105" GraphicSheet="CoolFont" CellIndex="72" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="106" GraphicSheet="CoolFont" CellIndex="73" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="107" GraphicSheet="CoolFont" CellIndex="74" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="108" GraphicSheet="CoolFont" CellIndex="75" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="109" GraphicSheet="CoolFont" CellIndex="76" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="110" GraphicSheet="CoolFont" CellIndex="77" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="111" GraphicSheet="CoolFont" CellIndex="78" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="112" GraphicSheet="CoolFont" CellIndex="79" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="113" GraphicSheet="CoolFont" CellIndex="80" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="114" GraphicSheet="CoolFont" CellIndex="81" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="115" GraphicSheet="CoolFont" CellIndex="82" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="116" GraphicSheet="CoolFont" CellIndex="83" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="117" GraphicSheet="CoolFont" CellIndex="84" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="118" GraphicSheet="CoolFont" CellIndex="85" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="119" GraphicSheet="CoolFont" CellIndex="86" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="120" GraphicSheet="CoolFont" CellIndex="87" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="121" GraphicSheet="CoolFont" CellIndex="88" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="122" GraphicSheet="CoolFont" CellIndex="89" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="123" GraphicSheet="CoolFont" CellIndex="90" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="124" GraphicSheet="CoolFont" CellIndex="91" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="125" GraphicSheet="CoolFont" CellIndex="92" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="126" GraphicSheet="CoolFont" CellIndex="93" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="127" GraphicSheet="CoolFont" CellIndex="94" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="128" GraphicSheet="CoolFont" CellIndex="95" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="32" GraphicSheet="CoolFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="129" GraphicSheet="CoolFont" CellIndex="76" m11="1" m12="0" m21="0" m22="1" dx="10" dy="0" color="-1" />
    <Frame FrameValue="130" GraphicSheet="CoolFont" CellIndex="79" m11="1" m12="0" m21="0" m22="1" dx="20" dy="0" color="-1" />
    <Frame FrameValue="131" GraphicSheet="CoolFont" CellIndex="83" m11="1" m12="0" m21="0" m22="1" dx="30" dy="0" color="-1" />
    <Frame FrameValue="132" GraphicSheet="CoolFont" CellIndex="88" m11="1" m12="0" m21="0" m22="1" dx="40" dy="0" color="-1" />
    <Frame FrameValue="133" GraphicSheet="CoolFont" CellIndex="84" m11="1" m12="0" m21="0" m22="1" dx="10" dy="0" color="-1" />
    <Frame FrameValue="134" GraphicSheet="CoolFont" CellIndex="75" m11="1" m12="0" m21="0" m22="1" dx="20" dy="0" color="-1" />
    <Frame FrameValue="135" GraphicSheet="CoolFont" CellIndex="75" m11="1" m12="0" m21="0" m22="1" dx="30" dy="0" color="-1" />
    <Frame FrameValue="136" GraphicSheet="CoolFont" CellIndex="96" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="137" GraphicSheet="CoolFont" CellIndex="97" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="0" GraphicSheet="NanoBots" CellIndex="12" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="NanoBots" CellIndex="13" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="NanoBots" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="NanoBots" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="NanoBots" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="NanoBots" CellIndex="14" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="FireFontFrames">
    <Frame FrameValue="0" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="6" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="7" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="8" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="9" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="10" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="11" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="12" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="13" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="14" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="15" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="16" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="17" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="18" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="19" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="20" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="21" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="22" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="23" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="24" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="25" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="26" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="27" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="28" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="29" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="30" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="31" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="33" GraphicSheet="FireFont" CellIndex="0" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="34" GraphicSheet="FireFont" CellIndex="1" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="35" GraphicSheet="FireFont" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="36" GraphicSheet="FireFont" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="37" GraphicSheet="FireFont" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="38" GraphicSheet="FireFont" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="39" GraphicSheet="FireFont" CellIndex="6" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="40" GraphicSheet="FireFont" CellIndex="7" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="41" GraphicSheet="FireFont" CellIndex="8" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="42" GraphicSheet="FireFont" CellIndex="9" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="43" GraphicSheet="FireFont" CellIndex="10" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="44" GraphicSheet="FireFont" CellIndex="11" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="45" GraphicSheet="FireFont" CellIndex="12" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="46" GraphicSheet="FireFont" CellIndex="13" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="47" GraphicSheet="FireFont" CellIndex="14" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="48" GraphicSheet="FireFont" CellIndex="15" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="49" GraphicSheet="FireFont" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="50" GraphicSheet="FireFont" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="51" GraphicSheet="FireFont" CellIndex="18" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="52" GraphicSheet="FireFont" CellIndex="19" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="53" GraphicSheet="FireFont" CellIndex="20" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="54" GraphicSheet="FireFont" CellIndex="21" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="55" GraphicSheet="FireFont" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="56" GraphicSheet="FireFont" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="57" GraphicSheet="FireFont" CellIndex="24" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="58" GraphicSheet="FireFont" CellIndex="25" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="59" GraphicSheet="FireFont" CellIndex="26" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="60" GraphicSheet="FireFont" CellIndex="27" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="61" GraphicSheet="FireFont" CellIndex="28" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="62" GraphicSheet="FireFont" CellIndex="29" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="63" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="64" GraphicSheet="FireFont" CellIndex="31" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="65" GraphicSheet="FireFont" CellIndex="32" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="66" GraphicSheet="FireFont" CellIndex="33" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="67" GraphicSheet="FireFont" CellIndex="34" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="68" GraphicSheet="FireFont" CellIndex="35" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="69" GraphicSheet="FireFont" CellIndex="36" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="70" GraphicSheet="FireFont" CellIndex="37" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="71" GraphicSheet="FireFont" CellIndex="38" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="72" GraphicSheet="FireFont" CellIndex="39" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="73" GraphicSheet="FireFont" CellIndex="40" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="74" GraphicSheet="FireFont" CellIndex="41" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="75" GraphicSheet="FireFont" CellIndex="42" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="76" GraphicSheet="FireFont" CellIndex="43" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="77" GraphicSheet="FireFont" CellIndex="44" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="78" GraphicSheet="FireFont" CellIndex="45" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="79" GraphicSheet="FireFont" CellIndex="46" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="80" GraphicSheet="FireFont" CellIndex="47" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="81" GraphicSheet="FireFont" CellIndex="48" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="82" GraphicSheet="FireFont" CellIndex="49" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="83" GraphicSheet="FireFont" CellIndex="50" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="84" GraphicSheet="FireFont" CellIndex="51" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="85" GraphicSheet="FireFont" CellIndex="52" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="86" GraphicSheet="FireFont" CellIndex="53" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="87" GraphicSheet="FireFont" CellIndex="54" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="88" GraphicSheet="FireFont" CellIndex="55" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="89" GraphicSheet="FireFont" CellIndex="56" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="90" GraphicSheet="FireFont" CellIndex="57" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="91" GraphicSheet="FireFont" CellIndex="58" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="92" GraphicSheet="FireFont" CellIndex="59" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="93" GraphicSheet="FireFont" CellIndex="60" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="94" GraphicSheet="FireFont" CellIndex="61" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="95" GraphicSheet="FireFont" CellIndex="62" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="96" GraphicSheet="FireFont" CellIndex="63" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="97" GraphicSheet="FireFont" CellIndex="64" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="98" GraphicSheet="FireFont" CellIndex="65" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="99" GraphicSheet="FireFont" CellIndex="66" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="100" GraphicSheet="FireFont" CellIndex="67" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="101" GraphicSheet="FireFont" CellIndex="68" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="102" GraphicSheet="FireFont" CellIndex="69" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="103" GraphicSheet="FireFont" CellIndex="70" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="104" GraphicSheet="FireFont" CellIndex="71" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="105" GraphicSheet="FireFont" CellIndex="72" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="106" GraphicSheet="FireFont" CellIndex="73" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="107" GraphicSheet="FireFont" CellIndex="74" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="108" GraphicSheet="FireFont" CellIndex="75" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="109" GraphicSheet="FireFont" CellIndex="76" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="110" GraphicSheet="FireFont" CellIndex="77" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="111" GraphicSheet="FireFont" CellIndex="78" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="112" GraphicSheet="FireFont" CellIndex="79" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="113" GraphicSheet="FireFont" CellIndex="80" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="114" GraphicSheet="FireFont" CellIndex="81" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="115" GraphicSheet="FireFont" CellIndex="82" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="116" GraphicSheet="FireFont" CellIndex="83" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="117" GraphicSheet="FireFont" CellIndex="84" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="118" GraphicSheet="FireFont" CellIndex="85" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="119" GraphicSheet="FireFont" CellIndex="86" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="120" GraphicSheet="FireFont" CellIndex="87" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="121" GraphicSheet="FireFont" CellIndex="88" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="122" GraphicSheet="FireFont" CellIndex="89" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="123" GraphicSheet="FireFont" CellIndex="90" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="124" GraphicSheet="FireFont" CellIndex="91" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="125" GraphicSheet="FireFont" CellIndex="92" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="126" GraphicSheet="FireFont" CellIndex="93" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="127" GraphicSheet="FireFont" CellIndex="94" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="128" GraphicSheet="FireFont" CellIndex="95" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="32" GraphicSheet="FireFont" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="MainFrames">
    <Frame FrameValue="27" GraphicSheet="Main" CellIndex="20" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="28" GraphicSheet="Main" CellIndex="21" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="29" GraphicSheet="Main" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="30" GraphicSheet="Main" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="31" GraphicSheet="Main" CellIndex="24" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="32" GraphicSheet="Main" CellIndex="25" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="33" GraphicSheet="Main" CellIndex="26" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="34" GraphicSheet="Main" CellIndex="36" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="35" GraphicSheet="Main" CellIndex="37" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="36" GraphicSheet="Main" CellIndex="38" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="37" GraphicSheet="Main" CellIndex="39" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="38" GraphicSheet="Main" CellIndex="40" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="39" GraphicSheet="Main" CellIndex="41" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="40" GraphicSheet="Main" CellIndex="42" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="1" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="10" GraphicSheet="Main" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8388608" />
    <Frame FrameValue="11" GraphicSheet="Main" CellIndex="3" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-8388608" />
    <Frame FrameValue="12" GraphicSheet="Main" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8388608" />
    <Frame FrameValue="13" GraphicSheet="Main" CellIndex="6" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8388608" />
    <Frame FrameValue="14" GraphicSheet="Main" CellIndex="6" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-8388608" />
    <Frame FrameValue="15" GraphicSheet="Main" CellIndex="5" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-8388608" />
    <Frame FrameValue="16" GraphicSheet="Main" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8388608" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16744448" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16744448" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="3" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-16744448" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16744448" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="6" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16744448" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="6" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-16744448" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="5" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-16744448" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16744448" />
    <Frame FrameValue="17" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14663425" />
    <Frame FrameValue="18" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14679868" />
    <Frame FrameValue="49" GraphicSheet="Main" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="50" GraphicSheet="Main" CellIndex="16" m11="0.75" m12="0" m21="0" m22="1" dx="4" dy="0" color="-1" />
    <Frame FrameValue="51" GraphicSheet="Main" CellIndex="16" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-1" />
    <Frame FrameValue="52" GraphicSheet="Main" CellIndex="16" m11="0.25" m12="0" m21="0" m22="1" dx="12" dy="0" color="-1" />
    <Frame FrameValue="53" GraphicSheet="Main" CellIndex="32" m11="0.25" m12="0" m21="0" m22="1" dx="12" dy="0" color="-1" />
    <Frame FrameValue="54" GraphicSheet="Main" CellIndex="32" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-1" />
    <Frame FrameValue="55" GraphicSheet="Main" CellIndex="32" m11="0.75" m12="0" m21="0" m22="1" dx="4" dy="0" color="-1" />
    <Frame FrameValue="56" GraphicSheet="Main" CellIndex="32" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="41" GraphicSheet="Main" CellIndex="33" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="42" GraphicSheet="Main" CellIndex="34" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="43" GraphicSheet="Main" CellIndex="35" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="44" GraphicSheet="Main" CellIndex="49" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="45" GraphicSheet="Main" CellIndex="33" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="46" GraphicSheet="Main" CellIndex="34" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="47" GraphicSheet="Main" CellIndex="35" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="48" GraphicSheet="Main" CellIndex="49" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="19" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="20" GraphicSheet="Main" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="21" GraphicSheet="Main" CellIndex="3" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="22" GraphicSheet="Main" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="23" GraphicSheet="Main" CellIndex="6" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="24" GraphicSheet="Main" CellIndex="6" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="25" GraphicSheet="Main" CellIndex="5" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="26" GraphicSheet="Main" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="57" GraphicSheet="Main" CellIndex="7" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="58" GraphicSheet="Main" CellIndex="8" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="59" GraphicSheet="Main" CellIndex="9" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="60" GraphicSheet="Main" CellIndex="10" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="61" GraphicSheet="Main" CellIndex="70" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="62" GraphicSheet="Main" CellIndex="15" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="63" GraphicSheet="Main" CellIndex="68" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="64" GraphicSheet="Main" CellIndex="69" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="65" GraphicSheet="Main" CellIndex="83" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="66" GraphicSheet="Main" CellIndex="78" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="67" GraphicSheet="Main" CellIndex="79" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="68" GraphicSheet="Main" CellIndex="46" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="69" GraphicSheet="Main" CellIndex="85" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="70" GraphicSheet="Main" CellIndex="86" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="71" GraphicSheet="Main" CellIndex="87" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="72" GraphicSheet="Main" CellIndex="88" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="73" GraphicSheet="Main" CellIndex="89" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="82" GraphicSheet="Main" CellIndex="90" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="75" GraphicSheet="Main" CellIndex="85" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-14623680" />
    <Frame FrameValue="76" GraphicSheet="Main" CellIndex="86" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-14623680" />
    <Frame FrameValue="77" GraphicSheet="Main" CellIndex="87" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-14623680" />
    <Frame FrameValue="78" GraphicSheet="Main" CellIndex="88" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-14623680" />
    <Frame FrameValue="79" GraphicSheet="Main" CellIndex="85" m11="0" m12="1" m21="1" m22="0" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="80" GraphicSheet="Main" CellIndex="86" m11="0" m12="1" m21="1" m22="0" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="81" GraphicSheet="Main" CellIndex="87" m11="0" m12="1" m21="1" m22="0" dx="0" dy="0" color="-14623680" />
    <Frame FrameValue="74" GraphicSheet="Main" CellIndex="89" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-14623680" />
    <Frame FrameValue="83" GraphicSheet="Main" CellIndex="11" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="85" GraphicSheet="Main" CellIndex="19" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-65536" />
    <Frame FrameValue="84" GraphicSheet="Main" CellIndex="97" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-65536" />
    <Frame FrameValue="86" GraphicSheet="Main" CellIndex="116" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="87" GraphicSheet="Main" CellIndex="117" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="88" GraphicSheet="Main" CellIndex="118" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="89" GraphicSheet="Main" CellIndex="118" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="90" GraphicSheet="Main" CellIndex="119" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-3881729" />
    <Frame FrameValue="91" GraphicSheet="Main" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="92" GraphicSheet="Main" CellIndex="120" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="93" GraphicSheet="Main" CellIndex="120" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8388608" />
    <Frame FrameValue="94" GraphicSheet="Main" CellIndex="126" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="95" GraphicSheet="Main" CellIndex="127" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="96" GraphicSheet="CoolFont" CellIndex="44" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="97" GraphicSheet="CoolFont" CellIndex="68" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="98" GraphicSheet="CoolFont" CellIndex="82" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="99" GraphicSheet="CoolFont" CellIndex="64" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="100" GraphicSheet="CoolFont" CellIndex="70" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="101" GraphicSheet="CoolFont" CellIndex="68" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="102" GraphicSheet="CoolFont" CellIndex="19" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="103" GraphicSheet="CoolFont" CellIndex="52" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="104" GraphicSheet="CoolFont" CellIndex="72" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="105" GraphicSheet="CoolFont" CellIndex="81" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="106" GraphicSheet="CoolFont" CellIndex="0" m11="1" m12="0" m21="0" m22="1" dx="9" dy="6" color="-1" />
    <Frame FrameValue="108" GraphicSheet="Main" CellIndex="31" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="107" GraphicSheet="Main" CellIndex="30" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="113" GraphicSheet="Main" CellIndex="130" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="114" GraphicSheet="Main" CellIndex="131" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-256" />
    <Frame FrameValue="115" GraphicSheet="Main" CellIndex="131" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-65281" />
    <Frame FrameValue="116" GraphicSheet="Main" CellIndex="131" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16711681" />
    <Frame FrameValue="117" GraphicSheet="Main" CellIndex="131" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16711936" />
    <Frame FrameValue="109" GraphicSheet="Main" CellIndex="129" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-256" />
    <Frame FrameValue="110" GraphicSheet="Main" CellIndex="129" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-65281" />
    <Frame FrameValue="111" GraphicSheet="Main" CellIndex="129" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16711681" />
    <Frame FrameValue="112" GraphicSheet="Main" CellIndex="129" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16711936" />
    <Frame FrameValue="118" GraphicSheet="Main" CellIndex="14" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="119" GraphicSheet="Main" CellIndex="133" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="120" GraphicSheet="Main" CellIndex="3" m11="1" m12="0" m21="0" m22="-1" dx="0" dy="32" color="-16744448" />
    <Frame FrameValue="121" GraphicSheet="Main" CellIndex="3" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-16744448" />
    <Frame FrameValue="122" GraphicSheet="Main" CellIndex="3" m11="1" m12="0" m21="0" m22="-1" dx="0" dy="32" color="-8388608" />
    <Frame FrameValue="123" GraphicSheet="Main" CellIndex="3" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8388608" />
    <Frame FrameValue="124" GraphicSheet="Main" CellIndex="3" m11="1" m12="0" m21="0" m22="-1" dx="0" dy="32" color="-1" />
    <Frame FrameValue="125" GraphicSheet="Main" CellIndex="3" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-1" />
    <Frame FrameValue="126" GraphicSheet="Main" CellIndex="134" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="127" GraphicSheet="Main" CellIndex="135" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="128" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-12582912" />
    <Frame FrameValue="129" GraphicSheet="Main" CellIndex="16" m11="0.5" m12="0" m21="0" m22="0.5" dx="8" dy="16" color="-1" />
  </Frameset>
  <Frameset Name="PlayerFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="33" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="34" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="35" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="49" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="33" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="34" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="35" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="49" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="91" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="92" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="11" GraphicSheet="Main" CellIndex="91" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="10" GraphicSheet="Main" CellIndex="92" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="12" GraphicSheet="Main" CellIndex="93" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="13" GraphicSheet="Main" CellIndex="94" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="14" GraphicSheet="Main" CellIndex="95" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="15" GraphicSheet="Main" CellIndex="93" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="16" GraphicSheet="Main" CellIndex="94" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="17" GraphicSheet="Main" CellIndex="95" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="18" GraphicSheet="Main" CellIndex="96" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="0" color="-1" />
    <Frame FrameValue="19" GraphicSheet="Main" CellIndex="96" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="0" color="-1" />
    <Frame FrameValue="20" GraphicSheet="Main" CellIndex="110" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="21" GraphicSheet="Main" CellIndex="111" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="23" GraphicSheet="Main" CellIndex="110" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-1" />
    <Frame FrameValue="24" GraphicSheet="Main" CellIndex="111" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-1" />
    <Frame FrameValue="26" GraphicSheet="Main" CellIndex="110" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-1" />
    <Frame FrameValue="27" GraphicSheet="Main" CellIndex="111" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-1" />
    <Frame FrameValue="29" GraphicSheet="Main" CellIndex="110" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-1" />
    <Frame FrameValue="30" GraphicSheet="Main" CellIndex="111" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-1" />
    <Frame FrameValue="22" GraphicSheet="Main" CellIndex="110" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="25" GraphicSheet="Main" CellIndex="110" m11="0" m12="-1" m21="-1" m22="0" dx="32" dy="32" color="-1" />
    <Frame FrameValue="28" GraphicSheet="Main" CellIndex="110" m11="1" m12="0" m21="0" m22="-1" dx="0" dy="32" color="-1" />
    <Frame FrameValue="31" GraphicSheet="Main" CellIndex="110" m11="0" m12="1" m21="1" m22="0" dx="0" dy="0" color="-1" />
    <Frame FrameValue="32" GraphicSheet="Main" CellIndex="112" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="Explosion">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="71" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="72" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="73" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="74" m11="1.1" m12="0" m21="0" m22="1.1" dx="-2" dy="-2" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="75" m11="1.3" m12="0" m21="0" m22="1.3" dx="-5" dy="-5" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="76" m11="1.5" m12="0" m21="0" m22="1.5" dx="-7" dy="-7" color="-1" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="77" m11="1.7" m12="0" m21="0" m22="1.7" dx="-10" dy="-10" color="-1" />
  </Frameset>
  <Frameset Name="BombFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="50" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="51" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="52" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="53" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="54" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="55" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="56" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="57" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="58" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="59" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="10" GraphicSheet="Main" CellIndex="60" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="11" GraphicSheet="Main" CellIndex="61" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="12" GraphicSheet="Main" CellIndex="62" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="13" GraphicSheet="Main" CellIndex="63" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="14" GraphicSheet="Main" CellIndex="64" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="15" GraphicSheet="Main" CellIndex="65" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="16" GraphicSheet="Main" CellIndex="66" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
    <Frame FrameValue="17" GraphicSheet="Main" CellIndex="67" m11="1" m12="0" m21="0" m22="1" dx="-8" dy="-16" color="-1" />
  </Frameset>
  <Frameset Name="Worm">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="43" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-32513" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="44" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-32513" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="45" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-32513" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="44" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-32513" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="45" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-32513" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="43" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-32513" />
  </Frameset>
  <Frameset Name="Bombot">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="80" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="81" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="82" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="80" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="81" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="82" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="IgniterFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="46" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="47" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="48" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="47" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="48" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="Platform">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="WorldMapFrames">
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="99" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="99" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="99" m11="1" m12="0" m21="0" m22="-1" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="99" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="100" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="10" GraphicSheet="Main" CellIndex="100" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="11" GraphicSheet="Main" CellIndex="101" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="12" GraphicSheet="Main" CellIndex="101" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="13" GraphicSheet="Main" CellIndex="101" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-16726016" />
    <Frame FrameValue="14" GraphicSheet="Main" CellIndex="101" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="15" GraphicSheet="Main" CellIndex="102" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="16" GraphicSheet="Main" CellIndex="102" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="17" GraphicSheet="Main" CellIndex="102" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-16726016" />
    <Frame FrameValue="18" GraphicSheet="Main" CellIndex="102" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="19" GraphicSheet="Main" CellIndex="103" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="20" GraphicSheet="Main" CellIndex="108" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="21" GraphicSheet="Main" CellIndex="108" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="22" GraphicSheet="Main" CellIndex="108" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-16726016" />
    <Frame FrameValue="23" GraphicSheet="Main" CellIndex="108" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="24" GraphicSheet="Main" CellIndex="105" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="25" GraphicSheet="Main" CellIndex="105" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="105" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-10477568" />
    <Frame FrameValue="27" GraphicSheet="Main" CellIndex="105" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="28" GraphicSheet="Main" CellIndex="109" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="29" GraphicSheet="Main" CellIndex="109" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="30" GraphicSheet="Main" CellIndex="109" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-16726016" />
    <Frame FrameValue="31" GraphicSheet="Main" CellIndex="109" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="32" GraphicSheet="Main" CellIndex="106" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="33" GraphicSheet="Main" CellIndex="106" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="34" GraphicSheet="Main" CellIndex="106" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-16726016" />
    <Frame FrameValue="35" GraphicSheet="Main" CellIndex="106" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-16726016" />
    <Frame FrameValue="36" GraphicSheet="Main" CellIndex="107" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="37" GraphicSheet="Main" CellIndex="107" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="39" GraphicSheet="Main" CellIndex="99" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="40" GraphicSheet="Main" CellIndex="99" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="41" GraphicSheet="Main" CellIndex="99" m11="1" m12="0" m21="0" m22="-1" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="42" GraphicSheet="Main" CellIndex="99" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="43" GraphicSheet="Main" CellIndex="100" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="44" GraphicSheet="Main" CellIndex="100" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="45" GraphicSheet="Main" CellIndex="101" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="46" GraphicSheet="Main" CellIndex="101" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="47" GraphicSheet="Main" CellIndex="101" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8364032" />
    <Frame FrameValue="48" GraphicSheet="Main" CellIndex="101" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="49" GraphicSheet="Main" CellIndex="102" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="50" GraphicSheet="Main" CellIndex="102" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="51" GraphicSheet="Main" CellIndex="102" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8364032" />
    <Frame FrameValue="52" GraphicSheet="Main" CellIndex="102" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="53" GraphicSheet="Main" CellIndex="103" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="54" GraphicSheet="Main" CellIndex="108" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="55" GraphicSheet="Main" CellIndex="108" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="56" GraphicSheet="Main" CellIndex="108" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8364032" />
    <Frame FrameValue="57" GraphicSheet="Main" CellIndex="108" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="58" GraphicSheet="Main" CellIndex="105" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="59" GraphicSheet="Main" CellIndex="105" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="60" GraphicSheet="Main" CellIndex="105" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8364032" />
    <Frame FrameValue="61" GraphicSheet="Main" CellIndex="105" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="62" GraphicSheet="Main" CellIndex="109" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="63" GraphicSheet="Main" CellIndex="109" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="64" GraphicSheet="Main" CellIndex="109" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8364032" />
    <Frame FrameValue="65" GraphicSheet="Main" CellIndex="109" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="66" GraphicSheet="Main" CellIndex="106" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="67" GraphicSheet="Main" CellIndex="106" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="68" GraphicSheet="Main" CellIndex="106" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-8364032" />
    <Frame FrameValue="69" GraphicSheet="Main" CellIndex="106" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-8364032" />
    <Frame FrameValue="70" GraphicSheet="Main" CellIndex="107" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="71" GraphicSheet="Main" CellIndex="107" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-8364032" />
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16777088" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="104" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-10477568" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="104" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-16726016" />
    <Frame FrameValue="38" GraphicSheet="Main" CellIndex="104" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-8364032" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="105" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-10477568" />
    <Frame FrameValue="72" GraphicSheet="Main" CellIndex="104" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-16" color="-16736256" />
    <Frame FrameValue="73" GraphicSheet="Main" CellIndex="105" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-16" color="-16736256" />
    <Frame FrameValue="74" GraphicSheet="Main" CellIndex="105" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="-16" color="-16736256" />
    <Frame FrameValue="76" GraphicSheet="Main" CellIndex="105" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="16" color="-16736256" />
    <Frame FrameValue="77" GraphicSheet="Main" CellIndex="109" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-16" color="-16736256" />
    <Frame FrameValue="78" GraphicSheet="Main" CellIndex="109" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="-16" color="-16736256" />
    <Frame FrameValue="79" GraphicSheet="Main" CellIndex="109" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="16" color="-16736256" />
    <Frame FrameValue="80" GraphicSheet="Main" CellIndex="109" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="16" color="-16736256" />
    <Frame FrameValue="81" GraphicSheet="Main" CellIndex="106" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-16" color="-16736256" />
    <Frame FrameValue="82" GraphicSheet="Main" CellIndex="106" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="-16" color="-16736256" />
    <Frame FrameValue="83" GraphicSheet="Main" CellIndex="106" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="16" color="-16736256" />
    <Frame FrameValue="84" GraphicSheet="Main" CellIndex="106" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="16" color="-16736256" />
    <Frame FrameValue="85" GraphicSheet="Main" CellIndex="107" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-16" color="-16736256" />
    <Frame FrameValue="86" GraphicSheet="Main" CellIndex="107" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="-16" color="-16736256" />
    <Frame FrameValue="26" GraphicSheet="Main" CellIndex="105" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-16726016" />
    <Frame FrameValue="75" GraphicSheet="Main" CellIndex="105" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="-16" color="-16736256" />
    <Frame FrameValue="87" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-12566273" />
    <Frame FrameValue="88" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-48897" />
    <Frame FrameValue="89" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-49088" />
    <Frame FrameValue="90" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-192" />
    <Frame FrameValue="91" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-32704" />
    <Frame FrameValue="92" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-12566464" />
    <Frame FrameValue="93" GraphicSheet="Main" CellIndex="98" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="94" GraphicSheet="FireFont" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="95" GraphicSheet="FireFont" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="96" GraphicSheet="FireFont" CellIndex="18" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="97" GraphicSheet="FireFont" CellIndex="19" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="98" GraphicSheet="FireFont" CellIndex="20" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="99" GraphicSheet="FireFont" CellIndex="21" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="100" GraphicSheet="FireFont" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="101" GraphicSheet="FireFont" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="102" GraphicSheet="FireFont" CellIndex="24" m11="1" m12="0" m21="0" m22="1" dx="9" dy="8" color="-1" />
    <Frame FrameValue="103" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-12566273" />
    <Frame FrameValue="105" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-48897" />
    <Frame FrameValue="107" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-49088" />
    <Frame FrameValue="109" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-192" />
    <Frame FrameValue="111" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-32704" />
    <Frame FrameValue="113" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-12566464" />
    <Frame FrameValue="115" GraphicSheet="Main" CellIndex="98" m11="0.5" m12="0" m21="0" m22="1" dx="8" dy="0" color="-1" />
    <Frame FrameValue="104" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-12566273" />
    <Frame FrameValue="106" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-48897" />
    <Frame FrameValue="108" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-49088" />
    <Frame FrameValue="110" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-192" />
    <Frame FrameValue="112" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-32704" />
    <Frame FrameValue="114" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-12566464" />
    <Frame FrameValue="116" GraphicSheet="Main" CellIndex="98" m11="0.2" m12="0" m21="0" m22="1" dx="13" dy="0" color="-1" />
    <Frame FrameValue="117" GraphicSheet="Main" CellIndex="113" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-15232" />
    <Frame FrameValue="118" GraphicSheet="Main" CellIndex="114" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-15232" />
    <Frame FrameValue="119" GraphicSheet="Main" CellIndex="113" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-15232" />
  </Frameset>
  <Frameset Name="SeedFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="84" m11="0.9613" m12="-0.2756" m21="0.2756" m22="0.9613" dx="-8.7904" dy="6.03" color="-3899648" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="84" m11="0.9816" m12="-0.1908" m21="0.1908" m22="0.9816" dx="-6" dy="4" color="-3899648" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="84" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-3899648" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="84" m11="0.9848" m12="0.1736" m21="-0.1736" m22="0.9848" dx="6" dy="-3" color="-3899648" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="84" m11="0.9659" m12="0.2588" m21="-0.2588" m22="0.9659" dx="9" dy="-4" color="-3899648" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="115" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="RocketFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="12" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="12" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="12" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="12" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="13" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="13" m11="0" m12="1" m21="-1" m22="0" dx="32" dy="0" color="-1" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="13" m11="-1" m12="0" m21="0" m22="-1" dx="32" dy="32" color="-1" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="13" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="32" color="-1" />
  </Frameset>
  <Frameset Name="JumperFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="121" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="122" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="123" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="121" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="122" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="123" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="SpiderFrames">
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="125" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="124" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="125" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="NanoBotFrames">
    <Frame FrameValue="0" GraphicSheet="NanoBots" CellIndex="6" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="NanoBots" CellIndex="7" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="NanoBots" CellIndex="8" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="NanoBots" CellIndex="9" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="NanoBots" CellIndex="10" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="NanoBots" CellIndex="11" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="9" GraphicSheet="NanoBots" CellIndex="7" m11="-1" m12="0" m21="0" m22="-1" dx="16" dy="16" color="-1" />
    <Frame FrameValue="8" GraphicSheet="NanoBots" CellIndex="8" m11="-1" m12="0" m21="0" m22="-1" dx="16" dy="16" color="-1" />
    <Frame FrameValue="7" GraphicSheet="NanoBots" CellIndex="9" m11="-1" m12="0" m21="0" m22="-1" dx="16" dy="16" color="-1" />
    <Frame FrameValue="6" GraphicSheet="NanoBots" CellIndex="10" m11="-1" m12="0" m21="0" m22="-1" dx="16" dy="16" color="-1" />
    <Frame FrameValue="10" GraphicSheet="NanoBots" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="11" GraphicSheet="NanoBots" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="12" GraphicSheet="NanoBots" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="13" GraphicSheet="NanoBots" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="14" GraphicSheet="NanoBots" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="15" GraphicSheet="NanoBots" CellIndex="21" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="16" GraphicSheet="NanoBots" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="17" GraphicSheet="NanoBots" CellIndex="18" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="18" GraphicSheet="NanoBots" CellIndex="19" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="19" GraphicSheet="NanoBots" CellIndex="12" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="20" GraphicSheet="NanoBots" CellIndex="20" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="21" GraphicSheet="NanoBots" CellIndex="20" m11="0" m12="1" m21="-1" m22="0" dx="16" dy="0" color="-1" />
    <Frame FrameValue="22" GraphicSheet="NanoBots" CellIndex="20" m11="-1" m12="0" m21="0" m22="-1" dx="16" dy="16" color="-1" />
    <Frame FrameValue="23" GraphicSheet="NanoBots" CellIndex="20" m11="0" m12="-1" m21="1" m22="0" dx="0" dy="16" color="-1" />
    <Frame FrameValue="24" GraphicSheet="NanoBots" CellIndex="13" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="25" GraphicSheet="NanoBots" CellIndex="14" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="26" GraphicSheet="NanoBots" CellIndex="15" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="27" GraphicSheet="NanoBots" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="InventoryFrames">
    <Frame FrameValue="6" GraphicSheet="NanoBots" CellIndex="13" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="1" GraphicSheet="NanoBots" CellIndex="16" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="2" GraphicSheet="NanoBots" CellIndex="22" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="50" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="NanoBots" CellIndex="17" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="5" GraphicSheet="NanoBots" CellIndex="18" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="7" GraphicSheet="NanoBots" CellIndex="14" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="3" GraphicSheet="NanoBots" CellIndex="12" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-2134588220" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="133" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="10" GraphicSheet="Main" CellIndex="78" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="10" color="-1" />
    <Frame FrameValue="11" GraphicSheet="NanoBots" CellIndex="20" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="12" GraphicSheet="NanoBots" CellIndex="20" m11="0" m12="1" m21="-1" m22="0" dx="24" dy="8" color="-1" />
    <Frame FrameValue="13" GraphicSheet="NanoBots" CellIndex="20" m11="1" m12="0" m21="0" m22="-1" dx="8" dy="24" color="-1" />
    <Frame FrameValue="14" GraphicSheet="NanoBots" CellIndex="20" m11="0" m12="1" m21="1" m22="0" dx="8" dy="8" color="-1" />
    <Frame FrameValue="15" GraphicSheet="NanoBots" CellIndex="2" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="16" GraphicSheet="NanoBots" CellIndex="5" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="17" GraphicSheet="NanoBots" CellIndex="3" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
    <Frame FrameValue="18" GraphicSheet="NanoBots" CellIndex="4" m11="1" m12="0" m21="0" m22="1" dx="8" dy="8" color="-1" />
  </Frameset>
  <Frameset Name="InventorySelector">
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="128" m11="1.1" m12="0" m21="0" m22="1.1" dx="-1.6" dy="-1.6" color="-1" />
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="128" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="128" m11="1.2" m12="0" m21="0" m22="1.2" dx="-3.2" dy="-3.2" color="-1" />
  </Frameset>
  <Frameset Name="ThrownTorchFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="133" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="133" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="78" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="10" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="79" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="10" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="78" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="10" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="79" m11="-1" m12="0" m21="0" m22="1" dx="28" dy="10" color="-1" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="78" m11="1" m12="0" m21="0" m22="1" dx="6" dy="10" color="-1" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="79" m11="1" m12="0" m21="0" m22="1" dx="6" dy="10" color="-1" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="78" m11="-1" m12="0" m21="0" m22="1" dx="38" dy="10" color="-1" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="79" m11="-1" m12="0" m21="0" m22="1" dx="38" dy="10" color="-1" />
  </Frameset>
  <Frameset Name="EaterFrames">
    <Frame FrameValue="0" GraphicSheet="Main" CellIndex="138" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="Main" CellIndex="139" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="2" GraphicSheet="Main" CellIndex="140" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="3" GraphicSheet="Main" CellIndex="141" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="4" GraphicSheet="Main" CellIndex="142" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="5" GraphicSheet="Main" CellIndex="143" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="6" GraphicSheet="Main" CellIndex="138" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="7" GraphicSheet="Main" CellIndex="139" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="8" GraphicSheet="Main" CellIndex="140" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="9" GraphicSheet="Main" CellIndex="141" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="10" GraphicSheet="Main" CellIndex="142" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
    <Frame FrameValue="11" GraphicSheet="Main" CellIndex="143" m11="-1" m12="0" m21="0" m22="1" dx="32" dy="0" color="-1" />
  </Frameset>
  <Frameset Name="Sparkles">
    <Frame FrameValue="0" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="0" color="-1" />
    <Frame FrameValue="1" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-1" color="-436207617" />
    <Frame FrameValue="2" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-2" color="-855638017" />
    <Frame FrameValue="3" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-3" color="-1291845633" />
    <Frame FrameValue="4" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-4" color="-1711276033" />
    <Frame FrameValue="5" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-5" color="2147483647" />
    <Frame FrameValue="6" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-6" color="1728053247" />
    <Frame FrameValue="7" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-7" color="1291845631" />
    <Frame FrameValue="8" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-8" color="872415231" />
    <Frame FrameValue="9" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="0" dy="-9" color="436207615" />
    <Frame FrameValue="10" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-4" color="-1" />
    <Frame FrameValue="11" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-5" color="-436207617" />
    <Frame FrameValue="12" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-6" color="-855638017" />
    <Frame FrameValue="13" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-7" color="-1291845633" />
    <Frame FrameValue="14" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-8" color="-1711276033" />
    <Frame FrameValue="15" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-9" color="2147483647" />
    <Frame FrameValue="16" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-10" color="1728053247" />
    <Frame FrameValue="17" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-11" color="1291845631" />
    <Frame FrameValue="18" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-12" color="872415231" />
    <Frame FrameValue="19" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="3" dy="-13" color="436207615" />
    <Frame FrameValue="20" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-6" color="-1" />
    <Frame FrameValue="21" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-7" color="-436207617" />
    <Frame FrameValue="22" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-8" color="-855638017" />
    <Frame FrameValue="23" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-9" color="-1291845633" />
    <Frame FrameValue="24" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-10" color="-1711276033" />
    <Frame FrameValue="25" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-11" color="2147483647" />
    <Frame FrameValue="26" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-12" color="1728053247" />
    <Frame FrameValue="27" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-13" color="1291845631" />
    <Frame FrameValue="28" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-14" color="872415231" />
    <Frame FrameValue="29" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="-4" dy="-15" color="436207615" />
    <Frame FrameValue="30" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="0" color="-1" />
    <Frame FrameValue="31" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-1" color="-436207617" />
    <Frame FrameValue="32" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-2" color="-855638017" />
    <Frame FrameValue="33" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-3" color="-1291845633" />
    <Frame FrameValue="34" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-4" color="-1711276033" />
    <Frame FrameValue="35" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-5" color="2147483647" />
    <Frame FrameValue="36" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-6" color="1728053247" />
    <Frame FrameValue="37" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-7" color="1291845631" />
    <Frame FrameValue="38" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-8" color="872415231" />
    <Frame FrameValue="39" GraphicSheet="NanoBots" CellIndex="23" m11="1" m12="0" m21="0" m22="1" dx="2" dy="-9" color="436207615" />
  </Frameset>
  <Tileset Name="CoolText" Frameset="CoolFontFrames" TileWidth="11" TileHeight="15">
    <Tile TileValue="32" />
    <Tile TileValue="0" />
    <Tile TileValue="1" Counter="SaveSlot1">
      <TileFrame Sequence="0" FrameValue="69" Duration="0" />
      <TileFrame Sequence="1" FrameValue="129" Duration="0" />
      <TileFrame Sequence="2" FrameValue="130" Duration="0" />
      <TileFrame Sequence="3" FrameValue="131" Duration="0" />
      <TileFrame Sequence="4" FrameValue="132" Duration="1" />
      <TileFrame Sequence="5" FrameValue="70" Duration="0" />
      <TileFrame Sequence="6" FrameValue="133" Duration="0" />
      <TileFrame Sequence="7" FrameValue="134" Duration="0" />
      <TileFrame Sequence="8" FrameValue="135" Duration="1" />
    </Tile>
    <Tile TileValue="2" Counter="SaveSlot2">
      <TileFrame Sequence="0" FrameValue="69" Duration="0" />
      <TileFrame Sequence="1" FrameValue="129" Duration="0" />
      <TileFrame Sequence="2" FrameValue="130" Duration="0" />
      <TileFrame Sequence="3" FrameValue="131" Duration="0" />
      <TileFrame Sequence="4" FrameValue="132" Duration="1" />
      <TileFrame Sequence="5" FrameValue="70" Duration="0" />
      <TileFrame Sequence="6" FrameValue="133" Duration="0" />
      <TileFrame Sequence="7" FrameValue="134" Duration="0" />
      <TileFrame Sequence="8" FrameValue="135" Duration="1" />
    </Tile>
    <Tile TileValue="3" Counter="SaveSlot3">
      <TileFrame Sequence="0" FrameValue="69" Duration="0" />
      <TileFrame Sequence="1" FrameValue="129" Duration="0" />
      <TileFrame Sequence="2" FrameValue="130" Duration="0" />
      <TileFrame Sequence="3" FrameValue="131" Duration="0" />
      <TileFrame Sequence="4" FrameValue="132" Duration="1" />
      <TileFrame Sequence="5" FrameValue="70" Duration="0" />
      <TileFrame Sequence="6" FrameValue="133" Duration="0" />
      <TileFrame Sequence="7" FrameValue="134" Duration="0" />
      <TileFrame Sequence="8" FrameValue="135" Duration="1" />
    </Tile>
    <Tile TileValue="4" Counter="SaveSlotCP">
      <TileFrame Sequence="0" FrameValue="69" Duration="0" />
      <TileFrame Sequence="1" FrameValue="129" Duration="0" />
      <TileFrame Sequence="2" FrameValue="130" Duration="0" />
      <TileFrame Sequence="3" FrameValue="131" Duration="0" />
      <TileFrame Sequence="4" FrameValue="132" Duration="1" />
      <TileFrame Sequence="5" FrameValue="70" Duration="0" />
      <TileFrame Sequence="6" FrameValue="133" Duration="0" />
      <TileFrame Sequence="7" FrameValue="134" Duration="0" />
      <TileFrame Sequence="8" FrameValue="135" Duration="1" />
    </Tile>
    <Tile TileValue="8">
      <TileFrame Sequence="0" FrameValue="0" Duration="1" />
    </Tile>
    <Tile TileValue="9">
      <TileFrame Sequence="0" FrameValue="1" Duration="1" />
    </Tile>
    <Tile TileValue="11">
      <TileFrame Sequence="0" FrameValue="2" Duration="1" />
    </Tile>
    <Tile TileValue="12">
      <TileFrame Sequence="0" FrameValue="3" Duration="1" />
    </Tile>
    <Tile TileValue="14">
      <TileFrame Sequence="0" FrameValue="4" Duration="1" />
    </Tile>
    <Tile TileValue="15">
      <TileFrame Sequence="0" FrameValue="5" Duration="1" />
    </Tile>
    <Tile TileValue="129" Counter="CurrentSlot">
      <TileFrame Sequence="0" FrameValue="136" Duration="1" />
      <TileFrame Sequence="1" FrameValue="137" Duration="4" />
    </Tile>
    <Tile TileValue="130" Counter="CurrentSlot">
      <TileFrame Sequence="0" FrameValue="137" Duration="1" />
      <TileFrame Sequence="1" FrameValue="136" Duration="1" />
      <TileFrame Sequence="2" FrameValue="137" Duration="3" />
    </Tile>
    <Tile TileValue="131" Counter="CurrentSlot">
      <TileFrame Sequence="0" FrameValue="137" Duration="2" />
      <TileFrame Sequence="1" FrameValue="136" Duration="1" />
      <TileFrame Sequence="2" FrameValue="137" Duration="2" />
    </Tile>
    <Tile TileValue="132" Counter="CurrentSlot">
      <TileFrame Sequence="0" FrameValue="137" Duration="3" />
      <TileFrame Sequence="1" FrameValue="136" Duration="1" />
      <TileFrame Sequence="2" FrameValue="137" Duration="1" />
    </Tile>
    <Tile TileValue="133" Counter="CurrentSlot">
      <TileFrame Sequence="0" FrameValue="137" Duration="4" />
      <TileFrame Sequence="1" FrameValue="136" Duration="1" />
    </Tile>
  </Tileset>
  <Tileset Name="FireText" Frameset="FireFontFrames" TileWidth="11" TileHeight="15">
    <Tile TileValue="32" />
    <Tile TileValue="0" />
  </Tileset>
  <Tileset Name="MainTiles" Frameset="MainFrames" TileWidth="32" TileHeight="32">
    <Tile TileValue="50" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="27" Duration="4" />
      <TileFrame Sequence="1" FrameValue="28" Duration="4" />
      <TileFrame Sequence="2" FrameValue="29" Duration="4" />
      <TileFrame Sequence="3" FrameValue="30" Duration="4" />
      <TileFrame Sequence="4" FrameValue="31" Duration="4" />
      <TileFrame Sequence="5" FrameValue="32" Duration="4" />
      <TileFrame Sequence="6" FrameValue="33" Duration="4" />
    </Tile>
    <Tile TileValue="51" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="34" Duration="4" />
      <TileFrame Sequence="1" FrameValue="35" Duration="4" />
      <TileFrame Sequence="2" FrameValue="36" Duration="4" />
      <TileFrame Sequence="3" FrameValue="37" Duration="4" />
      <TileFrame Sequence="4" FrameValue="38" Duration="4" />
      <TileFrame Sequence="5" FrameValue="39" Duration="4" />
      <TileFrame Sequence="6" FrameValue="40" Duration="4" />
    </Tile>
    <Tile TileValue="52" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="49" Duration="4" />
      <TileFrame Sequence="1" FrameValue="50" Duration="4" />
      <TileFrame Sequence="2" FrameValue="51" Duration="4" />
      <TileFrame Sequence="3" FrameValue="52" Duration="4" />
      <TileFrame Sequence="4" FrameValue="54" Duration="4" />
      <TileFrame Sequence="5" FrameValue="55" Duration="4" />
      <TileFrame Sequence="6" FrameValue="56" Duration="4" />
      <TileFrame Sequence="7" FrameValue="55" Duration="4" />
      <TileFrame Sequence="8" FrameValue="54" Duration="4" />
      <TileFrame Sequence="9" FrameValue="52" Duration="4" />
      <TileFrame Sequence="10" FrameValue="51" Duration="4" />
      <TileFrame Sequence="11" FrameValue="50" Duration="4" />
    </Tile>
    <Tile TileValue="0" />
    <Tile TileValue="53" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="57" Duration="3" />
      <TileFrame Sequence="1" FrameValue="58" Duration="3" />
      <TileFrame Sequence="2" FrameValue="59" Duration="3" />
      <TileFrame Sequence="3" FrameValue="60" Duration="3" />
    </Tile>
    <Tile TileValue="54" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="60" Duration="3" />
      <TileFrame Sequence="1" FrameValue="59" Duration="3" />
      <TileFrame Sequence="2" FrameValue="58" Duration="3" />
      <TileFrame Sequence="3" FrameValue="57" Duration="3" />
    </Tile>
    <Tile TileValue="27">
      <TileFrame Sequence="0" FrameValue="61" Duration="1" />
    </Tile>
    <Tile TileValue="28">
      <TileFrame Sequence="0" FrameValue="62" Duration="1" />
    </Tile>
    <Tile TileValue="29" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="62" Duration="0" />
      <TileFrame Sequence="1" FrameValue="63" Duration="6" />
      <TileFrame Sequence="3" FrameValue="64" Duration="6" />
      <TileFrame Sequence="2" FrameValue="62" Duration="0" />
    </Tile>
    <Tile TileValue="30">
      <TileFrame Sequence="0" FrameValue="65" Duration="1" />
    </Tile>
    <Tile TileValue="31" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="65" Duration="0" />
      <TileFrame Sequence="1" FrameValue="66" Duration="6" />
      <TileFrame Sequence="3" FrameValue="67" Duration="6" />
      <TileFrame Sequence="2" FrameValue="65" Duration="0" />
    </Tile>
    <Tile TileValue="32">
      <TileFrame Sequence="0" FrameValue="62" Duration="0" />
      <TileFrame Sequence="1" FrameValue="68" Duration="1" />
    </Tile>
    <Tile TileValue="33">
      <TileFrame Sequence="0" FrameValue="65" Duration="0" />
      <TileFrame Sequence="1" FrameValue="68" Duration="1" />
    </Tile>
    <Tile TileValue="34">
      <TileFrame Sequence="0" FrameValue="71" Duration="1" />
    </Tile>
    <Tile TileValue="35">
      <TileFrame Sequence="0" FrameValue="72" Duration="1" />
    </Tile>
    <Tile TileValue="36">
      <TileFrame Sequence="0" FrameValue="73" Duration="1" />
    </Tile>
    <Tile TileValue="37">
      <TileFrame Sequence="0" FrameValue="74" Duration="1" />
    </Tile>
    <Tile TileValue="38">
      <TileFrame Sequence="0" FrameValue="77" Duration="1" />
    </Tile>
    <Tile TileValue="39">
      <TileFrame Sequence="0" FrameValue="78" Duration="1" />
    </Tile>
    <Tile TileValue="40">
      <TileFrame Sequence="0" FrameValue="81" Duration="1" />
    </Tile>
    <Tile TileValue="41">
      <TileFrame Sequence="0" FrameValue="82" Duration="1" />
    </Tile>
    <Tile TileValue="55">
      <TileFrame Sequence="0" FrameValue="84" Duration="1" />
    </Tile>
    <Tile TileValue="56">
      <TileFrame Sequence="0" FrameValue="85" Duration="1" />
    </Tile>
    <Tile TileValue="57">
      <TileFrame Sequence="0" FrameValue="86" Duration="1" />
    </Tile>
    <Tile TileValue="58">
      <TileFrame Sequence="0" FrameValue="87" Duration="1" />
    </Tile>
    <Tile TileValue="59">
      <TileFrame Sequence="0" FrameValue="88" Duration="1" />
    </Tile>
    <Tile TileValue="60">
      <TileFrame Sequence="0" FrameValue="89" Duration="1" />
    </Tile>
    <Tile TileValue="61">
      <TileFrame Sequence="0" FrameValue="90" Duration="1" />
    </Tile>
    <Tile TileValue="62">
      <TileFrame Sequence="0" FrameValue="90" Duration="0" />
      <TileFrame Sequence="1" FrameValue="26" Duration="1" />
    </Tile>
    <Tile TileValue="63">
      <TileFrame Sequence="0" FrameValue="91" Duration="1" />
    </Tile>
    <Tile TileValue="64">
      <TileFrame Sequence="0" FrameValue="92" Duration="1" />
    </Tile>
    <Tile TileValue="65">
      <TileFrame Sequence="0" FrameValue="93" Duration="1" />
    </Tile>
    <Tile TileValue="66">
      <TileFrame Sequence="0" FrameValue="94" Duration="1" />
    </Tile>
    <Tile TileValue="42" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="95" Duration="0" />
      <TileFrame Sequence="1" FrameValue="96" Duration="16" />
      <TileFrame Sequence="2" FrameValue="95" Duration="0" />
      <TileFrame Sequence="4" FrameValue="95" Duration="0" />
      <TileFrame Sequence="6" FrameValue="95" Duration="0" />
      <TileFrame Sequence="8" FrameValue="95" Duration="0" />
      <TileFrame Sequence="10" FrameValue="95" Duration="0" />
      <TileFrame Sequence="12" FrameValue="95" Duration="16" />
      <TileFrame Sequence="13" FrameValue="95" Duration="0" />
      <TileFrame Sequence="15" FrameValue="95" Duration="0" />
      <TileFrame Sequence="3" FrameValue="97" Duration="16" />
      <TileFrame Sequence="5" FrameValue="98" Duration="32" />
      <TileFrame Sequence="7" FrameValue="99" Duration="16" />
      <TileFrame Sequence="9" FrameValue="100" Duration="16" />
      <TileFrame Sequence="11" FrameValue="101" Duration="16" />
      <TileFrame Sequence="14" FrameValue="102" Duration="16" />
      <TileFrame Sequence="16" FrameValue="103" Duration="16" />
      <TileFrame Sequence="17" FrameValue="95" Duration="16" />
      <TileFrame Sequence="18" FrameValue="95" Duration="0" />
      <TileFrame Sequence="20" FrameValue="95" Duration="0" />
      <TileFrame Sequence="22" FrameValue="95" Duration="0" />
      <TileFrame Sequence="19" FrameValue="98" Duration="16" />
      <TileFrame Sequence="21" FrameValue="104" Duration="16" />
      <TileFrame Sequence="23" FrameValue="105" Duration="16" />
      <TileFrame Sequence="24" FrameValue="95" Duration="0" />
      <TileFrame Sequence="25" FrameValue="106" Duration="16" />
      <TileFrame Sequence="26" FrameValue="95" Duration="60" />
    </Tile>
    <Tile TileValue="43">
      <TileFrame Sequence="0" FrameValue="107" Duration="1" />
    </Tile>
    <Tile TileValue="44">
      <TileFrame Sequence="0" FrameValue="108" Duration="1" />
    </Tile>
    <Tile TileValue="67">
      <TileFrame Sequence="1" FrameValue="94" Duration="1" />
      <TileFrame Sequence="0" FrameValue="19" Duration="0" />
    </Tile>
    <Tile TileValue="68">
      <TileFrame Sequence="0" FrameValue="109" Duration="1" />
    </Tile>
    <Tile TileValue="69">
      <TileFrame Sequence="0" FrameValue="110" Duration="1" />
    </Tile>
    <Tile TileValue="70">
      <TileFrame Sequence="0" FrameValue="111" Duration="1" />
    </Tile>
    <Tile TileValue="71">
      <TileFrame Sequence="0" FrameValue="112" Duration="1" />
    </Tile>
    <Tile TileValue="72">
      <TileFrame Sequence="0" FrameValue="113" Duration="1" />
    </Tile>
    <Tile TileValue="73">
      <TileFrame Sequence="0" FrameValue="114" Duration="1" />
    </Tile>
    <Tile TileValue="74">
      <TileFrame Sequence="0" FrameValue="115" Duration="1" />
    </Tile>
    <Tile TileValue="75">
      <TileFrame Sequence="0" FrameValue="116" Duration="1" />
    </Tile>
    <Tile TileValue="76">
      <TileFrame Sequence="0" FrameValue="117" Duration="1" />
    </Tile>
    <Tile TileValue="77">
      <TileFrame Sequence="0" FrameValue="118" Duration="1" />
    </Tile>
    <Tile TileValue="78">
      <TileFrame Sequence="0" FrameValue="119" Duration="1" />
    </Tile>
    <Tile TileValue="79">
      <TileFrame Sequence="0" FrameValue="120" Duration="1" />
    </Tile>
    <Tile TileValue="80">
      <TileFrame Sequence="0" FrameValue="121" Duration="1" />
    </Tile>
    <Tile TileValue="81">
      <TileFrame Sequence="0" FrameValue="122" Duration="1" />
    </Tile>
    <Tile TileValue="82">
      <TileFrame Sequence="0" FrameValue="123" Duration="1" />
    </Tile>
    <Tile TileValue="83">
      <TileFrame Sequence="0" FrameValue="124" Duration="1" />
    </Tile>
    <Tile TileValue="84">
      <TileFrame Sequence="0" FrameValue="125" Duration="1" />
    </Tile>
    <Tile TileValue="85">
      <TileFrame Sequence="0" FrameValue="126" Duration="1" />
    </Tile>
    <Tile TileValue="86">
      <TileFrame Sequence="0" FrameValue="0" Duration="1" />
    </Tile>
    <Tile TileValue="87">
      <TileFrame Sequence="0" FrameValue="127" Duration="1" />
    </Tile>
    <Tile TileValue="88">
      <TileFrame Sequence="0" FrameValue="128" Duration="1" />
    </Tile>
    <Tile TileValue="89">
      <TileFrame Sequence="0" FrameValue="107" Duration="0" />
      <TileFrame Sequence="1" FrameValue="129" Duration="1" />
    </Tile>
  </Tileset>
  <Tileset Name="WorldMapTiles" Frameset="WorldMapFrames" TileWidth="32" TileHeight="32">
    <Tile TileValue="76">
      <TileFrame Sequence="1" FrameValue="76" Duration="1" />
      <TileFrame Sequence="0" FrameValue="1" Duration="0" />
    </Tile>
    <Tile TileValue="79">
      <TileFrame Sequence="1" FrameValue="79" Duration="1" />
      <TileFrame Sequence="0" FrameValue="3" Duration="0" />
    </Tile>
    <Tile TileValue="80">
      <TileFrame Sequence="1" FrameValue="80" Duration="1" />
      <TileFrame Sequence="0" FrameValue="2" Duration="0" />
    </Tile>
    <Tile TileValue="83">
      <TileFrame Sequence="1" FrameValue="83" Duration="1" />
      <TileFrame Sequence="0" FrameValue="1" Duration="0" />
    </Tile>
    <Tile TileValue="84">
      <TileFrame Sequence="1" FrameValue="84" Duration="1" />
      <TileFrame Sequence="0" FrameValue="1" Duration="0" />
    </Tile>
    <Tile TileValue="85">
      <TileFrame Sequence="1" FrameValue="85" Duration="1" />
      <TileFrame Sequence="0" FrameValue="1" Duration="0" />
    </Tile>
    <Tile TileValue="86">
      <TileFrame Sequence="1" FrameValue="86" Duration="1" />
      <TileFrame Sequence="0" FrameValue="1" Duration="0" />
    </Tile>
    <Tile TileValue="87">
      <TileFrame Sequence="0" FrameValue="0" Duration="1" />
    </Tile>
    <Tile TileValue="0" />
    <Tile TileValue="88" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="90" Duration="0" />
      <TileFrame Sequence="2" FrameValue="109" Duration="0" />
      <TileFrame Sequence="4" FrameValue="110" Duration="0" />
      <TileFrame Sequence="6" FrameValue="109" Duration="0" />
      <TileFrame Sequence="1" FrameValue="94" Duration="6" />
      <TileFrame Sequence="3" FrameValue="94" Duration="6" />
      <TileFrame Sequence="5" FrameValue="94" Duration="6" />
      <TileFrame Sequence="7" FrameValue="94" Duration="6" />
    </Tile>
    <Tile TileValue="89" Counter="FrameCounter">
      <TileFrame Sequence="0" FrameValue="91" Duration="0" />
      <TileFrame Sequence="2" FrameValue="111" Duration="0" />
      <TileFrame Sequence="6" FrameValue="111" Duration="0" />
      <TileFrame Sequence="4" FrameValue="112" Duration="0" />
      <TileFrame Sequence="1" FrameValue="95" Duration="6" />
      <TileFrame Sequence="3" FrameValue="95" Duration="6" />
      <TileFrame Sequence="5" FrameValue="95" Duration="6" />
      <TileFrame Sequence="7" FrameValue="95" Duration="6" />
    </Tile>
    <Tile TileValue="90">
      <TileFrame Sequence="0" FrameValue="117" Duration="1" />
    </Tile>
    <Tile TileValue="91">
      <TileFrame Sequence="0" FrameValue="118" Duration="1" />
    </Tile>
    <Tile TileValue="92">
      <TileFrame Sequence="0" FrameValue="119" Duration="1" />
    </Tile>
    <Tile TileValue="39">
      <TileFrame Sequence="1" FrameValue="39" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="40">
      <TileFrame Sequence="1" FrameValue="40" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="41">
      <TileFrame Sequence="1" FrameValue="41" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="42">
      <TileFrame Sequence="1" FrameValue="42" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="43">
      <TileFrame Sequence="1" FrameValue="43" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="44">
      <TileFrame Sequence="1" FrameValue="44" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="45">
      <TileFrame Sequence="1" FrameValue="45" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="46">
      <TileFrame Sequence="1" FrameValue="46" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="47">
      <TileFrame Sequence="1" FrameValue="47" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="48">
      <TileFrame Sequence="1" FrameValue="48" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="49">
      <TileFrame Sequence="1" FrameValue="49" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="50">
      <TileFrame Sequence="1" FrameValue="50" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="51">
      <TileFrame Sequence="1" FrameValue="51" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="52">
      <TileFrame Sequence="1" FrameValue="52" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="53">
      <TileFrame Sequence="1" FrameValue="53" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="54">
      <TileFrame Sequence="1" FrameValue="54" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="55">
      <TileFrame Sequence="1" FrameValue="55" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="56">
      <TileFrame Sequence="1" FrameValue="56" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="57">
      <TileFrame Sequence="1" FrameValue="57" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="58">
      <TileFrame Sequence="1" FrameValue="58" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="59">
      <TileFrame Sequence="1" FrameValue="59" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="60">
      <TileFrame Sequence="1" FrameValue="60" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="61">
      <TileFrame Sequence="1" FrameValue="61" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="62">
      <TileFrame Sequence="1" FrameValue="62" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="63">
      <TileFrame Sequence="1" FrameValue="63" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="64">
      <TileFrame Sequence="1" FrameValue="64" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="65">
      <TileFrame Sequence="1" FrameValue="65" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="66">
      <TileFrame Sequence="1" FrameValue="66" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="67">
      <TileFrame Sequence="1" FrameValue="67" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="68">
      <TileFrame Sequence="1" FrameValue="68" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="69">
      <TileFrame Sequence="1" FrameValue="69" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="70">
      <TileFrame Sequence="1" FrameValue="70" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="71">
      <TileFrame Sequence="1" FrameValue="71" Duration="1" />
      <TileFrame Sequence="0" FrameValue="4" Duration="0" />
    </Tile>
    <Tile TileValue="93">
      <TileFrame Sequence="0" FrameValue="72" Duration="0" />
      <TileFrame Sequence="1" FrameValue="117" Duration="1" />
    </Tile>
    <Tile TileValue="94">
      <TileFrame Sequence="0" FrameValue="72" Duration="0" />
      <TileFrame Sequence="1" FrameValue="118" Duration="1" />
    </Tile>
    <Tile TileValue="95">
      <TileFrame Sequence="0" FrameValue="72" Duration="0" />
      <TileFrame Sequence="1" FrameValue="119" Duration="1" />
    </Tile>
  </Tileset>
  <Tileset Name="UsableInventory" Frameset="InventoryFrames" TileWidth="32" TileHeight="32">
    <Tile TileValue="100" Counter="SelectedInventory">
      <TileFrame Sequence="0" FrameValue="0" Duration="1" />
      <TileFrame Sequence="1" FrameValue="1" Duration="1" />
      <TileFrame Sequence="2" FrameValue="2" Duration="1" />
      <TileFrame Sequence="3" FrameValue="3" Duration="1" />
      <TileFrame Sequence="4" FrameValue="4" Duration="1" />
      <TileFrame Sequence="5" FrameValue="5" Duration="1" />
      <TileFrame Sequence="6" FrameValue="6" Duration="1" />
      <TileFrame Sequence="7" FrameValue="7" Duration="1" />
      <TileFrame Sequence="9" FrameValue="10" Duration="1" />
      <TileFrame Sequence="8" FrameValue="9" Duration="0" />
      <TileFrame Sequence="10" FrameValue="11" Duration="1" />
      <TileFrame Sequence="11" FrameValue="12" Duration="1" />
      <TileFrame Sequence="12" FrameValue="13" Duration="1" />
      <TileFrame Sequence="13" FrameValue="14" Duration="1" />
      <TileFrame Sequence="14" FrameValue="15" Duration="1" />
      <TileFrame Sequence="15" FrameValue="16" Duration="1" />
      <TileFrame Sequence="16" FrameValue="17" Duration="1" />
      <TileFrame Sequence="17" FrameValue="18" Duration="1" />
    </Tile>
    <Tile TileValue="101">
      <TileFrame Sequence="0" FrameValue="8" Duration="1" />
    </Tile>
    <Tile TileValue="0">
      <TileFrame Sequence="1" FrameValue="0" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="1">
      <TileFrame Sequence="1" FrameValue="1" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="2">
      <TileFrame Sequence="1" FrameValue="2" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="3">
      <TileFrame Sequence="1" FrameValue="3" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="4">
      <TileFrame Sequence="1" FrameValue="4" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="5">
      <TileFrame Sequence="1" FrameValue="5" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="6">
      <TileFrame Sequence="1" FrameValue="6" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="7">
      <TileFrame Sequence="1" FrameValue="7" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="8">
      <TileFrame Sequence="1" FrameValue="9" Duration="0" />
      <TileFrame Sequence="2" FrameValue="10" Duration="1" />
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
    </Tile>
    <Tile TileValue="9">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="11" Duration="1" />
    </Tile>
    <Tile TileValue="10">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="12" Duration="1" />
    </Tile>
    <Tile TileValue="11">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="13" Duration="1" />
    </Tile>
    <Tile TileValue="12">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="14" Duration="1" />
    </Tile>
    <Tile TileValue="13">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="15" Duration="1" />
    </Tile>
    <Tile TileValue="14">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="16" Duration="1" />
    </Tile>
    <Tile TileValue="15">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="17" Duration="1" />
    </Tile>
    <Tile TileValue="16">
      <TileFrame Sequence="0" FrameValue="8" Duration="0" />
      <TileFrame Sequence="1" FrameValue="18" Duration="1" />
    </Tile>
  </Tileset>
  <Counter Name="FrameCounter" Value="1" Max="25200">
    <Min>0</Min>
  </Counter>
  <Counter Name="Life" Value="3" Max="10">
    <Min>0</Min>
  </Counter>
  <Counter Name="Health" Value="10" Max="10">
    <Min>0</Min>
  </Counter>
  <Counter Name="Money" Value="0" Max="10000">
    <Min>0</Min>
  </Counter>
  <Counter Name="SelectedInventory" Value="0" Max="14">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotRange" Value="500" Max="10000">
    <Min>0</Min>
  </Counter>
  <Counter Name="CanAccessInventory" Value="1" Max="1">
    <Min>0</Min>
  </Counter>
  <Counter Name="Bombs" Value="0" Max="5">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotEnergySources" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="ThrowableTorches" Value="0" Max="5">
    <Min>0</Min>
  </Counter>
  <Counter Name="SaveSlot1" Value="0" Max="1">
    <Min>0</Min>
  </Counter>
  <Counter Name="SaveSlot2" Value="0" Max="1">
    <Min>0</Min>
  </Counter>
  <Counter Name="SaveSlot3" Value="0" Max="1">
    <Min>0</Min>
  </Counter>
  <Counter Name="CurrentSlot" Value="0" Max="4">
    <Min>0</Min>
  </Counter>
  <Counter Name="SaveLoadDelete" Value="0" Max="2">
    <Min>0</Min>
  </Counter>
  <Counter Name="GlobalAction" Value="0" Max="5">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotDroplets" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotBombs" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotCollisionPowers" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotSplashPowers" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotFollowers" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="SaveSlotCP" Value="0" Max="1">
    <Min>0</Min>
  </Counter>
  <Counter Name="DNAWorms" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="DNASpiders" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotMoveLefts" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotMoveRights" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotMoveUps" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Counter Name="BotMoveDowns" Value="0" Max="100">
    <Min>0</Min>
  </Counter>
  <Map Name="TestLevel" ScrollMarginLeft="280" ScrollMarginTop="200" ScrollMarginRight="280" ScrollMarginBottom="200" ScrollWidth="2000" ScrollHeight="1600">
    <Layer Name="Main" Width="63" Height="50" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="1" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAORwcHBwcHBsbAAAAAAAAAAAAAAAAAAAAAAAbGxscHB4cGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEBAQEBARsbAAA9AAAAAAAAAAAAAAAAABsbGxsBAQEBGwACAQEAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAQABAQE+ATU1NQEBAQEBAQEBAQEBAQEBAAABGwIBAQEAAAABAQAbAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAA9AAAAAAAAAAAAAAAAAAAAAAAAAAABGwEAAAAAAAAAAAAbAQEBAQEAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAA9AAAAAAAAMgAAAAAAAAAAAAAAAAABGwEAGx4AAAAAAAAbAQAAAAAAAAAAAAATAAAAAAAAAAAAAAAbADoANAA9AAAAAAQFATU1NTUBAQE2NjY2AAABGxsbGwEAAAAAAAAbAQAAAAAAAAAAAAATAAAAAAAAAAAAAAAbAAAAAAA9AAAEBQEBAQMANwAAAAAAAAAAAAIBAAACAQEAAAAAAAAbAQAAAAAAAAAAAAATAAAAAAAAAAAAAAAbAAAAAAA9BAUBAQEBAQEBAQMAAAAAAAAAAgEAAAIBAQEAAAAAAAAbAQAAAAAAAAAAAAATAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAgEBAQEAAAAAAAAbAQAAAAAAAAAAAAATAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</Tiles>
      <Sprite Name="Player 1" DefinitionName="Player" StateName="Right" CurrentFrame="0" X="657" Y="1180" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-49024">
        <ParameterValue ParameterName="PlayerNum" Value="1" />
        <ParameterValue ParameterName="InvincibleTimer" Value="0" />
        <ParameterValue ParameterName="HurtFlag" Value="0" />
        <ParameterValue ParameterName="TouchedEnemy" Value="0" />
        <ParameterValue ParameterName="TempNum" Value="0" />
        <ParameterValue ParameterName="TouchIndex" Value="0" />
      </Sprite>
      <Sprite Name="Worm 1" DefinitionName="Worm" StateName="Right" CurrentFrame="0" X="705" Y="990" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="collideIndex" Value="0" />
      </Sprite>
      <Sprite Name="Bombot 1" DefinitionName="Bombot" StateName="Right" CurrentFrame="0" X="902" Y="991" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="BehaviorTimer" Value="0" />
        <ParameterValue ParameterName="MoveTime" Value="300" />
        <ParameterValue ParameterName="WaitBefore" Value="60" />
        <ParameterValue ParameterName="WaitAfter" Value="200" />
        <ParameterValue ParameterName="TempNum" Value="0" />
      </Sprite>
      <Sprite Name="Platform 1" DefinitionName="Platform" StateName="Main" CurrentFrame="0" X="1600" Y="1248" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="CoordIndex" Value="0" />
        <ParameterValue ParameterName="WaitTime" Value="0" />
      </Sprite>
      <Sprite Name="Sprout 1" DefinitionName="Sprout" StateName="Seed" CurrentFrame="0" X="384" Y="1184" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="Structure" Value="4501041" />
        <ParameterValue ParameterName="StructureTemp" Value="0" />
        <ParameterValue ParameterName="LengthTemp" Value="0" />
        <ParameterValue ParameterName="Seeds" Value="10" />
        <ParameterValue ParameterName="SeedsTemp" Value="0" />
      </Sprite>
      <Sprite Name="Platform 2" DefinitionName="Platform" StateName="Main" CurrentFrame="0" X="224" Y="1184" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="CoordIndex" Value="0" />
        <ParameterValue ParameterName="WaitTime" Value="0" />
      </Sprite>
      <Sprite Name="Package 1" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="240" Y="1099" DX="0" DY="0" Priority="2" Active="true" Solidity="Standard" Color="-65281">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Package 2" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="240" Y="1137" DX="0" DY="0" Priority="2" Active="true" Solidity="Standard" Color="-256">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Package 3" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="545" Y="1071" DX="0" DY="0" Priority="2" Active="true" Solidity="Standard" Color="-16711681">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Package 4" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="724" Y="1172" DX="0" DY="0" Priority="2" Active="true" Solidity="Standard" Color="-16711936">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Package 5" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="453" Y="1175" DX="0" DY="0" Priority="2" Active="true" Solidity="Standard" Color="-16776961">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Package 6" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="543" Y="1019" DX="0" DY="0" Priority="2" Active="true" Solidity="Standard" Color="-65536">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Rocket 1" DefinitionName="Rocket" StateName="Right" CurrentFrame="0" X="1568" Y="1086" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="Ignited" Value="0" />
      </Sprite>
      <Sprite Name="Jumper 1" DefinitionName="Jumper" StateName="Right" CurrentFrame="0" X="414" Y="1184" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="JumpWait" Value="120" />
        <ParameterValue ParameterName="WaitTimer" Value="0" />
        <ParameterValue ParameterName="NearestPlayer" Value="0" />
      </Sprite>
      <Sprite Name="Spider 1" DefinitionName="Spider" StateName="Main" CurrentFrame="0" X="448" Y="1024" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="PlayerDirection" Value="0" />
        <ParameterValue ParameterName="Behavior" Value="0" />
        <ParameterValue ParameterName="NextWeb" Value="0" />
        <ParameterValue ParameterName="StartY" Value="0" />
      </Sprite>
      <Sprite Name="BotMover 1" DefinitionName="BotMover" StateName="Follow" CurrentFrame="0" X="650" Y="1097" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="TempNum" Value="0" />
        <ParameterValue ParameterName="DeactivateFlag" Value="0" />
      </Sprite>
      <Sprite Name="BotEnergySource 1" DefinitionName="BotEnergySource" StateName="Always" CurrentFrame="0" X="786" Y="1126" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="Energy" Value="200" />
        <ParameterValue ParameterName="TargetIndex" Value="0" />
        <ParameterValue ParameterName="DeactivateFlag" Value="0" />
        <ParameterValue ParameterName="DoGenerate" Value="0" />
      </Sprite>
      <SpritePlan Name="L1Platform1" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="1600" Y="1248" Weight="60" />
        <Coordinate Sequence="2" X="1600" Y="992" Weight="60" />
        <PlanRule Name="Push platform 1" Sequence="1" Type="Do" Function="FollowPath" Parameter1="m_ParentLayer.m_Platform_1" Parameter2="ref m_ParentLayer.m_Platform_1.CoordIndex" Parameter3="ref m_ParentLayer.m_Platform_1.WaitTime" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="L1Platform2" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="224" Y="1184" Weight="60" />
        <Coordinate Sequence="2" X="224" Y="832" Weight="30" />
        <PlanRule Name="Platform 2 Follow" Sequence="1" Type="Do" Function="FollowPath" Parameter1="m_ParentLayer.m_Platform_2" Parameter2="ref m_ParentLayer.m_Platform_2.CoordIndex" Parameter3="ref m_ParentLayer.m_Platform_2.WaitTime" EndIf="false" Suspended="false" />
      </SpritePlan>
    </Layer>
    <Layer Name="Background" Width="1" Height="1" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" ZIndex="0" Priority="0" VirtualWidth="59" VirtualHeight="32">
      <Tiles>EQ==</Tiles>
    </Layer>
  </Map>
  <Map Name="Overlay" ScrollMarginLeft="32" ScrollMarginTop="32" ScrollMarginRight="32" ScrollMarginBottom="32">
    <Layer Name="Main" Width="20" Height="15" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="1" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</Tiles>
      <SpritePlan Name="Animate Tiles" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <PlanRule Name="AnimateTiles" Sequence="1" Type="Do" Function="ChangeCounter" Parameter1="Counter.FrameCounter" Parameter2="CounterOperation.IncrementAndLoop" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Draw life" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="0" Y="0" Weight="0" />
        <Coordinate Sequence="2" X="320" Y="32" Weight="0" />
        <PlanRule Name="Draw life" Sequence="1" Type="Do" Function="DrawCounterAsTile" Parameter1="55" Parameter2="Counter.Life" Parameter3="PlanBase.DrawStyle.RepeatRightToCounter" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Draw health" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="0" Y="32" Weight="0" />
        <Coordinate Sequence="2" X="320" Y="64" Weight="0" />
        <PlanRule Name="Draw counter as tile" Sequence="1" Type="Do" Function="DrawCounterAsTile" Parameter1="56" Parameter2="Counter.Health" Parameter3="PlanBase.DrawStyle.RepeatRightToCounter" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Limit frame rate" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <PlanRule Name="Limit frame rate" Sequence="1" Type="Do" Function="LimitFrameRate" Parameter1="75" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Draw Money" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="352" Y="0" Weight="0" />
        <Coordinate Sequence="2" X="480" Y="32" Weight="0" />
        <PlanRule Name="Draw money" Sequence="1" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.Money" Parameter3="System.Drawing.KnownColor.White" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Draw selected inventory" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="352" Y="32" Weight="0" />
        <Coordinate Sequence="2" X="480" Y="64" Weight="0" />
        <PlanRule Name="If selected inventory is bomb" Sequence="1" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="0" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bomb inventory" Sequence="2" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.Bombs" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot energy source" Sequence="3" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="1" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot energy source inventory" Sequence="4" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotEnergySources" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is throwable torch" Sequence="7" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="8" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw throwable torch inventory" Sequence="8" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.ThrowableTorches" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot droplet" Sequence="5" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="7" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot droplet inventory" Sequence="6" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotDroplets" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot bomb" Sequence="15" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="6" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot bomb inventory" Sequence="16" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotBombs" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is splash power source" Sequence="13" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="5" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw splash power source inventory" Sequence="14" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotSplashPowers" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is collision power source" Sequence="11" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="4" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw collision power source inventory" Sequence="12" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotCollisionPowers" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is follower" Sequence="9" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="3" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw follower inventory" Sequence="10" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotFollowers" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot move up" Sequence="17" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="9" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot move up inventory" Sequence="18" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotMoveUps" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is spider DNA" Sequence="27" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="14" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw spider DNA inventory" Sequence="28" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.DNASpiders" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is worm DNA" Sequence="25" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="13" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw worm DNA inventory" Sequence="26" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.DNAWorms" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot move left" Sequence="23" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="12" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot move left inventory" Sequence="24" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotMoveLefts" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot move down" Sequence="21" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="11" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot move down inventory" Sequence="22" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotMoveDowns" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
        <PlanRule Name="If selected inventory is bot move right" Sequence="19" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="10" EndIf="false" Suspended="false" />
        <PlanRule Name="Draw bot move right inventory" Sequence="20" Type="Do" Function="DrawCounterWithLabel" Parameter1="&quot;&quot;" Parameter2="Counter.BotMoveRights" Parameter3="System.Drawing.KnownColor.White" EndIf="true" Suspended="false" />
      </SpritePlan>
    </Layer>
    <Layer Name="SelectedInventory" Width="1" Height="1" Tileset="UsableInventory" BytesPerTile="1" OffsetX="320" OffsetY="32" ScrollRateX="1" ScrollRateY="1" ZIndex="2" Priority="0" VirtualWidth="1" VirtualHeight="1">
      <Tiles>ZA==</Tiles>
    </Layer>
    <Layer Name="DesignerBackground" Width="1" Height="1" BytesPerTile="1" OffsetX="-480" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="0" Priority="0" VirtualWidth="1000" VirtualHeight="1000">
      <Tiles>AA==</Tiles>
    </Layer>
    <Layer Name="InventorySelector" Width="15" Height="10" Tileset="UsableInventory" BytesPerTile="1" OffsetX="-480" OffsetY="80" ScrollRateX="1" ScrollRateY="1" ZIndex="4" Priority="0" VirtualWidth="15" VirtualHeight="10">
      <Tiles>ZWVlZWVlZWVlZWVlZWVlZQAIZWVlZWVlZWVlZWVlZQMJCgsMZWVlZWVlZWVlZQEEBWVlZWVlZWVlZWVlZQYHZWVlZWVlZWVlZWVlZQ0ODxBlZWVlZWVlZWVlZQJlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl</Tiles>
      <Sprite Name="InventorySelector 1" DefinitionName="InventorySelector" StateName="Main" CurrentFrame="0" X="32" Y="32" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1" />
      <SpritePlan Name="Show Inventory Selector" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <PlanRule Name="If pressing inventory button" Sequence="1" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_InventorySelector_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="false" EndIf="false" Suspended="false" />
        <PlanRule Name="And inventory access is not supressed" Sequence="2" Type="And" Function="&gt;=" Parameter1="Counter.CanAccessInventory.CurrentValue" Parameter2="1" EndIf="false" Suspended="false" />
        <PlanRule Name="Reset inventory access" Sequence="5" Type="Do" Function="ChangeCounter" Parameter1="Counter.CanAccessInventory" Parameter2="CounterOperation.SetToMaximum" EndIf="false" Suspended="false" />
        <PlanRule Name="Move inventory selector layer into view" Sequence="3" Type="Do" Function="MoveSelectorLayer" Parameter1="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Else move inventory selector layer out of view" Sequence="4" Type="Else" Function="MoveSelectorLayer" Parameter1="false" EndIf="true" Suspended="false" />
      </SpritePlan>
    </Layer>
  </Map>
  <Map Name="World" ScrollMarginLeft="200" ScrollMarginTop="200" ScrollMarginRight="200" ScrollMarginBottom="200" ScrollWidth="1000" ScrollHeight="1000">
    <Layer Name="Main" Width="32" Height="32" Tileset="WorldMapTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="2" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNSk4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBMTwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAgEDGRkZGR0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAHCAAAAAAAAAAIRkZGRkZHQAAAAAAAAAAAAAAAAAAABwgAAAAAAAAAAAAAAAAAAAhGRkZHQAAAAAAAAAAABwZIAAAAAAAAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAcIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAATUpOAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAATUoAAEsAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAABQVAAASwAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAABJAABLAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAFAAAE8AAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAgAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAWQAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</Tiles>
      <Sprite Name="WorldMapPlayer 1" DefinitionName="WorldMapPlayer" StateName="Right" CurrentFrame="11" X="96" Y="352" DX="0" DY="0" Priority="0" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="PlayerNum" Value="1" />
      </Sprite>
      <SpritePlan Name="Go to level 1" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="352" Y="224" Weight="0" />
        <Coordinate Sequence="2" X="384" Y="256" Weight="0" />
        <PlanRule Name="If player touches" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_WorldMapPlayer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Go to level 1" Sequence="3" Type="Do" Function="SwitchToMap" Parameter1="typeof(Level_1_Map)" Parameter2="false" EndIf="true" Suspended="false" />
        <PlanRule Name="And presses button" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_WorldMapPlayer_1" Parameter2="SpriteBase.InputBits.Button1" Parameter3="true" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Go to level 2" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="352" Y="544" Weight="0" />
        <Coordinate Sequence="2" X="384" Y="576" Weight="0" />
      </SpritePlan>
    </Layer>
    <Layer Name="Background" Width="1" Height="1" Tileset="WorldMapTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" ZIndex="0" Priority="0" VirtualWidth="59" VirtualHeight="32">
      <Tiles>Vw==</Tiles>
    </Layer>
    <Layer Name="Grass" Width="91" Height="67" Tileset="WorldMapTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="1" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGRkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALiwsLCwoBCosLC8EBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBCsEBAQEBAQEBAQrBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQrBAQEBAQEBAQEKwQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEKwQEBFFIBAQEBCsEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQqLDQEBFRISAQEKiw1LCwEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQrBAQESEgEBAQEKwQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEKwQEBF1fBAQEBCsEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBCsEBARadwQEBAQrBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQrBD5CdXdDPy4sMAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQELSw5JiYmJkM2PwQEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEQT09RSZEPUAEBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBEE9QAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</Tiles>
    </Layer>
  </Map>
  <Map Name="Tutorial 1" ScrollMarginLeft="200" ScrollMarginTop="200" ScrollMarginRight="200" ScrollMarginBottom="200" ScrollWidth="11936" ScrollHeight="2208">
    <Layer Name="Designer Background" Width="1" Height="1" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" ZIndex="0" Priority="0" VirtualWidth="4000" VirtualHeight="4000">
      <Tiles>AA==</Tiles>
    </Layer>
    <Layer Name="Background" Width="1" Height="1" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" ZIndex="1" Priority="0" VirtualWidth="59" VirtualHeight="32">
      <Tiles>EQ==</Tiles>
    </Layer>
    <Layer Name="Main" Width="373" Height="69" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="3" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQwAAAAAAAAAAAAAAAAAAAAAAABMTAAAAAAAAAAAAAABHAAATAAAAAAAAAAAAAAAAAABDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwTAAAAAAAAABNMAAAAAAAAAAAAAAAAAEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPQAAKgAAAAATSAAAAAAAAAAAAAAAAABDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4TExMAAAATExM7AAAAAAAAAAAAAAAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9ABMAAAAAAAAAAAAAAAAAAAAAAAAAAEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQwAAAAoJCQkJCQsAAAAAAAAAAAAAAAAAAAAAPQATAAAAAAAAAAATAEgAAAAAAAAAAABDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEMAAAAJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAD0AExMTExMTExMTExMTAAAAAAAAAAAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDAAAACQlSAFEJCQAAAAAAAAAAAAAAAAAAAAA9ABMAAAAAAAAAAAAAAAAAAAAAQkJCAEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOjo6Ojo6OjoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQwAAAAkJADQACQkAAAAAAAAAAAAAACoAAAAAPQATAAAAAAAAAAAAAAAAACoAAEI9QgBDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAENDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDPkNDQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD0AABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAKgAAHR0dHR0dHR09AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9AAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAExMTExMTExMTExMTPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPQAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAABMAAAAAAAA9AAAAEz0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAEJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQgAAAD0AABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAATOzwTExMTPhMTExM9AAAAAAAAAAAAAAAAAAAAAAAAExMTExMTExMTExMTExMTExMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQQAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAABCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEIAAAA9AAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAATEwAAEwAAAD0AAAATPQAAAAAAAAAAAAAAAAAAAAAAABMTExMTExMTExMTExMTExMTEwAAAAAAAAAAAAAAAAAAABsAAAAAAAAAAAAAAAAAAAAAAAAAQEEAAAAAAAAAAAAAAAATExMAAAAAAAAAAAAAAAAAAAAAQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCAAAAPQAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAA9AAAAEz0AAAAAAAAAAAAAAAAAAAAAAAATAAAAABMTExMTAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAbAAAAAAAAAAAAAAAAAAAAAAAAAEBBAAAAAAAAAAAAAAAAExsbGwAAAAAAAAAAAAAAAAAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQgAAAD0AABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEyoAAAAAHR0AKgAAPQAAABM9AAAAAAAAAAAAAAAAAAAAAAAAEwAAAAATABMAEwAAAAAAAAATAAAAAAAAAAAAAAAAAAAAGxsAAAAAAAAAAAAAAAAAAAAAAABAQQAAAAAAAAAAAAAAAAAAExsAAAAAAAAAAAAAAAAAAABCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEIAAAA9AAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMTExMTExMTEz4TExMTPQAAAAAAExMTExMTExMTExMTExMAAAAARABFAEYAAAAAAAAAEwAAAAAAAAAAAAAAAAAAABsbAAAAAAAAAAAAAAAAAAAAAAAAQEEAAAAAAAAAAABOTk5OThMbAAAAAAAAAAAAAAAAAAAAQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCAAAAPQAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9AAAAEz0AAAAAABMAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAbGxsAAAAAAAAAAAAAAAAAAAAAAEBBAAAAAAAAAAAAExMTExMTGwAAAAAAAAAAAAAAAAAAAEIAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAQgAAAD0AABMAAAAAAAAAAAAAAAAAAAACAQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPQAAABM9AAAAAAATAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAGxsbGwAAAAAAAAAAACoAPQAAAABAQQAAAAAAAABOTk5OTk5OExsAAAAAAAAAAAAAAAAAAABCAAAAAFMVAAAAAAAAABMAAAAAAAAAAAAAAEIAAAA9AAATAAAAAAAAAAAAAAAAAAAAAQEBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD0AKgATPQAAAAAAEwAAAAAAAAAAAAAAABMAPQAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAABsTExMTExMTExMTExMTEz4TExMTExMTEwAAAAAAExMTExMTExMbAAAAAAAAAAAAAAAAAAAAQgAAACoAUxUAAAAAAAATAAAAAAAAAAAAAABCAAAAPQAAEwAAAAAAAAAAAAAAAAAAAAEBAQEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBQEBAQEBEz0AAAAAABMAAAAAAAAAAAAAAAATEz4TEzU1NTU1NTUAAAAAABMAAAAAAAAAAAAAAAAAGxsbEwAAAAATOjo6Ojo6OgA9ADo6OhsAACw9ACoAABMAAAAAAAATGwAAAAAAAAAAAAAAAAAAAEIAABQTFT0TFQAqAD0AEwATPQATACoAAAAAQgAAAD0AABMAAAAAAAAAAAAAAAAAAAABAQEBAQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAQEBAQEBAQEBAwAAAAATAAAAAAAAAAAAAAAAEwA9AAAAAAAAAAAAAAAAAAATExMTAAAAAAA9ACoAABsbGxNNTU0AEwAAAAAAAAAAPQAAAAAbABQTPhoaGhobGwAAACoAExsAAAAAAAAAAAAAKgAAPQBCFhcTExM+ExMTExM+ABMTEz4TExMTEwAAAEIAPQA9AAATAAAAAAAAAAAAAAAAAAAAAQEBAQEBBgcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKCclAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAQEBAQEBAQEBAQEDAAAAEwAAAAAAAAAAAAAAABMAPQAAAAAAAAAAAAAAAAAAExMTEwAAABMTPhMTExMTExMTExMTABM7AAAAAAAbAD0bABsAGxQTEz0AAAAAGxMAABMTExMbAAAAAAAAAAAAExMTEz4TQ0NDQ0MTPRMTExMTPQAAAAA9EwBTFQAAAABCAD4TExMTEwAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFAQEBAQEBAQEBAQEBAQMAACwAAAAAAAA4AAAAAAATAD0AAEkASgBLAAAAAAAAAAAAAAAAABQTEz0AAAAAAAAAAAAAAAATAAAAADkAGwA9GwAbABsTExM9AAAAABsTAAATGxsbGwAAAAAAAAAAAAAAAAA9AAAAAABDEz0TExMTEz0AAAAAPRMAAFMVAAAAQgA9AAAAABMAAAAAAAAAAAAAAAAAAAATEwEBAQEBAQEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIBAQEBAQEBAQEBAQEBAQEBBgUTFQAqAAA4ODgAADIALAA9KgBIAEgASAAAAAAAAAAAAAAAABQTExM9AAAAAAAAAABNTU1NEwAAAAA5HhsAPRsAGwAbExMTPhMTAAATEwATEwATExsAAAAAAAAAVQAAAAAAPQAAAAAAQxM9AAATExM9ABQTExMTAAAAUxUAAEIAPQAAABMTEwAAAAAAAAAAAAAAAAAAExMBAQEBAQEBAQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjAAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAUBAQEBAQEBAQEBAQEBAQEBAQEBExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAAAAABMTExMTExMTExMTExMTExMTExMTExMTExMTExMTNRM1ExMTEz0AAAAqEwAAAAAAABMbAAAAKgAAFBMVAAAAAD0AAAAAAEMTPQAAExMTExMTExMTExMTExMTGBlCAD0AKgAAWVkAAAAAAAAAKgAAAAAAACwTAQEBAQEBAQEBAwAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAIwAAKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBE0A/P0ETAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwAAAQEBAQAAAQETExMTExMTExMTExMTExMTExMTExNDEz0AABMTExMTQ0NDQ0NDQ0NDQ0NDQxMTExMTExMTAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUEwAAAAAAKgAEBQEGBQEBBgcAAAAAAAIDAAAAAAAAAAAAAAEAAAEAAAAEBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBARMTExMTEwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAE8BAQEAAAEBEwAAAAAAAAAAAAAAAAAAAAAAAAAAQxM9AAATExMTE0MAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYXEywAACoEBQEBAQEBAQEBAQEBAwAqAAIBAQYHKgAAAAAAHwIBQEEBAwACAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQMATwEBAAABARMAAAAAAAAAAAAAAAAAAAAAAAAAAEMTPQAAAAAAABNDAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAx0CAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwBPAQAAAQETAAAAAAAAAAAAAAAAAAAAAAAAAABDEz0AACoAAAATQwAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAAAAAAEBEwAAAAAAAAAAAAAAAAAAAAAAAAAAQxMTExMTExMTE0MAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCRMAAAAAAAAAAAAAAAAAAAAAAAAAAENDQ0NDQ0NDQ0NDAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCRMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCRMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJExMTExMTExMTExMTExMTExMTExMTExMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</Tiles>
      <Sprite Name="Player 1" DefinitionName="Player" StateName="Right" CurrentFrame="0" X="293" Y="1361" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="PlayerNum" Value="1" />
        <ParameterValue ParameterName="InvincibleTimer" Value="0" />
        <ParameterValue ParameterName="HurtFlag" Value="0" />
        <ParameterValue ParameterName="TouchedEnemy" Value="0" />
        <ParameterValue ParameterName="TempNum" Value="0" />
        <ParameterValue ParameterName="TouchIndex" Value="0" />
      </Sprite>
      <Sprite Name="YellowPackage" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="2752" Y="1120" DX="0" DY="0" Priority="2" Active="false" Solidity="Standard" Color="-256">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="PinkPackage" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="2816" Y="1120" DX="0" DY="0" Priority="2" Active="false" Solidity="Standard" Color="-65281">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="CyanPackage" DefinitionName="Package" StateName="Main" CurrentFrame="0" X="2880" Y="1120" DX="0" DY="0" Priority="2" Active="false" Solidity="Standard" Color="-16711681">
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Bombot 1" DefinitionName="Bombot" StateName="Right" CurrentFrame="0" X="3904" Y="1344" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="BehaviorTimer" Value="0" />
        <ParameterValue ParameterName="MoveTime" Value="210" />
        <ParameterValue ParameterName="WaitBefore" Value="30" />
        <ParameterValue ParameterName="WaitAfter" Value="10" />
        <ParameterValue ParameterName="TempNum" Value="0" />
      </Sprite>
      <Sprite Name="Rocket 1" DefinitionName="Rocket" StateName="Up" CurrentFrame="0" X="4736" Y="1376" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="Ignited" Value="0" />
      </Sprite>
      <Sprite Name="Rocket 2" DefinitionName="Rocket" StateName="Right" CurrentFrame="0" X="4640" Y="1376" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="Ignited" Value="0" />
      </Sprite>
      <Sprite Name="Worm 1" DefinitionName="Worm" StateName="Left" CurrentFrame="0" X="5896" Y="1215" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="collideIndex" Value="0" />
      </Sprite>
      <Sprite Name="BotMover 1" DefinitionName="BotMover" StateName="Follow" CurrentFrame="0" X="5760" Y="1056" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="TempNum" Value="0" />
        <ParameterValue ParameterName="DeactivateFlag" Value="0" />
      </Sprite>
      <Sprite Name="BotBomber 1" DefinitionName="BotBomber" StateName="Bomb" CurrentFrame="0" X="5792" Y="1056" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="DeactivateFlag" Value="0" />
        <ParameterValue ParameterName="TargetIndex" Value="0" />
      </Sprite>
      <Sprite Name="BotEnergySource 1" DefinitionName="BotEnergySource" StateName="OnCollision" CurrentFrame="0" X="5719" Y="1132" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="Energy" Value="200" />
        <ParameterValue ParameterName="TargetIndex" Value="0" />
        <ParameterValue ParameterName="DeactivateFlag" Value="0" />
        <ParameterValue ParameterName="DoGenerate" Value="0" />
      </Sprite>
      <Sprite Name="Sprout 1" DefinitionName="Sprout" StateName="Seed" CurrentFrame="0" X="5440" Y="768" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="Structure" Value="411154" />
        <ParameterValue ParameterName="StructureTemp" Value="0" />
        <ParameterValue ParameterName="LengthTemp" Value="0" />
        <ParameterValue ParameterName="Seeds" Value="3333" />
        <ParameterValue ParameterName="SeedsTemp" Value="0" />
      </Sprite>
      <Sprite Name="Spider 1" DefinitionName="Spider" StateName="Main" CurrentFrame="0" X="5420" Y="514" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="PlayerDirection" Value="0" />
        <ParameterValue ParameterName="Behavior" Value="0" />
        <ParameterValue ParameterName="NextWeb" Value="0" />
        <ParameterValue ParameterName="StartY" Value="0" />
      </Sprite>
      <Sprite Name="Bombot 2" DefinitionName="Bombot" StateName="Right" CurrentFrame="0" X="5802" Y="671" DX="0" DY="0" Priority="1" Active="false" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="BehaviorTimer" Value="0" />
        <ParameterValue ParameterName="MoveTime" Value="100" />
        <ParameterValue ParameterName="WaitBefore" Value="100" />
        <ParameterValue ParameterName="WaitAfter" Value="200" />
        <ParameterValue ParameterName="TempNum" Value="0" />
      </Sprite>
      <Sprite Name="GreenPackage" DefinitionName="Package" StateName="Main" CurrentFrame="1" X="5824" Y="512" DX="0" DY="0" Priority="2" Active="false" Solidity="Standard" Color="-16711936">
        <ParameterValue ParameterName="Contents" Value="1" />
        <ParameterValue ParameterName="temp" Value="0" />
      </Sprite>
      <Sprite Name="Eater 1" DefinitionName="Eater" StateName="StandLeft" CurrentFrame="0" X="5625" Y="768" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-10444800">
        <ParameterValue ParameterName="Digesting" Value="0" />
        <ParameterValue ParameterName="HitIndex" Value="0" />
        <ParameterValue ParameterName="WalkAfterBurp" Value="0" />
      </Sprite>
      <Sprite Name="CrystalizedBot 1" DefinitionName="CrystalizedBot" StateName="CollisionPower" CurrentFrame="0" X="5359" Y="715" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="temp" Value="0" />
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="RegenerateTime" Value="600" />
        <ParameterValue ParameterName="regenTimer" Value="0" />
      </Sprite>
      <Sprite Name="CrystalizedBot 2" DefinitionName="CrystalizedBot" StateName="Follower" CurrentFrame="0" X="5571" Y="563" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="temp" Value="0" />
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="RegenerateTime" Value="600" />
        <ParameterValue ParameterName="regenTimer" Value="0" />
      </Sprite>
      <Sprite Name="CrystalizedBot 3" DefinitionName="CrystalizedBot" StateName="EnergySource" CurrentFrame="0" X="5707" Y="1500" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="temp" Value="0" />
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="RegenerateTime" Value="600" />
        <ParameterValue ParameterName="regenTimer" Value="0" />
      </Sprite>
      <Sprite Name="CrystalizedBot 4" DefinitionName="CrystalizedBot" StateName="MoveLeft" CurrentFrame="0" X="5553" Y="613" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="temp" Value="0" />
        <ParameterValue ParameterName="Contents" Value="0" />
        <ParameterValue ParameterName="RegenerateTime" Value="0" />
        <ParameterValue ParameterName="regenTimer" Value="0" />
      </Sprite>
      <SpritePlan Name="Welcome message" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="288" Y="1440" Weight="0" />
        <Coordinate Sequence="2" X="320" Y="1472" Weight="0" />
        <PlanRule Name="Display welcome message" Sequence="5" Type="Do" Function="ShowMessage" Parameter1="&quot;Welcome! Use this area to familiarize\r\nyourself with the basics of the game.\r\nThis message displays automatically\r\nwhen you touch it, but most messages\r\nwill only display when you press the\r\nselect button (space bar by default).\r\nUse the arrow keys to move. You can\r\nchange the controls in the options\r\nmenu (not yet available in the web\r\nversion). Press space to continue.&quot;" EndIf="true" Suspended="false" />
        <PlanRule Name="Set message button" Sequence="3" Type="Do" Function="SetMessageDismissal" Parameter1="GeneralRules.ButtonSpecifier.Second|GeneralRules.ButtonSpecifier.FreezeInputs" Parameter2="1" EndIf="false" Suspended="false" />
        <PlanRule Name="If player touched message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And player wasn't already touching message" Sequence="2" Type="And" Function="!WasSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="Set Message Background" Sequence="4" Type="Do" Function="SetMessageBackground" Parameter1="System.Drawing.KnownColor.Black" Parameter2="196" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="QuickExit" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="96" Y="1472" Weight="0" />
        <Coordinate Sequence="2" X="128" Y="1504" Weight="0" />
        <PlanRule Name="Quick exit to main map" Sequence="2" Type="Do" Function="SwitchToMap" Parameter1="typeof(World_Map)" Parameter2="true" EndIf="true" Suspended="false" />
        <PlanRule Name="If player is in the quick exit door" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="QuickExitMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="192" Y="1472" Weight="0" />
        <Coordinate Sequence="2" X="224" Y="1504" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show quick exit message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;If you don't need this tutorial, you\r\ncan take the shortcut to the world\r\nmap through this doorway.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="ScrollToPlayer1" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <PlanRule Name="Scroll to player 1 sprite" Sequence="1" Type="Do" Function="ScrollSpriteIntoView" Parameter1="m_ParentLayer.m_Player_1" Parameter2="true" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="VineMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="512" Y="1408" Weight="0" />
        <Coordinate Sequence="2" X="544" Y="1440" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;The default button for jumping is\r\nCtrl. Up is used for climbing.\r\nYou can climb vines. Just stand in\r\nin front of the vine and press up\r\nor down to begin climbing.\r\nMoving off the vine will stop.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="CoinMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="704" Y="1472" Weight="0" />
        <Coordinate Sequence="2" X="736" Y="1504" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Collect coins by touching them.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="HurtTilesMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="928" Y="1472" Weight="0" />
        <Coordinate Sequence="2" X="960" Y="1504" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Fire will hurt you if you touch it.\r\nSpikes will kill you instantly.\r\nAvoid touching these. Jump over.\r\nDon't worry about the torch fire.\r\nIt may start other fires, but it's\r\nsmall enough that it won't hurt\r\nyou.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="LadderMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="1888" Y="1184" Weight="0" />
        <Coordinate Sequence="2" X="1920" Y="1216" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Ladders are also climbable, of\r\ncourse. Just press up to climb.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="FaucetMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="1728" Y="1056" Weight="0" />
        <Coordinate Sequence="2" X="1760" Y="1088" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;This fire is too dangerous to avoid\r\nand get past. You'll have to put it\r\nout. Touching the faucets above\r\nwill drip water onto the fire. That\r\nshould do the trick.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="CrouchMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="1472" Y="1056" Weight="0" />
        <Coordinate Sequence="2" X="1504" Y="1088" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Who designed such a ridiculously\r\nhigh ledge!? You'll have to jump\r\nextra high to reach it. You can\r\ncrouch by pressing down. If you\r\njump from a crouched position,\r\nyou'll reach much higher.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="SnowflakeMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="1632" Y="864" Weight="0" />
        <Coordinate Sequence="2" X="1664" Y="896" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Melting snowflakes is another way\r\nto drip water. Just touch them and\r\nthey melt.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="HealthMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2272" Y="1344" Weight="0" />
        <Coordinate Sequence="2" X="2304" Y="1376" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;After all that fire, you may need\r\nsome first aid. Pick up health to\r\nrecover, or stand in the health\r\nfountain to recover an unlimited\r\namount of health.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="YellowButton" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2752" Y="1344" Weight="0" />
        <Coordinate Sequence="2" X="2784" Y="1376" Weight="0" />
        <PlanRule Name="If player presses button" Sequence="2" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="If player is on button" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Add a associated package" Sequence="3" Type="Do" Function="ActivateSprite" Parameter1="m_ParentLayer.m_YellowPackage" EndIf="false" Suspended="false" />
        <PlanRule Name="Move to associated chute" Sequence="4" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_YellowPackage" Parameter2="m_ParentLayer.m_YellowChute[0]" EndIf="false" Suspended="false" />
        <PlanRule Name="Suppress inventory access" Sequence="6" Type="Do" Function="ChangeCounter" Parameter1="Counter.CanAccessInventory" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
        <PlanRule Name="Move to associated chute again (to avoid hitting player in subspace)" Sequence="5" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_YellowPackage" Parameter2="m_ParentLayer.m_YellowChute[0]" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="PinkButton" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2816" Y="1344" Weight="0" />
        <Coordinate Sequence="2" X="2848" Y="1376" Weight="0" />
        <PlanRule Name="If player is on button" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="If player presses button" Sequence="2" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Add a associated package" Sequence="3" Type="Do" Function="ActivateSprite" Parameter1="m_ParentLayer.m_PinkPackage" EndIf="false" Suspended="false" />
        <PlanRule Name="Move to associated chute" Sequence="4" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_PinkPackage" Parameter2="m_ParentLayer.m_PinkChute[0]" EndIf="false" Suspended="false" />
        <PlanRule Name="Move to associated chute again (to avoid hitting player in subspace)" Sequence="5" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_PinkPackage" Parameter2="m_ParentLayer.m_PinkChute[0]" EndIf="true" Suspended="false" />
        <PlanRule Name="Suppress inventory access" Sequence="6" Type="Do" Function="ChangeCounter" Parameter1="Counter.CanAccessInventory" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="CyanButton" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2880" Y="1344" Weight="0" />
        <Coordinate Sequence="2" X="2912" Y="1376" Weight="0" />
        <PlanRule Name="If player is on button" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="If player presses button" Sequence="2" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Add a associated package" Sequence="3" Type="Do" Function="ActivateSprite" Parameter1="m_ParentLayer.m_CyanPackage" EndIf="false" Suspended="false" />
        <PlanRule Name="Move to associated chute" Sequence="4" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_CyanPackage" Parameter2="m_ParentLayer.m_CyanChute[0]" EndIf="false" Suspended="false" />
        <PlanRule Name="Move to associated chute again (to avoid hitting player in subspace)" Sequence="5" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_CyanPackage" Parameter2="m_ParentLayer.m_CyanChute[0]" EndIf="true" Suspended="false" />
        <PlanRule Name="Suppress inventory access" Sequence="6" Type="Do" Function="ChangeCounter" Parameter1="Counter.CanAccessInventory" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="YellowChute" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2752" Y="1120" Weight="0" />
      </SpritePlan>
      <SpritePlan Name="PinkChute" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2816" Y="1120" Weight="0" />
      </SpritePlan>
      <SpritePlan Name="CyanChute" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2880" Y="1120" Weight="0" />
      </SpritePlan>
      <SpritePlan Name="PackageMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="2688" Y="1344" Weight="0" />
        <Coordinate Sequence="2" X="2720" Y="1376" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Conveyor belts move anything that\r\nfalls onto them, including you.\r\nTry pushing these buttons to drop\r\nsome packages that you can push\r\nonto the spikes so you can safely\r\nwalk over them. Push the button\r\nagain if you need to re-position\r\nthe package.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="BombMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="3488" Y="1248" Weight="0" />
        <Coordinate Sequence="2" X="3520" Y="1280" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Some fool has stacked crates of\r\nexplosives here making it\r\nimpassable! Fortunately the bomb\r\nartillery room is right here too.\r\nGo pick up a bomb and drop it\r\nnext to a crate using the Use key\r\n(Enter by default). Stand back\r\nbefore it blows! (If you pressed\r\nspace and arrow at the wrong time\r\naccidentally, you may need to hold\r\nspace and use the arrow keys to re-\r\nselect the bomb from your\r\ninventory.)&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="BombotMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="4064" Y="1152" Weight="0" />
        <Coordinate Sequence="2" X="4096" Y="1184" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;There's a bomb robot trapped in the\r\nfreezer. If you free it, you might\r\nnot need to use as many of your own\r\nbombs to eliminate those explosive\r\ncrates. It's trapped by blocks of\r\nice. Those are harder to melt. If\r\nYou ignite the torch with an\r\nexplosion, that will provide lots\r\nof warmth. The robot can be\r\ndangerous when you don't want it.\r\nWater will destroy it, but be\r\ncareful not to destroy it before\r\nyou're done with it.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="TorchCrateMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="4544" Y="1376" Weight="0" />
        <Coordinate Sequence="2" X="4576" Y="1408" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Sometimes bombs won't work or are\r\ntoo dangerous with the explosions\r\nand the mayhem and pain in the\r\nglavin. Try standing on that ledge\r\nto throw a torch at the explosive\r\ncrates. Unlike bombs, thrown\r\ntorches don't hurt you, and they\r\nignite things more quickly.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="TorchMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="4480" Y="1216" Weight="0" />
        <Coordinate Sequence="2" X="4512" Y="1248" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Bombs are not the only things you\r\ncan carry around and use. When\r\nyou're not standing in front of a\r\nmessage, try holding down the\r\nselection button (space by default)\r\nand using the arrow keys to select\r\nanother item. Pick up the torches\r\nover there, and then you'll have\r\nanother item to use. The currently\r\nselected item is always displayed\r\nat the top of the screen along with\r\nthe quantity of that item that\r\nyou are carrying.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="RocketMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="4736" Y="1248" Weight="0" />
        <Coordinate Sequence="2" X="4768" Y="1280" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Sometimes even throwing a torch\r\nwon't get you the explosion you\r\nneed where you need it. But torches\r\n(and other forms of fire) can\r\nignite rockets (which can ignite\r\nother rockets). Try throwing a\r\ntorch on the rocket down there. You\r\ncan't get through here, but the\r\ncrates down here can blow open an\r\nentrance above.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="CheckpointMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="4960" Y="1376" Weight="0" />
        <Coordinate Sequence="2" X="4992" Y="1408" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;You can save your game at any time\r\nfrom the save menu using button 4\r\n(right shift by default). Touching\r\nthis checkpoint flag automatically\r\nsaves the game in the checkpoint\r\nslot (separate from the others). It\r\ncan also be activated with the\r\nselect button (like a message) as\r\nanother way to access the save\r\nmenu.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="BiologyMessage1" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5472" Y="1184" Weight="0" />
        <Coordinate Sequence="2" X="5504" Y="1216" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Time to learn a little biology. The\r\nworm is patrolling the ladder which\r\nmakes it hard to pass without being\r\nhurt (yeah, that's right, touching\r\nworms hurts for some reason).\r\nFortunately someone has set us up\r\nthe bomb (all your base are\r\nbelong to them). Actually, it's\r\ncalled a nano-bot.  Normally they\r\nare too small to see, but these\r\nbots emit images of symbols to make\r\nworking with them easier. These\r\nimages not only make it possible to\r\nsee where the bots are, but allow\r\nyou to see what they do and how\r\nthey interact. Go take a closer\r\nlook at that bot and read more\r\nabout it.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="BiohazardMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5184" Y="1248" Weight="0" />
        <Coordinate Sequence="2" X="5216" Y="1280" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Don't be afraid to enter the\r\nbiohazard containment area. The\r\nperimeter is designed only to\r\ndestroy microorganisms, not animals\r\nand people (as which you probably\r\nqualify). You may pick up some\r\nmicrobes while in that area, and\r\nthe perimeter will simply ensure\r\nthat they do not leave the area.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="BiologyMessage2" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5664" Y="1216" Weight="0" />
        <Coordinate Sequence="2" X="5696" Y="1248" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;This bot is composed of 3 elements.\r\nThe movement node indicates all 4 \u0008\r\ndirections meaning that it will\r\nfollow the nearest enemy. The\r\naction node indicates a bomb \u0009,\r\nmeaning that this bot can drop 1\r\nbomb. Both of these nodes require\r\npower sources. The bomb node is\r\nalready attached to a collision\r\npower source \u000b, which means that it\r\nwill be activated when the power\r\nsource comes in contact with an\r\nenemy. You need only supply a power\r\nsource for the movement node in\r\norder to make the whole nano-bot\r\nmove. If it can chase down that\r\nworm, that should cause the bomb\r\nto activate clearing up your\r\nproblem. Check the bunker below the\r\nprevious message for more\r\ninformation on power sources.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="BiologyMessage3" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5632" Y="1504" Weight="0" />
        <Coordinate Sequence="2" X="5664" Y="1536" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;This crystalized component is\r\nperhaps the simplest means to\r\nacquire nano-bot components.\r\nCrystalized components are inactive\r\nand can be taken by touching them.\r\nTake this, then select the \u000c compo-\r\nnent from your inventory. Stand on\r\nthe ledge on top of this bunker and\r\nrelease the bot component with the\r\nuse button (Enter by default). Make\r\nsure there is a straight path from\r\nyour position to the nano-bot\r\nbecause this component is very\r\nfragile and will self-destruct if\r\nit hits anything along the way. It\r\nattaches to any node that requires\r\npower and supplies constant energy\r\nfor a limited time. It's attracted\r\ndirectly to the nearest such node\r\nthat is in range.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="NanoDestructorMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="6016" Y="1216" Weight="0" />
        <Coordinate Sequence="2" X="6048" Y="1248" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;The world could get ugly if\r\ncluttered with nano-bots, so\r\nbiohazard containment fields often\r\nsurround areas where these\r\nmicroorganisms are expected to be\r\ncommonly used. Furthermore, you\r\nhave an unlimited supply of nano-\r\nbot destructors \u000e. Please keep our\r\nworld tidy by releasing a nano-bot\r\ndestructor to dispose of any\r\nobsolete nano-bots. If you release\r\nan extra destructor by mistake, be\r\naware that destructors can also\r\ndestroy other destructors! Also, be\r\naware that when you walk through a\r\nbiohazard perimeter, all the\r\nnano-bot components you are\r\ncarrying will be destroyed (except\r\ndestructors).&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="ActivateBombBot2" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="6080" Y="672" Weight="0" />
        <Coordinate Sequence="2" X="6112" Y="704" Weight="0" />
        <PlanRule Name="If player is on button" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="And is pressing button" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Activate bomb bot" Sequence="3" Type="Do" Function="ActivateSprite" Parameter1="m_ParentLayer.m_Bombot_2" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="GreenChute" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5824" Y="512" Weight="0" />
      </SpritePlan>
      <SpritePlan Name="GreenButton" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5952" Y="576" Weight="0" />
        <Coordinate Sequence="2" X="5984" Y="608" Weight="0" />
        <PlanRule Name="If player is within plan" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressing button" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Activate green package" Sequence="3" Type="Do" Function="ActivateSprite" Parameter1="m_ParentLayer.m_GreenPackage" EndIf="false" Suspended="false" />
        <PlanRule Name="Move to chute" Sequence="4" Type="Do" Function="TransportToPoint" Parameter1="m_ParentLayer.m_GreenPackage" Parameter2="m_ParentLayer.m_GreenChute[0]" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="GreenPackageMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="6176" Y="768" Weight="0" />
        <Coordinate Sequence="2" X="6208" Y="800" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Packages can contain useful items.\r\nThe packages dispensed from the\r\ngreen chute will release an energy\r\nsource for a nanobot when hit by\r\nan explosion. The energy source is\r\nin crystalized form meaning that\r\nyou can pick it up and use it\r\nwherever you like rather than\r\nhaving to deal with it wherever it\r\nhappens to fall.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="EaterMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5760" Y="576" Weight="0" />
        <Coordinate Sequence="2" X="5792" Y="608" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;The creature at the bottom of the\r\nladder is an eater. It will eat\r\nsome things that it touches such as\r\nwater and crystalize it into\r\na nanobot component for you. That\r\nwill be handy in watering the seed\r\non the left. You'll need to\r\nfigure out how to construct your\r\nown nanobot from scratch to get\r\nthat seed watered somehow, but the\r\neater will give you one component\r\nyou need.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="SeedMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="5504" Y="768" Weight="0" />
        <Coordinate Sequence="2" X="5536" Y="800" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;Seeds can grow plants that help you\r\nreach high places or produce useful\r\nitems or creatures from its leaves.\r\nThis unique plant will produce\r\nworms. Annoying pests, but also\r\nuseful for tunneling into dirt!\r\nWatch out for the spider, but it\r\ntoo is useful here for activating\r\na nanobot to water the seed to make\r\nit germinate. Try releasing bots in\r\nthe following sequence while\r\nstanding on the faucet at the top\r\r\nof the ladder: \u000f \u000b \u0008 \u000c.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="ExitToMap" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="6912" Y="1376" Weight="0" />
        <Coordinate Sequence="2" X="6944" Y="1408" Weight="0" />
        <PlanRule Name="If player is in the exit door" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_Player_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Exit to main map" Sequence="2" Type="Do" Function="SwitchToMap" Parameter1="typeof(World_Map)" Parameter2="true" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="TollMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="6304" Y="1376" Weight="0" />
        <Coordinate Sequence="2" X="6336" Y="1408" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;This is a toll gate. You must pay 1\r\ncoin per door to get through.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="ExitMessage" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="6688" Y="1376" Weight="0" />
        <Coordinate Sequence="2" X="6720" Y="1408" Weight="0" />
        <PlanRule Name="If player is touching message" Sequence="1" Type="If" Function="IsSpriteTouching" Parameter1="m_ParentLayer.m_Player_1" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button 2" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_Player_1" Parameter2="SpriteBase.InputBits.Button2" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Show message" Sequence="3" Type="Do" Function="ShowMessage" Parameter1="&quot;There is much more to learn, but\r\nsurely it would be more fun to do\r\nso while making actual progress\r\nrather than simply as practice.\r\nBegin your journey on the world\r\nmap through this doorway.&quot;" EndIf="true" Suspended="false" />
      </SpritePlan>
    </Layer>
    <Layer Name="InsideBackground" Width="1086" Height="148" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="2" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH9/f39/f39/f39/f38AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH9/f39/f39/f39/f39/fwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH9/f39/f39/f39/f39/fwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH9/f39/f39/f39/f39/fwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH9/f39/f39/f39/f39/fwAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH9/f39/f39/f39/f39/fwAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAABXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAAAAAABXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAABXV1dXV1dXV1dXV1dXV1dXV1dXV1dXf39/f39XV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXf39/f39XV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXf39/f39XV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXf39/f39XV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAV1dXV1dXV1dXV1dXf39/f39XV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAFhYWFhYWFhYWAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWFgAAABYWAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFhYWABYWAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhYWABYWAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWFhYWAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABXV1dXV1dXV1dXV1cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</Tiles>
    </Layer>
  </Map>
  <Map Name="SaveOrLoadGame" ScrollMarginLeft="32" ScrollMarginTop="32" ScrollMarginRight="32" ScrollMarginBottom="32" ScrollWidth="640" ScrollHeight="480" ViewLeft="0" ViewTop="0" ViewWidth="0" ViewHeight="0">
    <Layer Name="Designer Background" Width="1" Height="1" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" ZIndex="0" Priority="0" VirtualWidth="4000" VirtualHeight="4000">
      <Tiles>AA==</Tiles>
    </Layer>
    <Layer Name="Main" Width="59" Height="34" Tileset="CoolText" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="2" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALS0tLS0tLS0tLS0tLS0tLS0tLS0tAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU2F2ZWQAR2FtZQBTbG90cwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgYGBAFNsb3QAMQAtAAEAAAAAAIGBgQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgoKCAFNsb3QAMgAtAAIAAAAAAIKCggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg4ODAFNsb3QAMwAtAAMAAAAAAIODgwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAISEhABDaGVja3BvaW50AC0ABAAAAAAAhISEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIWFhQBDYW5jZWwAhYWFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUwBhAHYAZQAAAEcAYQBtAGUAAAAATABvAGEAZAAAAEcAYQBtAGUAAAAAAAAAAAAAAAAAAAAAAAAARABlAGwAZQB0AGUAAABHAGEAbQBlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</Tiles>
      <Sprite Name="MenuDummy 1" DefinitionName="MenuDummy" StateName="Main" CurrentFrame="0" X="593" Y="428" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="InputsReleased" Value="0" />
      </Sprite>
      <SpritePlan Name="HandleMenu" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="21" Y="411" Weight="0" />
        <Coordinate Sequence="2" X="68" Y="457" Weight="0" />
        <PlanRule Name="If not initialized" Sequence="1" Type="If" Function="!IsMapFlagOn" Parameter1="1" EndIf="false" Suspended="false" />
        <PlanRule Name="Set initialized" Sequence="14" Type="Do" Function="SetMapFlag" Parameter1="1" Parameter2="true" EndIf="true" Suspended="false" />
        <PlanRule Name="If game slot 1 is full" Sequence="2" Type="If" Function="SaveExists" Parameter1="0" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Set slot 1 status" Sequence="3" Type="Do" Function="ChangeCounter" Parameter1="Counter.SaveSlot1" Parameter2="CounterOperation.SetToMaximum" EndIf="false" Suspended="false" />
        <PlanRule Name="Else clear slot 1 status" Sequence="4" Type="Else" Function="ChangeCounter" Parameter1="Counter.SaveSlot1" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
        <PlanRule Name="If game slot 2 is full" Sequence="5" Type="If" Function="SaveExists" Parameter1="1" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Set slot 2 status" Sequence="6" Type="Do" Function="ChangeCounter" Parameter1="Counter.SaveSlot2" Parameter2="CounterOperation.SetToMaximum" EndIf="false" Suspended="false" />
        <PlanRule Name="Else clear slot 2 status" Sequence="7" Type="Else" Function="ChangeCounter" Parameter1="Counter.SaveSlot2" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
        <PlanRule Name="If game slot 3 is full" Sequence="8" Type="If" Function="SaveExists" Parameter1="2" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Set slot 3 status" Sequence="9" Type="Do" Function="ChangeCounter" Parameter1="Counter.SaveSlot3" Parameter2="CounterOperation.SetToMaximum" EndIf="false" Suspended="false" />
        <PlanRule Name="Else clear slot 3 status" Sequence="10" Type="Else" Function="ChangeCounter" Parameter1="Counter.SaveSlot3" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
        <PlanRule Name="Else If pressed up" Sequence="18" Type="ElseIf" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="SpriteBase.InputBits.Up" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Previous slot" Sequence="19" Type="Do" Function="ChangeCounter" Parameter1="Counter.CurrentSlot" Parameter2="CounterOperation.DecrementAndLoop" EndIf="false" Suspended="false" />
        <PlanRule Name="If pressed down" Sequence="25" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="SpriteBase.InputBits.Down" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Next slot" Sequence="26" Type="Do" Function="ChangeCounter" Parameter1="Counter.CurrentSlot" Parameter2="CounterOperation.IncrementAndLoop" EndIf="false" Suspended="false" />
        <PlanRule Name="If pressed button" Sequence="32" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="SpriteBase.InputBits.Button1|SpriteBase.InputBits.Button2|SpriteBase.InputBits.Button3|SpriteBase.InputBits.Button4" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Else if saving the game" Sequence="36" Type="ElseIf" Function="==" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="0" EndIf="true" Suspended="false" />
        <PlanRule Name="If slot is less than 4" Sequence="33" Type="If" Function="&lt;" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="4" EndIf="false" Suspended="false" />
        <PlanRule Name="Move dummy sprite to return plan" Sequence="41" Type="Do" Function="TransportToPlan" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="m_ParentLayer.m_HandleMenu" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
        <PlanRule Name="If sprite is on return plan" Sequence="15" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Return to previous map" Sequence="17" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="false" Suspended="false" />
        <PlanRule Name="End if sprite is on/off return plan" Sequence="49" Type="End" Function="End" EndIf="true" Suspended="false" />
        <PlanRule Name="If loading game" Sequence="34" Type="If" Function="==" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="1" EndIf="false" Suspended="false" />
        <PlanRule Name="Load the game" Sequence="35" Type="Do" Function="LoadGame" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="End if slot is less than 4" Sequence="40" Type="End" Function="End" EndIf="true" Suspended="false" />
        <PlanRule Name="If pressed left or right" Sequence="42" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="SpriteBase.InputBits.Right|SpriteBase.InputBits.Left" Parameter3="true" EndIf="false" Suspended="true" />
        <PlanRule Name="Swap save/load" Sequence="43" Type="Do" Function="ChangeCounter" Parameter1="Counter.SaveLoadDelete" Parameter2="CounterOperation.IncrementAndLoop" EndIf="false" Suspended="true" />
        <PlanRule Name="And no inputs are pressed" Sequence="16" Type="And" Function="!IsInputPressed" Parameter1="m_ParentLayer.m_MenuDummy_1" Parameter2="SpriteBase.InputBits.Up|SpriteBase.InputBits.Right|SpriteBase.InputBits.Down|SpriteBase.InputBits.Left|SpriteBase.InputBits.Button1|SpriteBase.InputBits.Button2|SpriteBase.InputBits.Button3|SpriteBase.InputBits.Button4" Parameter3="false" EndIf="false" Suspended="false" />
        <PlanRule Name="While current slot has no save (up)" Sequence="20" Type="While" Function="!SaveExists" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Skip slot up" Sequence="23" Type="Do" Function="ChangeCounter" Parameter1="Counter.CurrentSlot" Parameter2="CounterOperation.DecrementAndLoop" EndIf="true" Suspended="false" />
        <PlanRule Name="And current slot is not cancel (up)" Sequence="21" Type="And" Function="!=" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="4" EndIf="false" Suspended="false" />
        <PlanRule Name="End if (up)" Sequence="24" Type="End" Function="End" EndIf="true" Suspended="false" />
        <PlanRule Name="End if (down)" Sequence="31" Type="End" Function="End" EndIf="true" Suspended="false" />
        <PlanRule Name="And is not saving game (up)" Sequence="22" Type="And" Function="&gt;" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="0" EndIf="false" Suspended="false" />
        <PlanRule Name="While current slot has no save (down)" Sequence="27" Type="While" Function="!SaveExists" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="And current slot is not cancel (down)" Sequence="28" Type="And" Function="!=" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="4" EndIf="false" Suspended="false" />
        <PlanRule Name="And is not saving game (down)" Sequence="29" Type="And" Function="&gt;" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="0" EndIf="false" Suspended="false" />
        <PlanRule Name="Skip slot down" Sequence="30" Type="Do" Function="ChangeCounter" Parameter1="Counter.CurrentSlot" Parameter2="CounterOperation.IncrementAndLoop" EndIf="true" Suspended="false" />
        <PlanRule Name="While current slot has no save (swap)" Sequence="44" Type="While" Function="!SaveExists" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="false" EndIf="false" Suspended="true" />
        <PlanRule Name="And current slot is not cancel (swap)" Sequence="45" Type="And" Function="!=" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="4" EndIf="false" Suspended="true" />
        <PlanRule Name="And is not saving game (swap)" Sequence="46" Type="And" Function="&gt;" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="0" EndIf="false" Suspended="true" />
        <PlanRule Name="Skip slot (swap)" Sequence="47" Type="Do" Function="ChangeCounter" Parameter1="Counter.CurrentSlot" Parameter2="CounterOperation.IncrementAndLoop" EndIf="true" Suspended="true" />
        <PlanRule Name="End if left or right" Sequence="48" Type="End" Function="End" EndIf="true" Suspended="true" />
        <PlanRule Name="Save the game" Sequence="37" Type="Do" Function="SaveGame" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Else delete the game" Sequence="38" Type="Else" Function="DeleteSave" Parameter1="Counter.CurrentSlot.CurrentValue" Parameter2="false" EndIf="true" Suspended="false" />
        <PlanRule Name="End if loading game" Sequence="39" Type="End" Function="End" EndIf="true" Suspended="false" />
        <PlanRule Name="If checkpoint game slot is full" Sequence="11" Type="If" Function="SaveExists" Parameter1="3" Parameter2="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Set checkpoint slot status" Sequence="12" Type="Do" Function="ChangeCounter" Parameter1="Counter.SaveSlotCP" Parameter2="CounterOperation.SetToMaximum" EndIf="false" Suspended="false" />
        <PlanRule Name="Else clear checkpoint lsot status" Sequence="13" Type="Else" Function="ChangeCounter" Parameter1="Counter.SaveSlotCP" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="SaveOrLoad" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="132" Y="75" Weight="0" />
        <Coordinate Sequence="2" X="363" Y="90" Weight="0" />
        <PlanRule Name="If is loading game" Sequence="1" Type="If" Function="==" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="1" EndIf="false" Suspended="false" />
        <PlanRule Name="Copy &quot;Load&quot; text" Sequence="2" Type="Do" Function="CopyFrom" Parameter1="m_ParentLayer.m_LoadText" Parameter2="RelativePosition.TopLeft" EndIf="false" Suspended="false" />
        <PlanRule Name="Copy &quot;Save&quot; text" Sequence="4" Type="Do" Function="CopyFrom" Parameter1="m_ParentLayer.m_SaveText" Parameter2="RelativePosition.TopLeft" EndIf="false" Suspended="false" />
        <PlanRule Name="Else if saving the game" Sequence="3" Type="ElseIf" Function="==" Parameter1="Counter.SaveLoadDelete.CurrentValue" Parameter2="0" EndIf="false" Suspended="false" />
        <PlanRule Name="Else copy &quot;Delete&quot; text" Sequence="5" Type="Else" Function="CopyFrom" Parameter1="m_ParentLayer.m_DeleteText" Parameter2="RelativePosition.TopLeft" EndIf="true" Suspended="false" />
        <PlanRule Name="End if loading game" Sequence="6" Type="End" Function="End" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="SaveText" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="0" Y="480" Weight="0" />
        <Coordinate Sequence="2" X="231" Y="495" Weight="0" />
      </SpritePlan>
      <SpritePlan Name="LoadText" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="231" Y="480" Weight="0" />
        <Coordinate Sequence="2" X="462" Y="495" Weight="0" />
      </SpritePlan>
      <SpritePlan Name="DeleteText" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="0" Y="495" Weight="0" />
        <Coordinate Sequence="2" X="231" Y="510" Weight="0" />
      </SpritePlan>
    </Layer>
    <Layer Name="Background" Width="1" Height="1" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="1" Priority="0" VirtualWidth="59" VirtualHeight="32">
      <Tiles>Eg==</Tiles>
    </Layer>
  </Map>
  <Map Name="Menu" ScrollMarginLeft="0" ScrollMarginTop="0" ScrollMarginRight="0" ScrollMarginBottom="0" ScrollWidth="640" ScrollHeight="480">
    <Layer Name="Designer Background" Width="1" Height="1" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" Priority="0" VirtualWidth="4000" VirtualHeight="4000">
      <Tiles>AA==</Tiles>
    </Layer>
    <Layer Name="Background" Width="1" Height="1" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="1" Priority="0" VirtualWidth="20" VirtualHeight="15">
      <Tiles>Vg==</Tiles>
    </Layer>
    <Layer Name="Main" Width="59" Height="32" Tileset="CoolText" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="2" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU2F2ZQBnYW1lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAExvYWQAZ2FtZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEZWxldGUAc2F2ZWQAZ2FtZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU2FjcmlmaWNlAHBsYXllcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABSZXR1cm4AdG8AZ2FtZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</Tiles>
      <Sprite Name="MenuPointer 1" DefinitionName="MenuPointer" StateName="Main" CurrentFrame="0" X="154" Y="150" DX="0" DY="0" Priority="1" Active="true" Color="-1">
        <ParameterValue ParameterName="MenuItemCount" Value="0" />
      </Sprite>
      <SpritePlan Name="SaveGame" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="150" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="165" Weight="0" />
        <PlanRule Name="If menu sprite chose this command" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Go to save game" Sequence="5" Type="Do" Function="SwitchToMap" Parameter1="typeof(SaveOrLoadGame_Map)" Parameter2="false" EndIf="true" Suspended="false" />
        <PlanRule Name="Save mode" Sequence="3" Type="Do" Function="ChangeCounter" Parameter1="Counter.SaveLoadDelete" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
        <PlanRule Name="Return" Sequence="4" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" Parameter3="true" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="LoadGame" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="180" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="195" Weight="0" />
        <PlanRule Name="If menu sprite chose this command" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Load mode" Sequence="3" Type="Do" Function="=" Parameter1="1" ResultParameter="Counter.SaveLoadDelete.CurrentValue" EndIf="false" Suspended="false" />
        <PlanRule Name="Go to load game" Sequence="5" Type="Do" Function="SwitchToMap" Parameter1="typeof(SaveOrLoadGame_Map)" Parameter2="false" EndIf="true" Suspended="false" />
        <PlanRule Name="Return" Sequence="4" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" Parameter3="true" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Sacrifice" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="240" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="255" Weight="0" />
        <PlanRule Name="If menu sprite chose this command" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Set global action to hurt player" Sequence="4" Type="Do" Function="=" Parameter1="1" ResultParameter="Counter.GlobalAction.CurrentValue" EndIf="false" Suspended="false" />
        <PlanRule Name="Return to previous map" Sequence="6" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="true" Suspended="false" />
        <PlanRule Name="Set player health to 0" Sequence="5" Type="Do" Function="=" Parameter1="0" ResultParameter="Counter.Health.CurrentValue" EndIf="false" Suspended="false" />
        <PlanRule Name="And button was pressed" Sequence="2" Type="And" Function="WasInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" EndIf="false" Suspended="false" />
        <PlanRule Name="And button is no longer pressed" Sequence="3" Type="And" Function="!IsInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" Parameter3="false" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Skip" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="270" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="285" Weight="0" />
        <PlanRule Name="If menu sprite is here" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Skip to previous item" Sequence="3" Type="Do" Function="TransportToPlan" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="m_ParentLayer.m_Sacrifice" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="If up is pressed" Sequence="2" Type="If" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Up" Parameter3="false" EndIf="false" Suspended="false" />
        <PlanRule Name="Else skip to next item" Sequence="4" Type="Else" Function="TransportToPlan" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="m_ParentLayer.m_Return" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
        <PlanRule Name="End menu sprite is here" Sequence="5" Type="End" Function="End" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Return" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="300" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="315" Weight="0" />
        <PlanRule Name="If menu sprite chose this command" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Return to game" Sequence="4" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="true" Suspended="false" />
        <PlanRule Name="And button was pressed" Sequence="2" Type="And" Function="WasInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" EndIf="false" Suspended="false" />
        <PlanRule Name="And button is no longer pressed" Sequence="3" Type="And" Function="!IsInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" Parameter3="false" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="DeleteSave" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="210" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="225" Weight="0" />
        <PlanRule Name="If menu sprite chose this command" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="And pressed button" Sequence="2" Type="And" Function="IsInputPressed" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="SpriteBase.InputBits.Button3" Parameter3="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Delete mode" Sequence="3" Type="Do" Function="=" Parameter1="2" ResultParameter="Counter.SaveLoadDelete.CurrentValue" EndIf="false" Suspended="false" />
        <PlanRule Name="Return" Sequence="4" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="false" Suspended="false" />
        <PlanRule Name="Go to save game" Sequence="5" Type="Do" Function="SwitchToMap" Parameter1="typeof(SaveOrLoadGame_Map)" Parameter2="false" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="LoopTop" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="120" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="135" Weight="0" />
        <PlanRule Name="If pointer is here" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Move sprite to bottom" Sequence="2" Type="Do" Function="TransportToPlan" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="m_ParentLayer.m_Return" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="LoopBottom" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="154" Y="330" Weight="0" />
        <Coordinate Sequence="2" X="165" Y="345" Weight="0" />
        <PlanRule Name="If pointer is here" Sequence="1" Type="If" Function="IsSpriteWithin" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
        <PlanRule Name="Move sprite to top" Sequence="2" Type="Do" Function="TransportToPlan" Parameter1="m_ParentLayer.m_MenuPointer_1" Parameter2="m_ParentLayer.m_SaveGame" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
      </SpritePlan>
    </Layer>
  </Map>
  <Map Name="Level 1" ScrollMarginLeft="280" ScrollMarginTop="200" ScrollMarginRight="280" ScrollMarginBottom="200" ScrollWidth="2048" ScrollHeight="2048">
    <Layer Name="Designer Background" Width="1" Height="1" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="0" ScrollRateY="0" Priority="0" VirtualWidth="4000" VirtualHeight="4000">
      <Tiles>AA==</Tiles>
    </Layer>
    <Layer Name="Background" Width="64" Height="64" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="1" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/fw==</Tiles>
    </Layer>
    <Layer Name="Main" Width="64" Height="64" Tileset="MainTiles" BytesPerTile="1" OffsetX="0" OffsetY="0" ScrollRateX="1" ScrollRateY="1" ZIndex="2" Priority="0" VirtualWidth="0" VirtualHeight="0">
      <Tiles>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMTExMTExMTExMTExMTExMTExMTExMAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAATExMTExMTExMTExMTExMTExMTExMTExMTAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAExMTExMTExMTExMTExMTExMTExMTExMTEwAAAAAAAAAAAAAAAAAAPQAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMAAAAAAD4TExMAAAAAAAAAAAAAAAAAAAAAAAAAAAATExMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAA9ExMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAExMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNNTQAAAAAAAAAAPRMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMAAAAAAAAAAAAAADQ0AAAAAAAAAAAAAAATExMTAAATAAA9AD0TExMAAAAAAAAAAAAAAAAAAAAAAAAAAAATExMTAAAAAAAAAAAAAAA0NAAAABMTExMTExUAAAAAAAAAAAAAPhM+ExMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAExMTEwAAAAAAAAAAAAAAAAAAAAATExMTExMTFQAAAAAAAAAAAD0TPRMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMAAAAAAAAAAAAAAAAAAAAAExMTExMTExMAAAAAAAAAAAA9Ez0TExMAAAAAAAAAAAAAAAAAAAAAAAAAAAATExMTExMTExMAAAAAAAAAAAAAABMTExMTExMTExMTExMTExMTExM9ExMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAExMTExMTExMTAAAAAAAAAAAAAAATExMTADgAOAA4ADgAWQBZAFkAPRMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMTExMTEx0dHR0dHR0dHR0dExMTExMTExMTExMTExMTExMTExMTExMAAAAAAAAAAAAAAAAAAAAAAAAAAAATExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAABMTExMTExMTExMTExMTExMTExMTExMTEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATExMTExMTExMTExMTExMTExMTExMTExMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</Tiles>
      <Sprite Name="Player 1" DefinitionName="Player" StateName="Right" CurrentFrame="0" X="616" Y="605" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="PlayerNum" Value="1" />
        <ParameterValue ParameterName="InvincibleTimer" Value="0" />
        <ParameterValue ParameterName="HurtFlag" Value="0" />
        <ParameterValue ParameterName="TouchedEnemy" Value="0" />
        <ParameterValue ParameterName="TempNum" Value="0" />
        <ParameterValue ParameterName="TouchIndex" Value="0" />
      </Sprite>
      <Sprite Name="Platform 1" DefinitionName="Platform" StateName="Main" CurrentFrame="0" X="768" Y="640" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="CoordIndex" Value="0" />
        <ParameterValue ParameterName="WaitTime" Value="0" />
      </Sprite>
      <Sprite Name="Bombot 1" DefinitionName="Bombot" StateName="Right" CurrentFrame="0" X="1393" Y="607" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="BehaviorTimer" Value="0" />
        <ParameterValue ParameterName="MoveTime" Value="240" />
        <ParameterValue ParameterName="WaitBefore" Value="60" />
        <ParameterValue ParameterName="WaitAfter" Value="240" />
        <ParameterValue ParameterName="TempNum" Value="0" />
      </Sprite>
      <Sprite Name="Spider 1" DefinitionName="Spider" StateName="Main" CurrentFrame="0" X="1504" Y="448" DX="0" DY="0" Priority="1" Active="true" Solidity="Standard" Color="-1">
        <ParameterValue ParameterName="PlayerDirection" Value="0" />
        <ParameterValue ParameterName="Behavior" Value="0" />
        <ParameterValue ParameterName="NextWeb" Value="0" />
        <ParameterValue ParameterName="StartY" Value="0" />
      </Sprite>
      <SpritePlan Name="Platform 1 Path" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <Coordinate Sequence="1" X="768" Y="640" Weight="60" />
        <Coordinate Sequence="2" X="1056" Y="640" Weight="0" />
        <Coordinate Sequence="3" X="1056" Y="544" Weight="60" />
        <Coordinate Sequence="4" X="1056" Y="640" Weight="0" />
        <PlanRule Name="Move Platform 1" Sequence="1" Type="Do" Function="FollowPath" Parameter1="m_ParentLayer.m_Platform_1" Parameter2="ref m_ParentLayer.m_Platform_1.CoordIndex" Parameter3="ref m_ParentLayer.m_Platform_1.WaitTime" EndIf="false" Suspended="false" />
      </SpritePlan>
      <SpritePlan Name="Level 1 View" Priority="1">
        <BaseClass>PlanBase</BaseClass>
        <PlanRule Name="Scroll player 1 into view" Sequence="1" Type="Do" Function="ScrollSpriteIntoView" Parameter1="m_ParentLayer.m_Player_1" Parameter2="true" EndIf="false" Suspended="false" />
      </SpritePlan>
    </Layer>
  </Map>
  <SpriteDefinition Name="Player">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Get Inputs" Sequence="1" Type="Do" Function="MapPlayerToInputs" Parameter1="PlayerNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="MoveByVelocity" Sequence="234" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else check for landing on platform" Sequence="228" Type="Else" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="true" Suspended="false" />
    <SpriteRule Name="ReactToPlatform" Sequence="227" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="ReactToSolidity" Sequence="230" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="224" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByHorizontalVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="If Pressing Left" Sequence="205" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else React To Inputs for Walking" Sequence="112" Type="Else" Function="AccelerateByInputs" Parameter1="5" Parameter2="4" Parameter3="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If standing right" Sequence="206" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="(int)Sprites.Player.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stand facing left" Sequence="207" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If Pressing Right" Sequence="213" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Right" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If standing left" Sequence="214" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Left" Parameter2="(int)Sprites.Player.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stand facing right" Sequence="215" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Scroll" Sequence="235" Type="Do" Function="ScrollSpriteIntoView" Parameter1="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Gravity" Sequence="222" Type="Do" Function="+" Parameter1="dy" Parameter2=".3" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Inertia" Sequence="223" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="95" EndIf="false" Suspended="false" />
    <SpriteRule Name="Snap to ground" Sequence="231" Type="Do" Function="SnapToGround" Parameter1="2" EndIf="true" Suspended="false" />
    <SpriteRule Name="Land on conveyor belt" Sequence="203" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="225" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="If pressing jump button" Sequence="87" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Button1" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else (not climbing) If standing on solid" Sequence="80" Type="ElseIf" Function="Blocked" Parameter1="SpriteBase.Direction.Down" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else normal jump" Sequence="93" Type="Else" Function="AlterYVelocity" Parameter1="-5" EndIf="true" Suspended="false" />
    <SpriteRule Name="If using inventory" Sequence="128" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Button3" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bomb" Sequence="131" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Bomb)" Parameter2="RelativePosition.BottomCenter" Parameter3="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If riding platform" Sequence="226" Type="If" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or riding on platform" Sequence="81" Type="Or" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="End standing on solid" Sequence="108" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Stop riding platform for jump" Sequence="89" Type="Do" Function="StopRiding" EndIf="true" Suspended="false" />
    <SpriteRule Name="If riding on a platform" Sequence="88" Type="If" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="If climbing" Sequence="70" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Climbing" Parameter2="(int)Sprites.Player.State.Climbing" EndIf="false" Suspended="false" />
    <SpriteRule Name="If not on climbable tile" Sequence="71" Type="If" Function="!IsOnTile" Parameter1="TileCategoryName.Climbable" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="If stopped climbing" Sequence="72" Type="If" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressing up" Sequence="114" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Up" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And on a climbable tile" Sequence="115" Type="And" Function="IsOnTile" Parameter1="TileCategoryName.Climbable" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="If switched to climbing" Sequence="118" Type="If" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Climbing" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to inputs for climbing" Sequence="76" Type="Do" Function="AccelerateByInputs" Parameter1="2" Parameter2="3" Parameter3="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="Inertia for climbing" Sequence="77" Type="Do" Function="ReactToInertia" Parameter1="90" Parameter2="90" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate for climbing" Sequence="78" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByVectorVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="React To Solid for climbing" Sequence="79" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or pressing down" Sequence="116" Type="Or" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Down" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And on a climbable tile (down)" Sequence="117" Type="And" Function="IsOnTile" Parameter1="TileCategoryName.Climbable" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Use climbing solidity" Sequence="119" Type="Do" Function="SetSolidity" Parameter1="Solidity.Climbing_solidity" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if trying to climb" Sequence="125" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Switch to standard solidity" Sequence="73" Type="Do" Function="SetSolidity" Parameter1="Solidity.Standard" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if not on climbable tile" Sequence="74" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressing up (for un-crouch)" Sequence="126" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Up" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If crouching right (for turn)" Sequence="208" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="(int)Sprites.Player.State.Crouch_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Crouch facing left" Sequence="209" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Crouch_left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if pressing left" Sequence="212" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If crouching left (for turn)" Sequence="216" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_left" Parameter2="(int)Sprites.Player.State.Crouch_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Crouch facing right" Sequence="217" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if pressing right" Sequence="220" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If crouching" Sequence="110" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="(int)Sprites.Player.State.Crouch_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to inputs for crouching" Sequence="111" Type="Do" Function="AccelerateByInputs" Parameter1="2" Parameter2="1" Parameter3="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if crouching" Sequence="113" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If crouching for jump" Sequence="90" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="(int)Sprites.Player.State.Crouch_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="High jump" Sequence="92" Type="Do" Function="AlterYVelocity" Parameter1="-8" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if pressing jump" Sequence="94" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Un-crouch" Sequence="127" Type="Do" Function="UnCrouch" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to pushback" Sequence="229" Type="Do" Function="ReactToPushback" Parameter1="ParentLayer.m_SpriteCategories.Pushback" EndIf="false" Suspended="false" />
    <SpriteRule Name="If falling right" Sequence="82" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="(int)Sprites.Player.State.Falling_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land right" Sequence="83" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If falling left" Sequence="84" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Falling_left" Parameter2="(int)Sprites.Player.State.Falling_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land left" Sequence="85" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Switch to falling/jumping right" Sequence="104" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If walking left (for fall)" Sequence="105" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Left" Parameter2="(int)Sprites.Player.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to falling/jumping left" Sequence="107" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If falling right (for turn)" Sequence="210" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="(int)Sprites.Player.State.Falling_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn to fall left" Sequence="211" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If falling left (for turn)" Sequence="218" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Falling_left" Parameter2="(int)Sprites.Player.State.Falling_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn to fall right" Sequence="219" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="And uncrouch for jump works" Sequence="91" Type="And" Function="UnCrouch" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else (not standing on solid) if walking right (for fall)" Sequence="102" Type="ElseIf" Function="IsInState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="(int)Sprites.Player.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or crouching right (for fall)" Sequence="103" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="(int)Sprites.Player.State.Crouch_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or crouching left (for fall)" Sequence="106" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_left" Parameter2="(int)Sprites.Player.State.Crouch_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="If pressing down" Sequence="95" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Down" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If walking left" Sequence="96" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Left" Parameter2="(int)Sprites.Player.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Crouch left" Sequence="97" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Crouch_left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If walking right" Sequence="98" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="(int)Sprites.Player.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Crouch right" Sequence="99" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if pressing down" Sequence="100" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If hurt" Sequence="2" Type="If" Function="==" Parameter1="HurtFlag" Parameter2="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="If walking right when hurt" Sequence="4" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="(int)Sprites.Player.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or crouching right when hurt" Sequence="5" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="(int)Sprites.Player.State.Crouch_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to rightward hurt falling state" Sequence="8" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if in another state that needs to switch" Sequence="9" Type="ElseIf" Function="IsInState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="(int)Sprites.Player.State.Crouch_left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to leftward hurt falling state" Sequence="12" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Falling_left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if walking when hurt" Sequence="13" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Hurled backwards to the left" Sequence="6" Type="Do" Function="=" Parameter1="-4" ResultParameter="dx" EndIf="false" Suspended="false" />
    <SpriteRule Name="Hurled upwards top the left" Sequence="7" Type="Do" Function="=" Parameter1="-4" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Hurled backwards to the right" Sequence="10" Type="Do" Function="=" Parameter1="4" ResultParameter="dx" EndIf="false" Suspended="false" />
    <SpriteRule Name="Hurled upwards to the right" Sequence="11" Type="Do" Function="=" Parameter1="-4" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set temporary invincibility" Sequence="14" Type="Do" Function="=" Parameter1="120" ResultParameter="InvincibleTimer" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set invincible color" Sequence="15" Type="Do" Function="=" Parameter1="128" ResultParameter="ModulateAlpha" EndIf="true" Suspended="false" />
    <SpriteRule Name="If was hurt" Sequence="236" Type="If" Function="==" Parameter1="HurtFlag" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset hurt flag" Sequence="238" Type="Do" Function="=" Parameter1="0" ResultParameter="HurtFlag" EndIf="false" Suspended="false" />
    <SpriteRule Name="If damage to player health kills player" Sequence="240" Type="If" Function="ChangeCounter" Parameter1="Counter.Health" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Return to previous map and reset level" Sequence="243" Type="Do" Function="ReturnToPreviousMap" Parameter1="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if was hurt" Sequence="244" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else (not invincible) check if touching enemy" Sequence="23" Type="Else" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Enemies" ResultParameter="TouchedEnemy" EndIf="false" Suspended="false" />
    <SpriteRule Name="If invincible" Sequence="16" Type="If" Function="&gt;" Parameter1="InvincibleTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If touching enemy" Sequence="24" Type="If" Function="&gt;=" Parameter1="TouchedEnemy" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Decrease invincibility time" Sequence="17" Type="Do" Function="-" Parameter1="InvincibleTimer" Parameter2="1" ResultParameter="InvincibleTimer" EndIf="false" Suspended="false" />
    <SpriteRule Name="If invincibility time expired" Sequence="21" Type="If" Function="==" Parameter1="InvincibleTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Restore non-invincible color" Sequence="22" Type="Do" Function="=" Parameter1="255" ResultParameter="ModulateAlpha" EndIf="true" Suspended="false" />
    <SpriteRule Name="Set hurt flag for touching an enemy" Sequence="25" Type="Do" Function="=" Parameter1="2" ResultParameter="HurtFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="Decrement hurt flag" Sequence="3" Type="Do" Function="-" Parameter1="HurtFlag" Parameter2="1" ResultParameter="HurtFlag" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if invincible" Sequence="26" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Animate invincibility color" Sequence="18" Type="Do" Function="-" Parameter1="ModulateAlpha" Parameter2="16" ResultParameter="ModulateAlpha" EndIf="false" Suspended="false" />
    <SpriteRule Name="Loop invincibility color..." Sequence="19" Type="If" Function="&lt;" Parameter1="ModulateAlpha" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="To half-transparent" Sequence="20" Type="Do" Function="=" Parameter1="128" ResultParameter="ModulateAlpha" EndIf="true" Suspended="false" />
    <SpriteRule Name="Check if touching touchable tiles" Sequence="27" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.Touchable" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not invincible" Sequence="29" Type="And" Function="==" Parameter1="InvincibleTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If touching perilous tile" Sequence="28" Type="If" Function="TileCategoryTouched" Parameter1="TileCategoryName.Perilous" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Hurt player from perilous tile" Sequence="30" Type="Do" Function="=" Parameter1="2" ResultParameter="HurtFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="Take coins" Sequence="34" Type="Do" Function="TileTake" Parameter1="52" Parameter2="Counter.Money" Parameter3="0" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If took coins" Sequence="35" Type="If" Function="&gt;" Parameter1="TempNum" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Play bing sound" Sequence="36" Type="Do" Function="Sounds.Play" Parameter1="&quot;bing&quot;" EndIf="true" Suspended="false" />
    <SpriteRule Name="While touching snowflakes" Sequence="63" Type="While" Function="TileCategoryTouched" Parameter1="TileCategoryName.PlayerMeltable" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add water droplet in place of snowflake" Sequence="64" Type="Do" Function="TileAddSprite" Parameter1="TouchIndex" Parameter2="typeof(Sprites.Droplet)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Check if touching faucet" Sequence="66" Type="While" Function="TileCategoryTouched" Parameter1="TileCategoryName.Faucet" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add water droplet in place of faucet" Sequence="67" Type="Do" Function="TileAddSprite" Parameter1="TouchIndex" Parameter2="typeof(Sprites.Droplet)" EndIf="true" Suspended="false" />
    <SpriteRule Name="Remove snowflake" Sequence="65" Type="Do" Function="TileChangeTouched" Parameter1="TouchIndex" Parameter2="0" EndIf="true" Suspended="false" />
    <SpriteRule Name="If touching deadly tiles" Sequence="31" Type="If" Function="TileCategoryTouched" Parameter1="TileCategoryName.InstantDeath" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set hurt flag for death" Sequence="32" Type="Do" Function="=" Parameter1="1" ResultParameter="HurtFlag" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set health to zero" Sequence="33" Type="Do" Function="ChangeCounter" Parameter1="Counter.Health" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
    <SpriteRule Name="If bomb is selected" Sequence="129" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If BotEnergySource is selected" Sequence="132" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop BotEnergySource" Sequence="134" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotEnergySource)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select new BotEnergy" Sequence="135" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set Energy to 200" Sequence="136" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Energy&quot;" Parameter2="200" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if using inventory" Sequence="199" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If BotDestructor is selected" Sequence="137" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop BotDestructor" Sequence="138" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotDestructor)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If Bot Mover (follow) is selected" Sequence="139" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="3" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop follower" Sequence="141" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotMover)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created follower" Sequence="142" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to follow" Sequence="143" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotMover.State.Follow" EndIf="true" Suspended="false" />
    <SpriteRule Name="If collision power source is selected" Sequence="164" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop collision power source" Sequence="166" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotEnergySource)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created collision power source" Sequence="167" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to collision power source" Sequence="169" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotEnergySource.State.OnCollision" EndIf="true" Suspended="false" />
    <SpriteRule Name="If bot bomber is selected" Sequence="176" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="6" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bot bomber" Sequence="178" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotBomber)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="Set collision power source energy to 200" Sequence="168" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Energy&quot;" Parameter2="200" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop water bomber" Sequence="181" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotBomber)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="If splash power source is selected" Sequence="170" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="5" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop splash power source" Sequence="172" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotEnergySource)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created splash power source" Sequence="173" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set splash power source energy to 200" Sequence="174" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Energy&quot;" Parameter2="200" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to splash power source" Sequence="175" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotEnergySource.State.OnSplash" EndIf="true" Suspended="false" />
    <SpriteRule Name="If bot water bomber is selected" Sequence="179" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="7" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select new water bomber" Sequence="182" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to water bomber" Sequence="183" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotBomber.State.Water" EndIf="true" Suspended="false" />
    <SpriteRule Name="If inventory button is not blocking jump or crouch action" Sequence="86" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Button2" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if inventory button not blocking jump and crouch" Sequence="101" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if inventory button not blocking non climbing moverment" Sequence="202" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If inventory button not blocking left or right" Sequence="204" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Button2" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if inventory button not blocking left or right" Sequence="221" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If inventory not blocking climbing movement keys" Sequence="75" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Button2" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If inventory not blocking non-climbing movement keys" Sequence="109" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Button2" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if pressing down" Sequence="120" Type="ElseIf" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Down" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And standing on top of climbable tile" Sequence="121" Type="And" Function="IsAgainstTile" Parameter1="TileCategoryName.Climbable" Parameter2="RelativePosition.BottomCenter" Parameter3="SpriteBase.Direction.Down" EndIf="false" Suspended="false" />
    <SpriteRule Name="And successfully switched to climbing state" Sequence="122" Type="And" Function="SwitchToState" Parameter1="(int)Sprites.Player.State.Climbing" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Fall down a bit" Sequence="123" Type="Do" Function="AlterYVelocity" Parameter1="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="And switch to climbing solidity" Sequence="124" Type="Do" Function="SetSolidity" Parameter1="Solidity.Climbing_solidity" EndIf="true" Suspended="false" />
    <SpriteRule Name="Take health" Sequence="37" Type="Do" Function="TileTake" Parameter1="56" Parameter2="Counter.Health" Parameter3="0" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If took health" Sequence="39" Type="If" Function="&gt;" Parameter1="TempNum" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Play ahh sound" Sequence="40" Type="Do" Function="Sounds.Play" Parameter1="&quot;ahh&quot;" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on health fountain" Sequence="47" Type="If" Function="IsOnTileValue" Parameter1="50" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="And one second has passed" Sequence="48" Type="And" Function="==" Parameter1="Counter.FrameCounter.CurrentValue % 60" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If healed" Sequence="49" Type="If" Function="!ChangeCounter" Parameter1="Counter.Health" Parameter2="CounterOperation.IncrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Play Ahh sound for health fountain" Sequence="50" Type="Do" Function="Sounds.Play" Parameter1="&quot;ahh&quot;" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if on health fountain" Sequence="51" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If cannot return to previous map" Sequence="241" Type="If" Function="!CanReturnToPreviousMap" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset health" Sequence="242" Type="Do" Function="ChangeCounter" Parameter1="Counter.Health" Parameter2="CounterOperation.SetToMaximum" EndIf="true" Suspended="false" />
    <SpriteRule Name="Take bomb" Sequence="41" Type="Do" Function="TileTake" Parameter1="77" Parameter2="Counter.Bombs" Parameter3="0" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If took bomb" Sequence="42" Type="If" Function="&gt;" Parameter1="TempNum" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Play pickup sound for bomb" Sequence="43" Type="Do" Function="Sounds.Play" Parameter1="&quot;pickup&quot;" EndIf="true" Suspended="false" />
    <SpriteRule Name="And player had and used bomb" Sequence="130" Type="And" Function="!ChangeCounter" Parameter1="Counter.Bombs" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player had and used bot energy source" Sequence="133" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotEnergySources" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Take throwable torch" Sequence="44" Type="Do" Function="TileTake" Parameter1="78" Parameter2="Counter.ThrowableTorches" Parameter3="0" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If took throwable torch" Sequence="45" Type="If" Function="&gt;" Parameter1="TempNum" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Play pickup sound" Sequence="46" Type="Do" Function="Sounds.Play" Parameter1="&quot;pickup&quot;" EndIf="true" Suspended="false" />
    <SpriteRule Name="If throwable torch is selected" Sequence="184" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="8" EndIf="false" Suspended="false" />
    <SpriteRule Name="If walking rightward" Sequence="186" Type="If" Function="IsInState" Parameter1="(int)Sprites.Player.State.Right" Parameter2="(int)Sprites.Player.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or crouching rightward" Sequence="187" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Player.State.Crouch_right" Parameter2="(int)Sprites.Player.State.Crouch_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or falling right" Sequence="188" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Player.State.Falling_right" Parameter2="(int)Sprites.Player.State.Falling_right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add throwable torch sprite on right" Sequence="189" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.ThrownTorch)" Parameter2="RelativePosition.TopRight" Parameter3="RelativePosition.TopRight" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select right torch sprite" Sequence="190" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Throw torch to the right" Sequence="191" Type="Do" Function="SetTargetParameter" Parameter1="&quot;dx&quot;" Parameter2="6" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch torch to rightward state" Sequence="192" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else add throwable torch sprite on left" Sequence="193" Type="Else" Function="AddSpriteHere" Parameter1="typeof(Sprites.ThrownTorch)" Parameter2="RelativePosition.TopLeft" Parameter3="RelativePosition.TopLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="Throw torch upward too" Sequence="198" Type="Do" Function="SetTargetParameter" Parameter1="&quot;dy&quot;" Parameter2="-5" EndIf="true" Suspended="false" />
    <SpriteRule Name="Set torch burn time" Sequence="196" Type="Do" Function="SetTargetParameter" Parameter1="&quot;BurnTime&quot;" Parameter2="360" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player had and used throwable torch" Sequence="185" Type="And" Function="!ChangeCounter" Parameter1="Counter.ThrowableTorches" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Tell torch to ignite" Sequence="197" Type="Do" Function="SetTargetParameter" Parameter1="&quot;NeedIgnite&quot;" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Throw torch to the left" Sequence="195" Type="Do" Function="SetTargetParameter" Parameter1="&quot;dx&quot;" Parameter2="-6" EndIf="true" Suspended="false" />
    <SpriteRule Name="Select left torch sprite" Sequence="194" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if pressing select button on save tile" Sequence="200" Type="ElseIf" Function="IsOnTileValue" Parameter1="85" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Go to save/load game map" Sequence="201" Type="Do" Function="SwitchToMap" Parameter1="typeof(SaveOrLoadGame_Map)" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="Or global action is hurt player" Sequence="237" Type="Or" Function="==" Parameter1="Counter.GlobalAction.CurrentValue" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset global action" Sequence="239" Type="Do" Function="ChangeCounter" Parameter1="Counter.GlobalAction" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If pressing menu button" Sequence="232" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Button4" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Go to menu" Sequence="233" Type="Do" Function="SwitchToMap" Parameter1="typeof(Menu_Map)" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="If touched checkpoint tile" Sequence="68" Type="If" Function="TileCategoryTouched" Parameter1="TileCategoryName.Checkpoint" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Checkpoint save" Sequence="69" Type="Do" Function="SaveGame" Parameter1="3" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on biohazard" Sequence="52" Type="If" Function="IsOnTileValue" Parameter1="66" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove energy source bots from inventory" Sequence="62" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotEnergySources" Parameter2="CounterOperation.SetToMinimum" EndIf="true" Suspended="false" />
    <SpriteRule Name="And player has bot droplets" Sequence="180" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotDroplets" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses bot follower" Sequence="140" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotFollowers" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses collision power source" Sequence="165" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotCollisionPowers" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses splash power source" Sequence="171" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotSplashPowers" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses bot bomber" Sequence="177" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotBombs" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove droplet bots from inventory" Sequence="61" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotDroplets" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove bombs from inventory" Sequence="60" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotBombs" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove collision power sources from inventory" Sequence="59" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotCollisionPowers" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove splash power sources from inventory" Sequence="58" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotSplashPowers" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove followers from inventory" Sequence="57" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotFollowers" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove move lefts from inventory" Sequence="53" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveLefts" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove move downs from inventory" Sequence="56" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveDowns" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove move ups from inventory" Sequence="55" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveUps" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove move rights from inventory" Sequence="54" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveRights" Parameter2="CounterOperation.SetToMinimum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If Bot Mover (up) is selected" Sequence="144" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="9" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses bot move up" Sequence="145" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotMoveUps" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bot move up" Sequence="146" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotMover)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created bot move up" Sequence="147" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to up" Sequence="148" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotMover.State.Up" EndIf="true" Suspended="false" />
    <SpriteRule Name="If Bot Mover (left) is selected" Sequence="159" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="12" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses bot move left" Sequence="160" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotMoveLefts" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bot move left" Sequence="161" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotMover)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created bot move left" Sequence="162" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to left" Sequence="163" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotMover.State.Left" EndIf="true" Suspended="false" />
    <SpriteRule Name="If Bot Mover (down) is selected" Sequence="154" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="11" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses bot move down" Sequence="155" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotMoveDowns" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bot move down" Sequence="156" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotMover)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created bot move down" Sequence="157" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to down" Sequence="158" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotMover.State.Down" EndIf="true" Suspended="false" />
    <SpriteRule Name="If Bot Mover (right) is selected" Sequence="149" Type="If" Function="==" Parameter1="Counter.SelectedInventory.CurrentValue" Parameter2="10" EndIf="false" Suspended="false" />
    <SpriteRule Name="And player uses bot move right" Sequence="150" Type="And" Function="!ChangeCounter" Parameter1="Counter.BotMoveRights" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bot move right" Sequence="151" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotMover)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created bot move right" Sequence="152" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set state to right" Sequence="153" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.BotMover.State.Right" EndIf="true" Suspended="false" />
    <SpriteRule Name="Pay toll gate" Sequence="38" Type="Do" Function="TileUseUp" Parameter1="89" Parameter2="Counter.Money" Parameter3="44" ResultParameter="" EndIf="false" Suspended="false" />
    <SpriteParameter Name="PlayerNum" />
    <SpriteParameter Name="InvincibleTimer" />
    <SpriteParameter Name="HurtFlag" />
    <SpriteParameter Name="TouchedEnemy" />
    <SpriteParameter Name="TempNum" />
    <SpriteParameter Name="TouchIndex" />
    <SpriteState Name="Right" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="30" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="8" MaskAlphaLevel="130" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="8" MaskAlphaLevel="130" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="8" MaskAlphaLevel="130" />
      <SpriteFrame Sequence="3" FrameValue="3" Duration="8" MaskAlphaLevel="130" />
    </SpriteState>
    <SpriteState Name="Left" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="30" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="4" Duration="8" MaskAlphaLevel="130" />
      <SpriteFrame Sequence="1" FrameValue="5" Duration="8" MaskAlphaLevel="130" />
      <SpriteFrame Sequence="2" FrameValue="6" Duration="8" MaskAlphaLevel="130" />
      <SpriteFrame Sequence="3" FrameValue="7" Duration="8" MaskAlphaLevel="130" />
    </SpriteState>
    <SpriteState Name="Climbing" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="30" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="8" Duration="8" MaskAlphaLevel="11" />
      <SpriteFrame Sequence="1" FrameValue="9" Duration="8" MaskAlphaLevel="11" />
      <SpriteFrame Sequence="2" FrameValue="10" Duration="8" MaskAlphaLevel="11" />
      <SpriteFrame Sequence="3" FrameValue="11" Duration="8" MaskAlphaLevel="11" />
      <SpriteFrame Sequence="4" FrameValue="10" Duration="8" MaskAlphaLevel="11" />
      <SpriteFrame Sequence="5" FrameValue="9" Duration="8" MaskAlphaLevel="11" />
    </SpriteState>
    <SpriteState Name="Crouch right" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="16" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="12" Duration="8" MaskAlphaLevel="7" />
      <SpriteFrame Sequence="1" FrameValue="13" Duration="8" MaskAlphaLevel="7" />
      <SpriteFrame Sequence="2" FrameValue="14" Duration="8" MaskAlphaLevel="7" />
      <SpriteFrame Sequence="3" FrameValue="13" Duration="8" MaskAlphaLevel="7" />
    </SpriteState>
    <SpriteState Name="Crouch left" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="16" Sequence="5">
      <SpriteFrame Sequence="0" FrameValue="15" Duration="8" MaskAlphaLevel="6" />
      <SpriteFrame Sequence="1" FrameValue="16" Duration="8" MaskAlphaLevel="6" />
      <SpriteFrame Sequence="2" FrameValue="17" Duration="8" MaskAlphaLevel="6" />
      <SpriteFrame Sequence="3" FrameValue="16" Duration="8" MaskAlphaLevel="6" />
    </SpriteState>
    <SpriteState Name="Falling right" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="30" Sequence="6">
      <SpriteFrame Sequence="0" FrameValue="18" Duration="1" MaskAlphaLevel="11" />
    </SpriteState>
    <SpriteState Name="Falling left" FramesetName="PlayerFrames" SolidWidth="24" SolidHeight="30" Sequence="7">
      <SpriteFrame Sequence="0" FrameValue="19" Duration="1" MaskAlphaLevel="17" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Explosion">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Animate" Sequence="4" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If looped back to start" Sequence="23" Type="If" Function="&gt;=" Parameter1="frame" Parameter2="29" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="24" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If ready to propogate" Sequence="5" Type="If" Function="==" Parameter1="this.frame" Parameter2="20" EndIf="false" Suspended="false" />
    <SpriteRule Name="Check for ignitable" Sequence="6" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.Ignitable" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select explosive" Sequence="7" Type="Do" Function="TileTouchingIndex" Parameter1="27" Parameter2="false" Parameter3="true" ResultParameter="ExplodeIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Explode" Sequence="9" Type="Do" Function="TileAddSprite" Parameter1="ExplodeIndex" Parameter2="typeof(Sprites.Explosion)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove explosives" Sequence="20" Type="Do" Function="TileChange" Parameter1="27" Parameter2="0" Parameter3="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="While explosives remain" Sequence="8" Type="While" Function="&gt;=" Parameter1="ExplodeIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select next explosive" Sequence="10" Type="Do" Function="TileTouchingIndex" Parameter1="27" Parameter2="false" Parameter3="true" ResultParameter="ExplodeIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="Check for ignitables again to reset processed flag" Sequence="19" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.Ignitable" EndIf="false" Suspended="false" />
    <SpriteRule Name="While wood piles remain" Sequence="12" Type="While" Function="&gt;=" Parameter1="ExplodeIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Ignite wood pile" Sequence="13" Type="Do" Function="TileAddSprite" Parameter1="ExplodeIndex" Parameter2="typeof(Sprites.Igniter)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select next wood pile" Sequence="14" Type="Do" Function="TileTouchingIndex" Parameter1="28" Parameter2="false" Parameter3="true" ResultParameter="ExplodeIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="Select wood pile" Sequence="11" Type="Do" Function="TileTouchingIndex" Parameter1="28" Parameter2="false" Parameter3="true" ResultParameter="ExplodeIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="While torches remain" Sequence="16" Type="While" Function="&gt;=" Parameter1="ExplodeIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Ignite torch" Sequence="17" Type="Do" Function="TileAddSprite" Parameter1="ExplodeIndex" Parameter2="typeof(Sprites.Igniter)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select next torch" Sequence="18" Type="Do" Function="TileTouchingIndex" Parameter1="30" Parameter2="false" Parameter3="true" ResultParameter="ExplodeIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="Select torch" Sequence="15" Type="Do" Function="TileTouchingIndex" Parameter1="30" Parameter2="false" Parameter3="true" ResultParameter="ExplodeIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace wood piles with igniting wood piles" Sequence="21" Type="Do" Function="TileChange" Parameter1="28" Parameter2="32" Parameter3="false" ResultParameter="" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace torches with igniting torches" Sequence="22" Type="Do" Function="TileChange" Parameter1="30" Parameter2="33" Parameter3="false" ResultParameter="" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on first frame" Sequence="1" Type="If" Function="==" Parameter1="frame" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Play explosion sound" Sequence="3" Type="Do" Function="Sounds.Play" Parameter1="&quot;explode&quot;" EndIf="true" Suspended="false" />
    <SpriteRule Name="And is visible" Sequence="2" Type="And" Function="IsVisible" EndIf="false" Suspended="false" />
    <SpriteParameter Name="ExplodeIndex" />
    <SpriteState Name="Main" FramesetName="Explosion" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="4" MaskAlphaLevel="29" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="4" MaskAlphaLevel="29" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="4" MaskAlphaLevel="29" />
      <SpriteFrame Sequence="3" FrameValue="3" Duration="4" MaskAlphaLevel="29" />
      <SpriteFrame Sequence="4" FrameValue="4" Duration="4" MaskAlphaLevel="29" />
      <SpriteFrame Sequence="5" FrameValue="5" Duration="4" MaskAlphaLevel="29" />
      <SpriteFrame Sequence="6" FrameValue="6" Duration="4" MaskAlphaLevel="29" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Bomb">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Animate" Sequence="5" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If looped to start" Sequence="10" Type="If" Function="&gt;=" Parameter1="frame" Parameter2="216" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="12" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="Explode" Sequence="11" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Explosion)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Gravity" Sequence="1" Type="Do" Function="+" Parameter1="dy" Parameter2=".3" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Inertia" Sequence="2" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="95" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="3" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="4" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="6" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="7" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="8" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="9" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteState Name="Main" FramesetName="BombFrames" SolidWidth="20" SolidHeight="16" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="0" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="0" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="1" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="0" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="1" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="2" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="3" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="2" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="3" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="2" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="3" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="2" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="3" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="4" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="5" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="4" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="5" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="20" FrameValue="4" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="21" FrameValue="5" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="22" FrameValue="4" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="23" FrameValue="5" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="24" FrameValue="6" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="25" FrameValue="7" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="26" FrameValue="6" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="27" FrameValue="7" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="28" FrameValue="6" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="29" FrameValue="7" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="30" FrameValue="6" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="31" FrameValue="7" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="32" FrameValue="8" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="33" FrameValue="9" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="34" FrameValue="8" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="35" FrameValue="9" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="36" FrameValue="8" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="37" FrameValue="9" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="38" FrameValue="8" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="39" FrameValue="9" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="40" FrameValue="10" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="41" FrameValue="11" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="42" FrameValue="10" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="43" FrameValue="11" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="44" FrameValue="10" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="45" FrameValue="11" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="46" FrameValue="10" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="47" FrameValue="11" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="48" FrameValue="12" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="49" FrameValue="13" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="50" FrameValue="12" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="51" FrameValue="13" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="52" FrameValue="12" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="53" FrameValue="13" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="54" FrameValue="12" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="55" FrameValue="13" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="56" FrameValue="14" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="57" FrameValue="15" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="58" FrameValue="14" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="59" FrameValue="15" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="60" FrameValue="14" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="61" FrameValue="15" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="62" FrameValue="14" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="63" FrameValue="15" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="64" FrameValue="16" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="65" FrameValue="17" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="66" FrameValue="16" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="67" FrameValue="17" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="68" FrameValue="16" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="69" FrameValue="17" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="70" FrameValue="16" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="71" FrameValue="17" Duration="3" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Worm">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="If facing left" Sequence="4" Type="If" Function="IsInState" Parameter1="(int)Sprites.Worm.State.Left" Parameter2="(int)Sprites.Worm.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else move left" Sequence="10" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else move right" Sequence="13" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="Accelerate" Sequence="15" Type="Do" Function="AccelerateByInputs" Parameter1="10" Parameter2="1" Parameter3="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If blocked left" Sequence="5" Type="If" Function="Blocked" Parameter1="SpriteBase.Direction.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else face right" Sequence="9" Type="Else" Function="SwitchToState" Parameter1="(int)Sprites.Worm.State.Right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else if blocked right" Sequence="11" Type="ElseIf" Function="Blocked" Parameter1="SpriteBase.Direction.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Face left" Sequence="12" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Worm.State.Left" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="End facing" Sequence="14" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="16" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="17" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="18" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByHorizontalVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Gravity" Sequence="1" Type="Do" Function="+" Parameter1="dy" Parameter2=".3" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Inertia" Sequence="2" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="95" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="19" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="20" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move by velocity" Sequence="23" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="21" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Snap to ground" Sequence="22" Type="Do" Function="SnapToGround" Parameter1="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Un-set inputs" Sequence="3" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right|SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test collision with explosion" Sequence="24" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Igniters" ResultParameter="collideIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If collided" Sequence="25" Type="If" Function="&gt;=" Parameter1="collideIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="26" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If hit dirt (left)" Sequence="6" Type="If" Function="IsAgainstTile" Parameter1="TileCategoryName.WormDiggable" Parameter2="RelativePosition.LeftMiddle" Parameter3="SpriteBase.Direction.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Touch tiles (left)" Sequence="7" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.WormDiggable" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace dirt with passable dirt (left)" Sequence="8" Type="Do" Function="TileChange" Parameter1="9" Parameter2="88" Parameter3="true" ResultParameter="" EndIf="false" Suspended="false" />
    <SpriteParameter Name="collideIndex" />
    <SpriteState Name="Left" FramesetName="Worm" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="6" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Right" FramesetName="Worm" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="3" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="4" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="5" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="4" Duration="6" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Bombot">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Gravity" Sequence="29" Type="Do" Function="AlterYVelocity" Parameter1=".3" EndIf="false" Suspended="false" />
    <SpriteRule Name="Inertia" Sequence="30" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="95" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="31" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="32" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="33" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByHorizontalVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="34" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="35" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="36" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="37" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Accelerate" Sequence="28" Type="Do" Function="AccelerateByInputs" Parameter1="5" Parameter2="2" Parameter3="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If current behavior is moving" Sequence="2" Type="If" Function="&lt;" Parameter1="BehaviorTimer" Parameter2="MoveTime" EndIf="false" Suspended="false" />
    <SpriteRule Name="If state is facing right" Sequence="3" Type="If" Function="IsInState" Parameter1="(int)Sprites.Bombot.State.Right" Parameter2="(int)Sprites.Bombot.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Press right" Sequence="7" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else press left" Sequence="11" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="If blocked on right" Sequence="4" Type="If" Function="Blocked" Parameter1="SpriteBase.Direction.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn to left" Sequence="5" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Bombot.State.Left" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if blocked on left" Sequence="8" Type="ElseIf" Function="Blocked" Parameter1="SpriteBase.Direction.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn to right" Sequence="9" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Bombot.State.Right" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if facing right or left" Sequence="12" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If done waiting before bomb" Sequence="15" Type="If" Function="==" Parameter1="BehaviorTimer" Parameter2="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Increment behavior timer" Sequence="1" Type="Do" Function="+" Parameter1="BehaviorTimer" Parameter2="1" ResultParameter="BehaviorTimer" EndIf="false" Suspended="false" />
    <SpriteRule Name="Create bomb" Sequence="16" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Bomb)" Parameter2="RelativePosition.TopCenter" Parameter3="RelativePosition.TopCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select bomb sprite" Sequence="17" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Throw bomb upward" Sequence="18" Type="Do" Function="SetTargetParameter" Parameter1="&quot;dy&quot;" Parameter2="-4" EndIf="false" Suspended="false" />
    <SpriteRule Name="If bombing leftward" Sequence="19" Type="If" Function="IsInState" Parameter1="(int)Sprites.Bombot.State.Left" Parameter2="(int)Sprites.Bombot.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Throw bomb leftward" Sequence="20" Type="Do" Function="SetTargetParameter" Parameter1="&quot;dx&quot;" Parameter2="-4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else throw bomb rightward" Sequence="21" Type="Else" Function="SetTargetParameter" Parameter1="&quot;dx&quot;" Parameter2="4" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else calculate wait after 1" Sequence="22" Type="Else" Function="+" Parameter1="MoveTime" Parameter2="WaitBefore" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset behavior counter for moving" Sequence="25" Type="Do" Function="=" Parameter1="0" ResultParameter="BehaviorTimer" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if waiting behavior" Sequence="26" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if moving behavior" Sequence="27" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else un-press inputs" Sequence="13" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right|SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Un-press right" Sequence="6" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Un-press left" Sequence="10" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test collision with water" Sequence="38" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Water" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If touched water" Sequence="39" Type="If" Function="&gt;=" Parameter1="TempNum" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Explode" Sequence="40" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Explosion)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="41" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="Calculate wait time" Sequence="14" Type="Do" Function="+" Parameter1="MoveTime" Parameter2="WaitBefore" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Calculate wait after 2" Sequence="23" Type="Do" Function="+" Parameter1="TempNum" Parameter2="WaitAfter" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If done waiting after bomb" Sequence="24" Type="If" Function="==" Parameter1="BehaviorTimer" Parameter2="TempNum" EndIf="false" Suspended="false" />
    <SpriteParameter Name="BehaviorTimer" />
    <SpriteParameter Name="MoveTime" />
    <SpriteParameter Name="WaitBefore" />
    <SpriteParameter Name="WaitAfter" />
    <SpriteParameter Name="TempNum" />
    <SpriteState Name="Right" FramesetName="Bombot" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="4" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="4" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="4" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Left" FramesetName="Bombot" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="3" Duration="4" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="4" Duration="4" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="5" Duration="4" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Igniter">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Animate" Sequence="1" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If looped back to start" Sequence="36" Type="If" Function="&gt;=" Parameter1="frame" Parameter2="50" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="42" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If time to propogate" Sequence="13" Type="If" Function="==" Parameter1="this.frame % 50" Parameter2="32" EndIf="false" Suspended="false" />
    <SpriteRule Name="Find ignitable tiles" Sequence="14" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.Ignitable" EndIf="false" Suspended="false" />
    <SpriteRule Name="While wood pile tile found" Sequence="16" Type="While" Function="&gt;=" Parameter1="TouchIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Find wood pile tile" Sequence="15" Type="Do" Function="TileTouchingIndex" Parameter1="28" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Ignite neighboring woodpile" Sequence="17" Type="Do" Function="TileAddSprite" Parameter1="TouchIndex" Parameter2="typeof(Sprites.Igniter)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Find next wood pile tile" Sequence="18" Type="Do" Function="TileTouchingIndex" Parameter1="28" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="While torch tile found" Sequence="20" Type="While" Function="&gt;=" Parameter1="TouchIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Ignite neighboring torch" Sequence="21" Type="Do" Function="TileAddSprite" Parameter1="TouchIndex" Parameter2="typeof(Sprites.Igniter)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Find next torch tile" Sequence="22" Type="Do" Function="TileTouchingIndex" Parameter1="30" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="Find torch tile" Sequence="19" Type="Do" Function="TileTouchingIndex" Parameter1="30" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace wood piles with igniting wood piles" Sequence="33" Type="Do" Function="TileChange" Parameter1="28" Parameter2="32" Parameter3="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace torches with igniting torches" Sequence="35" Type="Do" Function="TileChange" Parameter1="30" Parameter2="33" Parameter3="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="Find ignitable tiles for replacing" Sequence="31" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.Ignitable" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace igniting wood pile with buring wood pile" Sequence="40" Type="Do" Function="TileChange" Parameter1="32" Parameter2="29" Parameter3="false" ResultParameter="" EndIf="false" Suspended="false" />
    <SpriteRule Name="Find igniting tiles" Sequence="39" Type="Do" Function="TouchTiles" Parameter1="TileCategoryName.Igniting" EndIf="false" Suspended="false" />
    <SpriteRule Name="Replace igniting torch with burning torch" Sequence="41" Type="Do" Function="TileChange" Parameter1="33" Parameter2="31" Parameter3="false" ResultParameter="" EndIf="false" Suspended="false" />
    <SpriteRule Name="While explosives remain" Sequence="24" Type="While" Function="&gt;=" Parameter1="TouchIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Explode" Sequence="25" Type="Do" Function="TileAddSprite" Parameter1="TouchIndex" Parameter2="typeof(Sprites.Explosion)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select next explosive" Sequence="26" Type="Do" Function="TileTouchingIndex" Parameter1="27" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="Select explosive" Sequence="23" Type="Do" Function="TileTouchingIndex" Parameter1="27" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove explosives" Sequence="32" Type="Do" Function="TileChange" Parameter1="27" Parameter2="0" Parameter3="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select ice" Sequence="27" Type="Do" Function="TileTouchingIndex" Parameter1="57" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="While ice remains" Sequence="28" Type="While" Function="&gt;=" Parameter1="TouchIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Melt" Sequence="29" Type="Do" Function="TileAddSprite" Parameter1="TouchIndex" Parameter2="typeof(Sprites.Droplet)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select next ice" Sequence="30" Type="Do" Function="TileTouchingIndex" Parameter1="57" Parameter2="false" Parameter3="true" ResultParameter="TouchIndex" EndIf="true" Suspended="false" />
    <SpriteRule Name="Remove ice" Sequence="34" Type="Do" Function="TileChange" Parameter1="57" Parameter2="0" Parameter3="false" ResultParameter="" EndIf="false" Suspended="false" />
    <SpriteRule Name="If become fire" Sequence="2" Type="If" Function="&gt;" Parameter1="BecomeFire" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Attach to nearest thrown torch" Sequence="4" Type="Do" Function="AttachToNearest" Parameter1="ParentLayer.m_SpriteCategories.ThrownTorch" EndIf="true" Suspended="false" />
    <SpriteRule Name="If not attached" Sequence="3" Type="If" Function="!IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stick to attached torch" Sequence="9" Type="Do" Function="StickToAttached" Parameter1="RelativePosition.TopLeft" Parameter2="RelativePosition.TopLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="If become fire left" Sequence="5" Type="If" Function="==" Parameter1="BecomeFire" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to left fire" Sequence="6" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Igniter.State.FireLeft" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If become fire right" Sequence="7" Type="If" Function="==" Parameter1="BecomeFire" Parameter2="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to right fire" Sequence="8" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Igniter.State.FireRight" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="And is igniter only" Sequence="38" Type="And" Function="IsInState" Parameter1="(int)Sprites.Igniter.State.Ignite" Parameter2="(int)Sprites.Igniter.State.Ignite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate because torch is gone" Sequence="11" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If not still attached" Sequence="10" Type="If" Function="!IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if become fire" Sequence="12" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="And is still active" Sequence="37" Type="And" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteParameter Name="TouchIndex" />
    <SpriteParameter Name="BecomeFire" />
    <SpriteState Name="Ignite" FramesetName="IgniterFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="20" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="3" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="4" Duration="6" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="3" Duration="6" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="FireLeft" FramesetName="ThrownTorchFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="2" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="3" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="4" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="5" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="FireRight" FramesetName="ThrownTorchFrames" SolidWidth="32" SolidHeight="32" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="6" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="7" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="8" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="9" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Platform">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="React to solidity" Sequence="2" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="3" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit Speed" Sequence="1" Type="Do" Function="LimitVelocity" Parameter1="3" EndIf="false" Suspended="false" />
    <SpriteParameter Name="CoordIndex" />
    <SpriteParameter Name="WaitTime" />
    <SpriteState Name="Main" FramesetName="Platform" SolidWidth="64" SolidHeight="2" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Sprout">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="And growing up" Sequence="20" Type="And" Function="IsInState" Parameter1="(int)Sprites.Sprout.State.Up" Parameter2="(int)Sprites.Sprout.State.Up" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="1" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If growth segment has finished (time to branch)" Sequence="34" Type="If" Function="&lt;=" Parameter1="LengthTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If temporary length is not initialized" Sequence="25" Type="If" Function="&lt;" Parameter1="LengthTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else read temporary length from structure" Sequence="29" Type="Else" Function="=" Parameter1="this.structureTemp % 10" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Get left branch length" Sequence="36" Type="Do" Function="=" Parameter1="this.structureTemp % 10" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove length from temporary structure" Sequence="30" Type="Do" Function="RemoveDigit" Parameter1="structureTemp" ResultParameter="structureTemp" EndIf="true" Suspended="false" />
    <SpriteRule Name="Remove left branch length from structure" Sequence="37" Type="Do" Function="RemoveDigit" Parameter1="structureTemp" ResultParameter="structureTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Spawn left branch" Sequence="39" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Sprout)" Parameter2="RelativePosition.LeftMiddle" Parameter3="RelativePosition.RightMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select left sprout" Sequence="40" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set left branch length" Sequence="41" Type="Do" Function="SetTargetParameter" Parameter1="&quot;LengthTemp&quot;" Parameter2="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set left branch state" Sequence="45" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.Sprout.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set stalk to branch left" Sequence="46" Type="Do" Function="TileSetValue" Parameter1="37" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If left branch exists" Sequence="38" Type="If" Function="&gt;" Parameter1="LengthTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Get right branch length" Sequence="47" Type="Do" Function="=" Parameter1="this.structureTemp % 10" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove right branch length from structure" Sequence="48" Type="Do" Function="RemoveDigit" Parameter1="structureTemp" ResultParameter="structureTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="If right branch exists" Sequence="49" Type="If" Function="&gt;" Parameter1="LengthTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Spawn right branch" Sequence="50" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Sprout)" Parameter2="RelativePosition.RightMiddle" Parameter3="RelativePosition.LeftMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select right sprout" Sequence="51" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set right branch length" Sequence="52" Type="Do" Function="SetTargetParameter" Parameter1="&quot;LengthTemp&quot;" Parameter2="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set right branch state" Sequence="56" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.Sprout.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="If branched left" Sequence="57" Type="If" Function="IsOnTileValue" Parameter1="37" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set stalk to branch both directions" Sequence="58" Type="Do" Function="TileSetValue" Parameter1="41" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else set stalk to branch right" Sequence="59" Type="Else" Function="TileSetValue" Parameter1="36" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="End branch right" Sequence="60" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Grow sprout upward" Sequence="65" Type="Do" Function="MoveOverTiles" Parameter1="SpriteBase.Direction.Up" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset temporary length" Sequence="61" Type="Do" Function="=" Parameter1="0" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="And growing left" Sequence="71" Type="And" Function="IsInState" Parameter1="(int)Sprites.Sprout.State.Left" Parameter2="(int)Sprites.Sprout.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set left branch tile" Sequence="75" Type="Else" Function="TileSetValue" Parameter1="39" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Persist stalk tile for growing up" Sequence="33" Type="Do" Function="TileSetValue" Parameter1="35" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="If structure is complete" Sequence="26" Type="If" Function="==" Parameter1="structureTemp" Parameter2="-1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Persist tile value" Sequence="27" Type="Do" Function="TileSetValue" Parameter1="34" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate upward sprout (while reading length)" Sequence="28" Type="Do" Function="Deactivate" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset growth frame" Sequence="66" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="End reading segment length" Sequence="31" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Reset frame for leftward growth" Sequence="77" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="Grow sprout leftward" Sequence="76" Type="Do" Function="MoveOverTiles" Parameter1="SpriteBase.Direction.Left" Parameter2="1" EndIf="true" Suspended="false" />
    <SpriteRule Name="If done growing left" Sequence="72" Type="If" Function="&lt;=" Parameter1="LengthTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Persist left tile" Sequence="73" Type="Do" Function="TileSetValue" Parameter1="40" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="And growing right" Sequence="79" Type="And" Function="IsInState" Parameter1="(int)Sprites.Sprout.State.Right" Parameter2="(int)Sprites.Sprout.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="If done growing right" Sequence="80" Type="If" Function="&lt;=" Parameter1="LengthTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Persist right tile" Sequence="81" Type="Do" Function="TileSetValue" Parameter1="38" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set right branch tile" Sequence="83" Type="Else" Function="TileSetValue" Parameter1="39" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Grow sprout rightward" Sequence="84" Type="Do" Function="MoveOverTiles" Parameter1="SpriteBase.Direction.Right" Parameter2="1" EndIf="true" Suspended="false" />
    <SpriteRule Name="Reset frame for rightward growth" Sequence="85" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="If (upward) sprout is active" Sequence="19" Type="If" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If (leftward) sprout is active" Sequence="70" Type="If" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If (rightward) sprout is active" Sequence="78" Type="If" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If sprout is still active for upward growth" Sequence="32" Type="If" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if active for upward growth" Sequence="69" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else (not seed) if finished animating current growth tile" Sequence="18" Type="ElseIf" Function="&gt;=" Parameter1="frame" Parameter2="90" EndIf="false" Suspended="false" />
    <SpriteRule Name="If remaining structure is empty" Sequence="67" Type="If" Function="==" Parameter1="structureTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Mark structure as completed" Sequence="68" Type="Do" Function="=" Parameter1="-1" ResultParameter="structureTemp" EndIf="true" Suspended="false" />
    <SpriteRule Name="If structure is not empty" Sequence="35" Type="If" Function="&gt;" Parameter1="structureTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If needs initialization" Sequence="21" Type="If" Function="==" Parameter1="structureTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Initialize Length" Sequence="22" Type="Do" Function="=" Parameter1="-1" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Initialize structure" Sequence="24" Type="Do" Function="=" Parameter1="Structure" ResultParameter="structureTemp" EndIf="true" Suspended="false" />
    <SpriteRule Name="Decrease remaining length" Sequence="97" Type="Do" Function="-" Parameter1="LengthTemp" Parameter2="1" ResultParameter="LengthTemp" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else (structure growth is done) set top tile" Sequence="62" Type="Else" Function="TileSetValue" Parameter1="34" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate upward sprout (during branching check)" Sequence="63" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if branching" Sequence="64" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Get left branch seed" Sequence="42" Type="Do" Function="=" Parameter1="this.seedsTemp % 10" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set left branch seed" Sequence="43" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Seeds&quot;" Parameter2="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove left seed from queue" Sequence="44" Type="Do" Function="RemoveDigit" Parameter1="seedsTemp" ResultParameter="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Initialize Seeds" Sequence="23" Type="Do" Function="=" Parameter1="Seeds" ResultParameter="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Get right branch seed" Sequence="53" Type="Do" Function="=" Parameter1="this.seedsTemp % 10" ResultParameter="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set right branch seed" Sequence="54" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Seeds&quot;" Parameter2="LengthTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remove right seed from queue" Sequence="55" Type="Do" Function="RemoveDigit" Parameter1="seedsTemp" ResultParameter="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Mark sprite to check for left branch seeds and deactivate" Sequence="74" Type="Do" Function="=" Parameter1="-1" ResultParameter="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Mark sprite to check for right branch seeds and deactivate" Sequence="82" Type="Do" Function="=" Parameter1="-1" ResultParameter="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="If time to seed and deactivate" Sequence="86" Type="If" Function="==" Parameter1="seedsTemp" Parameter2="-1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If branch contains first seed" Sequence="87" Type="If" Function="==" Parameter1="Seeds" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Spawn first seed" Sequence="88" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Sprout)" Parameter2="RelativePosition.RightMiddle" Parameter3="RelativePosition.LeftMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate branch after seeding" Sequence="96" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If branch contains second seed" Sequence="92" Type="If" Function="==" Parameter1="Seeds" Parameter2="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Spawn second seed" Sequence="93" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Bomb)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If seed" Sequence="2" Type="If" Function="IsInState" Parameter1="(int)Sprites.Sprout.State.Seed" Parameter2="(int)Sprites.Sprout.State.Seed" EndIf="false" Suspended="false" />
    <SpriteRule Name="Check if watered" Sequence="11" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Water" ResultParameter="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="If watered" Sequence="12" Type="If" Function="&gt;=" Parameter1="seedsTemp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to sprout" Sequence="13" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Sprout.State.Up" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset frame" Sequence="17" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if seed" Sequence="101" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Select water" Sequence="15" Type="Do" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.Water" Parameter2="seedsTemp" EndIf="false" Suspended="false" />
    <SpriteRule Name="Tell water to finish" Sequence="16" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Watered&quot;" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="And on a non-growable tile" Sequence="99" Type="And" Function="!IsOnTileValue" Parameter1="0" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate due to hitting solid" Sequence="100" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If active" Sequence="98" Type="If" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to gravity" Sequence="3" Type="Do" Function="AlterYVelocity" Parameter1=".3" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to inertia" Sequence="4" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="95" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="5" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="6" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="7" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="8" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="9" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="10" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created seed" Sequence="89" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set seed state" Sequence="90" Type="Do" Function="SetTargetParameter" Parameter1="&quot;state&quot;" Parameter2="(int)Sprites.Sprout.State.Seed" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set structure" Sequence="91" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Structure&quot;" Parameter2="559" EndIf="true" Suspended="false" />
    <SpriteRule Name="Snap to tile horizontally" Sequence="14" Type="Do" Function="SnapToTile" EndIf="false" Suspended="false" />
    <SpriteRule Name="If branch contains third seed" Sequence="94" Type="If" Function="==" Parameter1="Seeds" Parameter2="3" EndIf="false" Suspended="false" />
    <SpriteRule Name="Spawn third seed" Sequence="95" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Worm)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteParameter Name="Structure" />
    <SpriteParameter Name="structureTemp" />
    <SpriteParameter Name="LengthTemp" />
    <SpriteParameter Name="Seeds" />
    <SpriteParameter Name="seedsTemp" />
    <SpriteState Name="Up" FramesetName="MainFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="69" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="70" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="71" Duration="30" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Right" FramesetName="MainFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="75" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="76" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="77" Duration="30" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Left" FramesetName="MainFrames" SolidWidth="32" SolidHeight="32" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="79" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="80" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="81" Duration="30" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Seed" FramesetName="SeedFrames" SolidWidth="32" SolidHeight="32" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="4" MaskAlphaLevel="62" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="4" MaskAlphaLevel="116" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="4" MaskAlphaLevel="116" />
      <SpriteFrame Sequence="3" FrameValue="3" Duration="4" MaskAlphaLevel="116" />
      <SpriteFrame Sequence="4" FrameValue="4" Duration="4" MaskAlphaLevel="116" />
      <SpriteFrame Sequence="7" FrameValue="1" Duration="4" MaskAlphaLevel="116" />
      <SpriteFrame Sequence="6" FrameValue="2" Duration="4" MaskAlphaLevel="116" />
      <SpriteFrame Sequence="5" FrameValue="3" Duration="4" MaskAlphaLevel="116" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Package">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Gravity" Sequence="1" Type="Do" Function="+" Parameter1="dy" Parameter2=".3" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Inertia" Sequence="2" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="50" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="3" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="4" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="8" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="10" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to pushers" Sequence="5" Type="Do" Function="ReactToPush" Parameter1="ParentLayer.m_SpriteCategories.Pusher" EndIf="false" Suspended="false" />
    <SpriteRule Name="Snap to ground" Sequence="9" Type="Do" Function="SnapToGround" Parameter1="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to pushback" Sequence="6" Type="Do" Function="ReactToPushback" Parameter1="ParentLayer.m_SpriteCategories.Pushback" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit Velocity" Sequence="7" Type="Do" Function="LimitVelocity" Parameter1="6" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test for explosion" Sequence="11" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Igniters" ResultParameter="temp" EndIf="false" Suspended="false" />
    <SpriteRule Name="If exploded" Sequence="12" Type="If" Function="&gt;=" Parameter1="temp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Create crystalized bot" Sequence="13" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.CrystalizedBot)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="16" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="Set contents of crystal" Sequence="15" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Contents&quot;" Parameter2="Contents" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created sprite" Sequence="14" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteParameter Name="Contents" />
    <SpriteParameter Name="temp" />
    <SpriteState Name="Main" FramesetName="MainFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="83" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="WorldMapPlayer">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Animate" Sequence="24" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByVectorVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else read inputs" Sequence="7" Type="Else" Function="MapPlayerToInputs" Parameter1="PlayerNum" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to inputs" Sequence="8" Type="Do" Function="AccelerateByInputs" Parameter1="5" Parameter2="4" Parameter3="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stop horizontal movement" Sequence="2" Type="Do" Function="ReactToInertia" Parameter1="98" Parameter2="0" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to Solidity" Sequence="21" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="22" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="If pressing right" Sequence="9" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Right" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not facing right" Sequence="10" Type="And" Function="!IsInState" Parameter1="(int)Sprites.WorldMapPlayer.State.Right" Parameter2="(int)Sprites.WorldMapPlayer.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Face right" Sequence="11" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.WorldMapPlayer.State.Right" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressing down" Sequence="12" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Down" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not facing down" Sequence="13" Type="And" Function="!IsInState" Parameter1="(int)Sprites.WorldMapPlayer.State.Down" Parameter2="(int)Sprites.WorldMapPlayer.State.Down" EndIf="false" Suspended="false" />
    <SpriteRule Name="Face down" Sequence="14" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.WorldMapPlayer.State.Down" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressing left" Sequence="15" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not facing left" Sequence="16" Type="And" Function="!IsInState" Parameter1="(int)Sprites.WorldMapPlayer.State.Left" Parameter2="(int)Sprites.WorldMapPlayer.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Face left" Sequence="17" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.WorldMapPlayer.State.Left" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressing up" Sequence="18" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Up" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not facing up" Sequence="19" Type="And" Function="!IsInState" Parameter1="(int)Sprites.WorldMapPlayer.State.Up" Parameter2="(int)Sprites.WorldMapPlayer.State.Up" EndIf="false" Suspended="false" />
    <SpriteRule Name="Face up" Sequence="20" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.WorldMapPlayer.State.Up" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If health is zero" Sequence="25" Type="If" Function="==" Parameter1="Counter.Health.CurrentValue" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If decrease life count hits zero lives" Sequence="26" Type="If" Function="ChangeCounter" Parameter1="Counter.Life" Parameter2="CounterOperation.DecrementAndStop" EndIf="false" Suspended="false" />
    <SpriteRule Name="Die" Sequence="27" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.WorldMapPlayer.State.Dead" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else reset health" Sequence="28" Type="Else" Function="ChangeCounter" Parameter1="Counter.Health" Parameter2="CounterOperation.SetToMaximum" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if health is zero" Sequence="29" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If dead" Sequence="5" Type="If" Function="IsInState" Parameter1="(int)Sprites.WorldMapPlayer.State.Dead" Parameter2="(int)Sprites.WorldMapPlayer.State.Dead" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset inputs" Sequence="6" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Up|SpriteBase.InputBits.Right|SpriteBase.InputBits.Down|SpriteBase.InputBits.Left|SpriteBase.InputBits.Button1|SpriteBase.InputBits.Button2|SpriteBase.InputBits.Button3|SpriteBase.InputBits.Button4" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If not pressing horizontal direction" Sequence="1" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Right|SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If not pressing vertical direction" Sequence="3" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Up|SpriteBase.InputBits.Down" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stop vertical movement" Sequence="4" Type="Do" Function="ReactToInertia" Parameter1="0" Parameter2="98" EndIf="true" Suspended="false" />
    <SpriteRule Name="Scroll into view" Sequence="23" Type="Do" Function="ScrollSpriteIntoView" Parameter1="true" EndIf="false" Suspended="false" />
    <SpriteParameter Name="PlayerNum" />
    <SpriteState Name="Up" FramesetName="PlayerFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="20" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="21" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="22" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="21" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Right" FramesetName="PlayerFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="23" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="24" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="25" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="24" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Down" FramesetName="PlayerFrames" SolidWidth="32" SolidHeight="32" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="26" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="27" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="28" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="27" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Left" FramesetName="PlayerFrames" SolidWidth="32" SolidHeight="32" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="29" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="30" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="31" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="30" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Dead" FramesetName="PlayerFrames" SolidWidth="32" SolidHeight="32" Sequence="5">
      <SpriteFrame Sequence="0" FrameValue="32" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Droplet">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="React to gravity" Sequence="1" Type="Do" Function="AlterYVelocity" Parameter1="4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit velocity" Sequence="2" Type="Do" Function="LimitVelocity" Parameter1="8" EndIf="false" Suspended="false" />
    <SpriteRule Name="If hit solid" Sequence="9" Type="If" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate after hitting ground" Sequence="10" Type="Do" Function="Deactivate" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if watered target" Sequence="11" Type="ElseIf" Function="&gt;" Parameter1="Watered" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate after watering" Sequence="12" Type="Do" Function="Deactivate" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if hit solid" Sequence="14" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else move by velocity" Sequence="13" Type="Else" Function="MoveByVelocity" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on a camp fire" Sequence="3" Type="If" Function="IsOnTileValue" Parameter1="29" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Extinguish camp fire" Sequence="5" Type="Do" Function="TileSetValue" Parameter1="28" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on a torch fire" Sequence="6" Type="If" Function="IsOnTileValue" Parameter1="31" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Extinguish torch fire" Sequence="8" Type="Do" Function="TileSetValue" Parameter1="30" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Remember watered camp fire" Sequence="4" Type="Do" Function="=" Parameter1="1" ResultParameter="Watered" EndIf="false" Suspended="false" />
    <SpriteRule Name="Remember watered torch fire" Sequence="7" Type="Do" Function="=" Parameter1="1" ResultParameter="Watered" EndIf="false" Suspended="false" />
    <SpriteParameter Name="Watered" />
    <SpriteState Name="Falling" FramesetName="SeedFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="5" Duration="1" MaskAlphaLevel="51" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Rocket">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="If launched up" Sequence="12" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.UpLaunched" Parameter2="(int)Sprites.Rocket.State.UpLaunched" EndIf="false" Suspended="false" />
    <SpriteRule Name="Press up" Sequence="13" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Up" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="If launched left" Sequence="15" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.LeftLaunched" Parameter2="(int)Sprites.Rocket.State.LeftLaunched" EndIf="false" Suspended="false" />
    <SpriteRule Name="Press left" Sequence="16" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else un-press up" Sequence="14" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Up" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else un-press left" Sequence="17" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="If launched down" Sequence="18" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.DownLaunched" Parameter2="(int)Sprites.Rocket.State.DownLaunched" EndIf="false" Suspended="false" />
    <SpriteRule Name="Press down" Sequence="19" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Down" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else un-press down" Sequence="20" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Down" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="If launched right" Sequence="21" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.RightLaunched" Parameter2="(int)Sprites.Rocket.State.RightLaunched" EndIf="false" Suspended="false" />
    <SpriteRule Name="Press right" Sequence="22" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else un-press right" Sequence="23" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="Accelerate by inputs" Sequence="29" Type="Do" Function="AccelerateByInputs" Parameter1="10" Parameter2="8" Parameter3="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="If no horizontal inputs are pressed" Sequence="24" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Right|SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to horizontal inertia" Sequence="25" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="50" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if no vertical inputs are pressed" Sequence="26" Type="ElseIf" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Up|SpriteBase.InputBits.Down" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to vertical inertia" Sequence="27" Type="Do" Function="ReactToInertia" Parameter1="50" Parameter2="100" EndIf="true" Suspended="false" />
    <SpriteRule Name="If no inputs are pressed" Sequence="30" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Up|SpriteBase.InputBits.Right|SpriteBase.InputBits.Down|SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to gravity" Sequence="31" Type="Do" Function="AlterYVelocity" Parameter1=".3" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="33" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor belt" Sequence="32" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="If riding platform" Sequence="34" Type="If" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="ReactToPlatform" Sequence="35" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else check for landing on platform" Sequence="36" Type="Else" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if no inputs are pressed" Sequence="37" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If reacting to solidity hits solid" Sequence="38" Type="If" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else move by velocity" Sequence="43" Type="Else" Function="MoveByVelocity" EndIf="true" Suspended="false" />
    <SpriteRule Name="Explode" Sequence="41" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Explosion)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="42" Type="Do" Function="Deactivate" EndIf="false" Suspended="false" />
    <SpriteRule Name="Check for igniters" Sequence="1" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Igniters" ResultParameter="Ignited" EndIf="false" Suspended="false" />
    <SpriteRule Name="If ignited" Sequence="2" Type="If" Function="&gt;=" Parameter1="Ignited" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If facing up" Sequence="3" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.Up" Parameter2="(int)Sprites.Rocket.State.Up" EndIf="false" Suspended="false" />
    <SpriteRule Name="Launch up" Sequence="4" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Rocket.State.UpLaunched" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If facing right" Sequence="5" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.Right" Parameter2="(int)Sprites.Rocket.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Launch right" Sequence="6" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Rocket.State.RightLaunched" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If facing down" Sequence="7" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.Down" Parameter2="(int)Sprites.Rocket.State.Down" EndIf="false" Suspended="false" />
    <SpriteRule Name="Launch down" Sequence="8" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Rocket.State.DownLaunched" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="If facing left" Sequence="9" Type="If" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.Left" Parameter2="(int)Sprites.Rocket.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Launch left" Sequence="10" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Rocket.State.LeftLaunched" Parameter2="RelativePosition.CenterMiddle" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if ignited" Sequence="11" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="And rocket was launched" Sequence="39" Type="And" Function="IsInState" Parameter1="(int)Sprites.Rocket.State.UpLaunched" Parameter2="(int)Sprites.Rocket.State.LeftLaunched" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if no horizontal inputs are pressed" Sequence="28" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Move next to solid" Sequence="40" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteParameter Name="Ignited" />
    <SpriteState Name="Up" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Right" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="1" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Down" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="2" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Left" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="3" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="UpLaunched" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="5">
      <SpriteFrame Sequence="0" FrameValue="4" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="RightLaunched" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="6">
      <SpriteFrame Sequence="0" FrameValue="5" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="DownLaunched" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="7">
      <SpriteFrame Sequence="0" FrameValue="6" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="LeftLaunched" FramesetName="RocketFrames" SolidWidth="32" SolidHeight="32" Sequence="8">
      <SpriteFrame Sequence="0" FrameValue="7" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Jumper">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="If jump timer has reached wait time" Sequence="1" Type="If" Function="&gt;=" Parameter1="WaitTimer" Parameter2="JumpWait" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate jump" Sequence="2" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="Jump velocity up" Sequence="3" Type="Do" Function="AlterYVelocity" Parameter1="-6" EndIf="false" Suspended="false" />
    <SpriteRule Name="If sitting right" Sequence="6" Type="If" Function="IsInState" Parameter1="(int)Sprites.Jumper.State.Right" Parameter2="(int)Sprites.Jumper.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Jump velocity right" Sequence="7" Type="Do" Function="AlterXVelocity" Parameter1="4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else Jump velocity left" Sequence="8" Type="Else" Function="AlterXVelocity" Parameter1="-4" EndIf="true" Suspended="false" />
    <SpriteRule Name="Reset jump timer" Sequence="9" Type="Do" Function="=" Parameter1="-1" ResultParameter="WaitTimer" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="39" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to gravity" Sequence="25" Type="Do" Function="AlterYVelocity" Parameter1=".3" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="26" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="27" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="37" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="38" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="40" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or touching ground" Sequence="30" Type="Or" Function="Blocked" Parameter1="SpriteBase.Direction.Down" EndIf="false" Suspended="false" />
    <SpriteRule Name="If riding platform" Sequence="29" Type="If" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="If jumping" Sequence="28" Type="If" Function="&lt;" Parameter1="WaitTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="End jump" Sequence="33" Type="Do" Function="+" Parameter1="WaitTimer" Parameter2="1" ResultParameter="WaitTimer" EndIf="true" Suspended="false" />
    <SpriteRule Name="If waiting to jump" Sequence="10" Type="If" Function="&gt;=" Parameter1="WaitTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Pass the time" Sequence="24" Type="Do" Function="+" Parameter1="WaitTimer" Parameter2="1" ResultParameter="WaitTimer" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on first sitting frame" Sequence="11" Type="If" Function="==" Parameter1="frame" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else animate landing" Sequence="21" Type="Else" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="true" Suspended="false" />
    <SpriteRule Name="If returned to sitting" Sequence="22" Type="If" Function="&gt;=" Parameter1="frame" Parameter2="18" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset to sitting frame" Sequence="23" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if jumping" Sequence="36" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Don't be riding a platform" Sequence="4" Type="Do" Function="StopRiding" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not planning to move up" Sequence="31" Type="And" Function="&gt;=" Parameter1="dy" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If jump animation has not reached jumping frame" Sequence="34" Type="If" Function="!=" Parameter1="frame" Parameter2="11" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate until jumping frame" Sequence="35" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="true" Suspended="false" />
    <SpriteRule Name="Get nearest player" Sequence="12" Type="Do" Function="GetNearestSpriteIndex" Parameter1="ParentLayer.m_SpriteCategories.Player" ResultParameter="NearestPlayer" EndIf="false" Suspended="false" />
    <SpriteRule Name="If nearest player exists" Sequence="13" Type="If" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.Player" Parameter2="NearestPlayer" EndIf="false" Suspended="false" />
    <SpriteRule Name="If player is left of this sprite" Sequence="14" Type="If" Function="IsTargetDirection" Parameter1="SpriteBase.Direction.Left" EndIf="true" Suspended="false" />
    <SpriteRule Name="And this sprite is facing right" Sequence="15" Type="And" Function="IsInState" Parameter1="(int)Sprites.Jumper.State.Right" Parameter2="(int)Sprites.Jumper.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to facing left" Sequence="16" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Jumper.State.Left" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If player is right of this sprite" Sequence="17" Type="If" Function="IsTargetDirection" Parameter1="SpriteBase.Direction.Right" EndIf="true" Suspended="false" />
    <SpriteRule Name="And this sprite is facing left" Sequence="18" Type="And" Function="IsInState" Parameter1="(int)Sprites.Jumper.State.Left" Parameter2="(int)Sprites.Jumper.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to facing right" Sequence="19" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Jumper.State.Right" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Don't be riding a conveyor" Sequence="5" Type="Do" Function="=" Parameter1="0" ResultParameter="OnConveyorBelt" EndIf="false" Suspended="false" />
    <SpriteRule Name="Zero inertia" Sequence="20" Type="Do" Function="ReactToInertia" Parameter1="0" Parameter2="0" EndIf="true" Suspended="false" />
    <SpriteRule Name="Stop horizontal velocity" Sequence="32" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteParameter Name="JumpWait" />
    <SpriteParameter Name="WaitTimer" />
    <SpriteParameter Name="NearestPlayer" />
    <SpriteState Name="Right" FramesetName="JumperFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="1" FrameValue="1" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="1" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="0" Duration="1" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="0" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Left" FramesetName="JumperFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="1" FrameValue="4" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="3" Duration="1" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="4" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="5" Duration="1" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="5" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Spider">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Push toward player" Sequence="4" Type="Do" Function="PushTowardCategory" Parameter1="ParentLayer.m_SpriteCategories.Player" Parameter2="0" Parameter3="50" EndIf="false" Suspended="false" />
    <SpriteRule Name="Get direction" Sequence="5" Type="Do" Function="GetPolarStateByVector" Parameter1="(int)Sprites.Spider.State.Main" Parameter2="36" ResultParameter="PlayerDirection" EndIf="false" Suspended="false" />
    <SpriteRule Name="If player is below" Sequence="6" Type="If" Function="==" Parameter1="PlayerDirection" Parameter2="27" EndIf="false" Suspended="false" />
    <SpriteRule Name="Start falling" Sequence="8" Type="Do" Function="=" Parameter1="1" ResultParameter="Behavior" EndIf="true" Suspended="false" />
    <SpriteRule Name="If waiting for player" Sequence="1" Type="If" Function="==" Parameter1="Behavior" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else if falling" Sequence="10" Type="ElseIf" Function="==" Parameter1="Behavior" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Go down" Sequence="11" Type="Do" Function="AlterYVelocity" Parameter1="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset velocity" Sequence="9" Type="Do" Function="LimitVelocity" Parameter1="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit velocity" Sequence="12" Type="Do" Function="LimitVelocity" Parameter1="10" EndIf="false" Suspended="false" />
    <SpriteRule Name="While next web is above" Sequence="13" Type="While" Function="&lt;" Parameter1="NextWeb" Parameter2="y" EndIf="false" Suspended="false" />
    <SpriteRule Name="Initialize NextWeb" Sequence="7" Type="Do" Function="=" Parameter1="(int)y" ResultParameter="NextWeb" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deploy a web segment" Sequence="14" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Web)" Parameter2="RelativePosition.TopCenter" Parameter3="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created segment" Sequence="15" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move created segment" Sequence="16" Type="Do" Function="SetTargetParameter" Parameter1="&quot;y&quot;" Parameter2="NextWeb" EndIf="false" Suspended="false" />
    <SpriteRule Name="Increase LastWeb" Sequence="17" Type="Do" Function="+" Parameter1="NextWeb" Parameter2="32" ResultParameter="NextWeb" EndIf="true" Suspended="false" />
    <SpriteRule Name="Select player" Sequence="18" Type="Do" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.Player" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If player is above" Sequence="19" Type="If" Function="IsTargetDirection" Parameter1="SpriteBase.Direction.Up" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stop falling" Sequence="21" Type="Do" Function="LimitVelocity" Parameter1="0" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else if climbing" Sequence="22" Type="ElseIf" Function="==" Parameter1="Behavior" Parameter2="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="climb back up" Sequence="23" Type="Do" Function="AlterYVelocity" Parameter1="-1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to climbing" Sequence="20" Type="Do" Function="=" Parameter1="2" ResultParameter="Behavior" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit climb speed" Sequence="25" Type="Do" Function="LimitVelocity" Parameter1="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If reached starting height" Sequence="30" Type="If" Function="&lt;=" Parameter1="y" Parameter2="StartY" EndIf="false" Suspended="false" />
    <SpriteRule Name="If uninitialized" Sequence="2" Type="If" Function="==" Parameter1="StartY" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Record starting height" Sequence="3" Type="Do" Function="=" Parameter1="(int)y" ResultParameter="StartY" EndIf="true" Suspended="false" />
    <SpriteRule Name="Stop climbing" Sequence="31" Type="Do" Function="LimitVelocity" Parameter1="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Snap to exact top" Sequence="32" Type="Do" Function="=" Parameter1="StartY" ResultParameter="y" EndIf="false" Suspended="false" />
    <SpriteRule Name="Return to waiting state" Sequence="33" Type="Do" Function="=" Parameter1="0" ResultParameter="Behavior" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if climbing" Sequence="34" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if waiting" Sequence="36" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if falling" Sequence="35" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="React To Solidity; if solid hit" Sequence="37" Type="If" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move by Velocity" Sequence="39" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to climbing after hitting solid" Sequence="38" Type="Do" Function="=" Parameter1="2" ResultParameter="Behavior" EndIf="true" Suspended="false" />
    <SpriteRule Name="Get nearest web" Sequence="26" Type="Do" Function="GetNearestSpriteIndex" Parameter1="ParentLayer.m_SpriteCategories.Web" ResultParameter="NextWeb" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select nearest web" Sequence="27" Type="Do" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.Web" Parameter2="NextWeb" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set web's deactivate height" Sequence="29" Type="Do" Function="SetTargetParameter" Parameter1="&quot;DeactivateHeight&quot;" Parameter2="(int)y" EndIf="true" Suspended="false" />
    <SpriteRule Name="If web selected" Sequence="28" Type="If" Function="&gt;=" Parameter1="NextWeb" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="24" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteParameter Name="PlayerDirection" />
    <SpriteParameter Name="Behavior" />
    <SpriteParameter Name="NextWeb" />
    <SpriteParameter Name="StartY" />
    <SpriteState Name="Main" FramesetName="SpiderFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="1" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="2" Duration="10" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Web">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="If need to deactivate" Sequence="1" Type="If" Function="&lt;=" Parameter1="DeactivateHeight" Parameter2="y" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="3" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="And deactivation initialized" Sequence="2" Type="And" Function="&gt;" Parameter1="DeactivateHeight" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteParameter Name="DeactivateHeight" />
    <SpriteState Name="Main" FramesetName="SpiderFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="CrystalizedBot">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Test for collision with player" Sequence="13" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Player" ResultParameter="temp" EndIf="false" Suspended="false" />
    <SpriteRule Name="If state does not match contents" Sequence="1" Type="If" Function="!=" Parameter1="Contents" Parameter2="state" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch state" Sequence="4" Type="Do" Function="SwitchToState" Parameter1="Contents" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to inertia" Sequence="10" Type="Do" Function="ReactToInertia" Parameter1="80" Parameter2="80" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="11" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move by velocity" Sequence="12" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="9" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If collided" Sequence="14" Type="If" Function="&gt;=" Parameter1="temp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If this is an energy source" Sequence="16" Type="If" Function="==" Parameter1="Contents" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add energy to inventory" Sequence="17" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotEnergySources" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is water" Sequence="18" Type="If" Function="==" Parameter1="Contents" Parameter2="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add bot droplet to inventory" Sequence="19" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotDroplets" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="Else Deactivate" Sequence="43" Type="Else" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is splash power source" Sequence="26" Type="If" Function="==" Parameter1="Contents" Parameter2="6" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add bot splash power source to inventory" Sequence="27" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotSplashPowers" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is collision power source" Sequence="24" Type="If" Function="==" Parameter1="Contents" Parameter2="5" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add bot collision power source to inventory" Sequence="25" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotCollisionPowers" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is follower" Sequence="22" Type="If" Function="==" Parameter1="Contents" Parameter2="4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add bot follower to inventory" Sequence="23" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotFollowers" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is bomb" Sequence="20" Type="If" Function="==" Parameter1="Contents" Parameter2="3" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add bot bomb to inventory" Sequence="21" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotBombs" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this sprite regenerates" Sequence="40" Type="If" Function="&gt;" Parameter1="RegenerateTime" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Switch to regenerating state" Sequence="41" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.CrystalizedBot.State.Regenerating" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set Regen Timer" Sequence="42" Type="Do" Function="=" Parameter1="RegenerateTime" ResultParameter="regenTimer" EndIf="false" Suspended="false" />
    <SpriteRule Name="End collided" Sequence="44" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="And regen timer is not running" Sequence="2" Type="And" Function="==" Parameter1="regenTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If regenerating" Sequence="7" Type="If" Function="&gt;" Parameter1="regenTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Run regen timer" Sequence="8" Type="Do" Function="-" Parameter1="regenTimer" Parameter2="1" ResultParameter="regenTimer" EndIf="true" Suspended="false" />
    <SpriteRule Name="And not regenerating" Sequence="15" Type="And" Function="==" Parameter1="regenTimer" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If contents is valid" Sequence="3" Type="If" Function="&gt;" Parameter1="Contents" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else match contents to state" Sequence="5" Type="Else" Function="=" Parameter1="state" ResultParameter="Contents" EndIf="true" Suspended="false" />
    <SpriteRule Name="End contents checking" Sequence="6" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is worm DNA" Sequence="28" Type="If" Function="==" Parameter1="Contents" Parameter2="11" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add worm DNA to inventory" Sequence="29" Type="Do" Function="ChangeCounter" Parameter1="Counter.DNAWorms" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is spider DNA" Sequence="30" Type="If" Function="==" Parameter1="Contents" Parameter2="12" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add spider DNA to inventory" Sequence="31" Type="Do" Function="ChangeCounter" Parameter1="Counter.DNASpiders" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is a move up bot" Sequence="32" Type="If" Function="==" Parameter1="Contents" Parameter2="7" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add move up bot to inventory" Sequence="33" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveUps" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is a move left bot" Sequence="38" Type="If" Function="==" Parameter1="Contents" Parameter2="10" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add move left bot to inventory" Sequence="39" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveLefts" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is a move down bot" Sequence="36" Type="If" Function="==" Parameter1="Contents" Parameter2="9" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add move down bot to inventory" Sequence="37" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveDowns" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteRule Name="If this is a move right bot" Sequence="34" Type="If" Function="==" Parameter1="Contents" Parameter2="8" EndIf="false" Suspended="false" />
    <SpriteRule Name="Add move right bot to inventory" Sequence="35" Type="Do" Function="ChangeCounter" Parameter1="Counter.BotMoveRights" Parameter2="CounterOperation.IncrementAndStop" EndIf="true" Suspended="false" />
    <SpriteParameter Name="temp" />
    <SpriteParameter Name="Contents" />
    <SpriteParameter Name="RegenerateTime" />
    <SpriteParameter Name="regenTimer" />
    <SpriteState Name="Worm" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="12">
      <SpriteFrame Sequence="0" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="10" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="EnergySource" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Water" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="3">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Bomb" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Follower" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="5">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="CollisionPower" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="6">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="SplashPower" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="7">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Regenerating" FramesetName="Sparkles" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="1" FrameValue="20" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="21" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="22" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="24" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="25" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="26" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="27" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="20" FrameValue="28" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="23" FrameValue="29" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="10" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="11" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="12" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="14" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="21" FrameValue="15" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="24" FrameValue="16" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="26" FrameValue="17" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="28" FrameValue="18" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="31" FrameValue="19" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="0" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="1" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="22" FrameValue="2" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="25" FrameValue="3" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="27" FrameValue="4" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="29" FrameValue="5" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="32" FrameValue="6" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="34" FrameValue="7" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="36" FrameValue="8" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="38" FrameValue="9" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="30" FrameValue="30" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="33" FrameValue="31" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="35" FrameValue="32" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="37" FrameValue="33" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="39" FrameValue="34" Duration="3" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="35" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="36" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="37" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="38" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="39" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="MoveUp" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="8">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="20" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="MoveRight" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="9">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="21" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="MoveDown" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="10">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="22" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="MoveLeft" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="11">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="23" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Spider" FramesetName="NanoBotFrames" SolidWidth="32" SolidHeight="32" Sequence="13">
      <SpriteFrame Sequence="1" FrameValue="0" Duration="30" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="2" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="3" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="9" FrameValue="4" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="11" FrameValue="5" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="13" FrameValue="6" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="15" FrameValue="7" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="17" FrameValue="8" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="19" FrameValue="9" Duration="2" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="8" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="10" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="12" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="14" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="16" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="18" FrameValue="13" Duration="0" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="BotMover">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Get touched energy" Sequence="1" Type="Do" Function="TestCollisionRectMargin" Parameter1="ParentLayer.m_SpriteCategories.BotEnergies" Parameter2="2" ResultParameter="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="If touched energy" Sequence="3" Type="If" Function="&gt;=" Parameter1="TempNum" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select touched energy" Sequence="17" Type="Do" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.BotEnergies" Parameter2="TempNum" EndIf="false" Suspended="false" />
    <SpriteRule Name="Terminate touched energy" Sequence="18" Type="Do" Function="SetTargetParameter" Parameter1="&quot;DeactivateFlag&quot;" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If move right" Sequence="4" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotMover.State.Right" Parameter2="(int)Sprites.BotMover.State.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="Input right" Sequence="5" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="If move left" Sequence="6" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotMover.State.Left" Parameter2="(int)Sprites.BotMover.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Input left" Sequence="7" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="If move up" Sequence="8" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotMover.State.Up" Parameter2="(int)Sprites.BotMover.State.Up" EndIf="false" Suspended="false" />
    <SpriteRule Name="Input up" Sequence="9" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Up" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="If move down" Sequence="10" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotMover.State.Down" Parameter2="(int)Sprites.BotMover.State.Down" EndIf="false" Suspended="false" />
    <SpriteRule Name="Input down" Sequence="11" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Down" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="If follow" Sequence="12" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotMover.State.Follow" Parameter2="(int)Sprites.BotMover.State.Follow" EndIf="false" Suspended="false" />
    <SpriteRule Name="Input follow" Sequence="13" Type="Do" Function="SetInputsTowardCategory" Parameter1="ParentLayer.m_SpriteCategories.Enemies" Parameter2="-1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Clear inputs" Sequence="2" Type="Do" Function="ClearInputs" Parameter1="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else stop moving" Sequence="19" Type="Else" Function="ReactToInertia" Parameter1="0" Parameter2="0" EndIf="true" Suspended="false" />
    <SpriteRule Name="Accelerate by inputs" Sequence="20" Type="Do" Function="AccelerateByInputs" Parameter1="2" Parameter2="2" Parameter3="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="21" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="22" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="If deactivate flag is set" Sequence="27" Type="If" Function="&gt;" Parameter1="DeactivateFlag" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="28" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If on biohazard" Sequence="24" Type="If" Function="IsOnTile" Parameter1="TileCategoryName.Biohazard" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Flag for deactivate" Sequence="25" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="If touching tiles that affect bots" Sequence="23" Type="If" Function="TouchTiles" Parameter1="TileCategoryName.AffectBots" EndIf="false" Suspended="false" />
    <SpriteRule Name="End touch tiles that affect bots" Sequence="26" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If not following anything" Sequence="14" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Up|SpriteBase.InputBits.Right|SpriteBase.InputBits.Down|SpriteBase.InputBits.Left" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stop moving when not following" Sequence="15" Type="Do" Function="ReactToInertia" Parameter1="0" Parameter2="0" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if follow" Sequence="16" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteParameter Name="TempNum" />
    <SpriteParameter Name="DeactivateFlag" />
    <SpriteState Name="Left" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="23" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Right" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="21" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Up" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="20" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Down" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="22" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Follow" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="5">
      <SpriteFrame Sequence="0" FrameValue="19" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="BotEnergy">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Animate" Sequence="1" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If timeout" Sequence="2" Type="If" Function="&gt;" Parameter1="frame" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="4" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="Or deactivate flag set" Sequence="3" Type="Or" Function="!=" Parameter1="DeactivateFlag" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteParameter Name="DeactivateFlag" />
    <SpriteState Name="Bolt" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="15" Duration="2" MaskAlphaLevel="166" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="BotEnergySource">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Attach to energy user" Sequence="31" Type="Do" Function="AttachToNearest" Parameter1="ParentLayer.m_SpriteCategories.NeedsPower" EndIf="true" Suspended="false" />
    <SpriteRule Name="Stick to energy user" Sequence="2" Type="Do" Function="StickToAttached" Parameter1="RelativePosition.LeftMiddle" Parameter2="RelativePosition.RightMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Generate energy" Sequence="16" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.BotEnergy)" Parameter2="RelativePosition.RightMiddle" Parameter3="RelativePosition.LeftMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else find unattached energy user" Sequence="19" Type="Else" Function="FindNearestFreeBot" Parameter1="ParentLayer.m_SpriteCategories.NeedsPower" Parameter2="ParentLayer.m_SpriteCategories.BotEnergySources" Parameter3="Counter.BotRange.CurrentValue" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Energy gets used up" Sequence="18" Type="Do" Function="-" Parameter1="Energy" Parameter2="1" ResultParameter="Energy" EndIf="true" Suspended="false" />
    <SpriteRule Name="If depleted" Sequence="38" Type="If" Function="&lt;=" Parameter1="Energy" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="40" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If attached to energy user" Sequence="1" Type="If" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move toward it" Sequence="26" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test if reached energy user" Sequence="27" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.NeedsPower" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If reached energy user" Sequence="28" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if attached to energy user" Sequence="33" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Limit velocity" Sequence="23" Type="Do" Function="LimitVelocity" Parameter1="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or deactivate flag is set" Sequence="39" Type="Or" Function="&gt;" Parameter1="DeactivateFlag" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If react to solidity changes velocity" Sequence="24" Type="If" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Tell self to deactivate" Sequence="25" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="If always generate energy" Sequence="3" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotEnergySource.State.Always" Parameter2="(int)Sprites.BotEnergySource.State.Always" EndIf="false" Suspended="false" />
    <SpriteRule Name="If generate energy on collision" Sequence="5" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotEnergySource.State.OnCollision" Parameter2="(int)Sprites.BotEnergySource.State.OnCollision" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn on generator always" Sequence="4" Type="Do" Function="=" Parameter1="1" ResultParameter="DoGenerate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If generating energy" Sequence="15" Type="If" Function="&gt;" Parameter1="DoGenerate" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test for collision" Sequence="6" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Enemies" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If collision detected" Sequence="7" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn on generator for collision" Sequence="8" Type="Do" Function="=" Parameter1="1" ResultParameter="DoGenerate" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if generate energy on collision" Sequence="9" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Reset generator flag" Sequence="17" Type="Do" Function="=" Parameter1="0" ResultParameter="DoGenerate" EndIf="false" Suspended="false" />
    <SpriteRule Name="If generate energy on splash" Sequence="10" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotEnergySource.State.OnSplash" Parameter2="(int)Sprites.BotEnergySource.State.OnSplash" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test for splash" Sequence="11" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Water" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If splashed" Sequence="12" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn on generator for splash" Sequence="13" Type="Do" Function="=" Parameter1="1" ResultParameter="DoGenerate" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if generate energy on splash" Sequence="14" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If touching tiles that affect bots" Sequence="34" Type="If" Function="TouchTiles" Parameter1="TileCategoryName.AffectBots" EndIf="false" Suspended="false" />
    <SpriteRule Name="If on biohazard" Sequence="35" Type="If" Function="IsOnTile" Parameter1="TileCategoryName.Biohazard" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Flag for deactivate" Sequence="36" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="End touch tiles that affect bots" Sequence="37" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Check if energy user has energy source already" Sequence="29" Type="Do" Function="GetTargetAttachment" Parameter1="ParentLayer.m_SpriteCategories.NeedsPower" Parameter2="-1" Parameter3="ParentLayer.m_SpriteCategories.BotEnergySources" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If target has no attached energy source" Sequence="30" Type="If" Function="&lt;" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if reached energy user" Sequence="32" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to inertia" Sequence="22" Type="Do" Function="ReactToInertia" Parameter1="99" Parameter2="99" EndIf="false" Suspended="false" />
    <SpriteRule Name="If unattached energy user is found" Sequence="20" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Attract to unattached energy user" Sequence="21" Type="Do" Function="PushTowardCategory" Parameter1="ParentLayer.m_SpriteCategories.NeedsPower" Parameter2="TargetIndex" Parameter3="2" EndIf="true" Suspended="false" />
    <SpriteParameter Name="Energy" />
    <SpriteParameter Name="TargetIndex" />
    <SpriteParameter Name="DeactivateFlag" />
    <SpriteParameter Name="DoGenerate" />
    <SpriteState Name="Always" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="14" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="OnCollision" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="16" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="OnSplash" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="3">
      <SpriteFrame Sequence="0" FrameValue="17" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="BotDestructor">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Seek bot" Sequence="1" Type="Do" Function="PushTowardCategory" Parameter1="ParentLayer.m_SpriteCategories.Bot" Parameter2="-1" Parameter3="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit velocity" Sequence="2" Type="Do" Function="LimitVelocity" Parameter1="4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test collision with bot" Sequence="4" Type="Do" Function="TestCollisionRectMargin" Parameter1="ParentLayer.m_SpriteCategories.Bot" Parameter2="2" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If collided" Sequence="5" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select target" Sequence="6" Type="Do" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.Bot" Parameter2="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Tell target to deactivate" Sequence="7" Type="Do" Function="SetTargetParameter" Parameter1="&quot;DeactivateFlag&quot;" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="14" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="Move" Sequence="3" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="If deactivate flag is set" Sequence="13" Type="If" Function="&gt;" Parameter1="DeactivateFlag" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Tell self to deactivate" Sequence="8" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="If touching tiles that affect bots" Sequence="9" Type="If" Function="TouchTiles" Parameter1="TileCategoryName.AffectBots" EndIf="false" Suspended="false" />
    <SpriteRule Name="If on biohazard" Sequence="10" Type="If" Function="IsOnTile" Parameter1="TileCategoryName.Biohazard" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Flag for deactivate" Sequence="11" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="End touch tiles that affect bots" Sequence="12" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteParameter Name="TargetIndex" />
    <SpriteParameter Name="DeactivateFlag" />
    <SpriteState Name="Main" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="27" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="BotBomber">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="If deactivate flag is set" Sequence="31" Type="If" Function="&gt;" Parameter1="DeactivateFlag" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="32" Type="Do" Function="Deactivate" EndIf="false" Suspended="false" />
    <SpriteRule Name="If attached to bot" Sequence="1" Type="If" Function="IsRidingPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stick to bot" Sequence="2" Type="Do" Function="StickToAttached" Parameter1="RelativePosition.BottomCenter" Parameter2="RelativePosition.TopCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else find unattached bot" Sequence="3" Type="Else" Function="FindNearestFreeBot" Parameter1="ParentLayer.m_SpriteCategories.BotCenter" Parameter2="ParentLayer.m_SpriteCategories.BotBombs" Parameter3="Counter.BotRange.CurrentValue" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Limit velocity" Sequence="7" Type="Do" Function="LimitVelocity" Parameter1="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="If react to solidity changes velocity" Sequence="8" Type="If" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Tell self to deactivate" Sequence="11" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="Move toward bot" Sequence="12" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Test if reached bot" Sequence="13" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.BotCenter" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If reached bot" Sequence="14" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Attach to bot" Sequence="17" Type="Do" Function="AttachToNearest" Parameter1="ParentLayer.m_SpriteCategories.BotCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if attached to energy user" Sequence="19" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Test if energy supplied" Sequence="20" Type="Do" Function="TestCollisionRectMargin" Parameter1="ParentLayer.m_SpriteCategories.BotEnergies" Parameter2="2" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If energy supplied" Sequence="21" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop bomb" Sequence="23" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Bomb)" Parameter2="RelativePosition.TopCenter" Parameter3="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Deactivate because finished goal" Sequence="26" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="And horizontal velocity is less than 1" Sequence="9" Type="And" Function="&lt;" Parameter1="System.Math.Abs(dx)" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="And vertical velocity is less than 1" Sequence="10" Type="And" Function="&lt;" Parameter1="System.Math.Abs(dy)" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If in bomb state" Sequence="22" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotBomber.State.Bomb" Parameter2="(int)Sprites.BotBomber.State.Bomb" EndIf="false" Suspended="false" />
    <SpriteRule Name="If in water state" Sequence="24" Type="If" Function="IsInState" Parameter1="(int)Sprites.BotBomber.State.Water" Parameter2="(int)Sprites.BotBomber.State.Water" EndIf="false" Suspended="false" />
    <SpriteRule Name="Drop water" Sequence="25" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Droplet)" Parameter2="RelativePosition.BottomCenter" Parameter3="RelativePosition.TopCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If touching tiles that affect bots" Sequence="27" Type="If" Function="TouchTiles" Parameter1="TileCategoryName.AffectBots" EndIf="false" Suspended="false" />
    <SpriteRule Name="If on biohazard" Sequence="28" Type="If" Function="IsOnTile" Parameter1="TileCategoryName.Biohazard" Parameter2="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Flag for deactivate" Sequence="29" Type="Do" Function="=" Parameter1="1" ResultParameter="DeactivateFlag" EndIf="true" Suspended="false" />
    <SpriteRule Name="End touch tiles that affect bots" Sequence="30" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to inertia" Sequence="6" Type="Do" Function="ReactToInertia" Parameter1="99" Parameter2="99" EndIf="false" Suspended="false" />
    <SpriteRule Name="Check if target has bomb attachments" Sequence="15" Type="Do" Function="GetTargetAttachment" Parameter1="ParentLayer.m_SpriteCategories.BotCenter" Parameter2="-1" Parameter3="ParentLayer.m_SpriteCategories.BotBombs" ResultParameter="TargetIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If no other it has no other attachments" Sequence="16" Type="If" Function="&lt;" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="End if reached bot" Sequence="18" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If unattached bot found" Sequence="4" Type="If" Function="&gt;=" Parameter1="TargetIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Attact to unattached bot" Sequence="5" Type="Do" Function="PushTowardCategory" Parameter1="ParentLayer.m_SpriteCategories.BotCenter" Parameter2="TargetIndex" Parameter3="2" EndIf="true" Suspended="false" />
    <SpriteParameter Name="DeactivateFlag" />
    <SpriteParameter Name="TargetIndex" />
    <SpriteState Name="Bomb" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="24" Duration="1" MaskAlphaLevel="152" />
    </SpriteState>
    <SpriteState Name="Water" FramesetName="NanoBotFrames" SolidWidth="16" SolidHeight="16" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="25" Duration="1" MaskAlphaLevel="152" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="InventorySelector">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Map player inputs to sprite inputs" Sequence="1" Type="Do" Function="MapPlayerToInputs" Parameter1="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If pressed right" Sequence="4" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Right" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Plan to move right 1 column" Sequence="5" Type="Do" Function="AlterXVelocity" Parameter1="32" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressed down" Sequence="6" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Down" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Plan to move down one row" Sequence="7" Type="Do" Function="AlterYVelocity" Parameter1="32" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressed up" Sequence="8" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Up" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Plan to move up one row" Sequence="9" Type="Do" Function="AlterYVelocity" Parameter1="-32" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressed left" Sequence="10" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Plan to move left one column" Sequence="11" Type="Do" Function="AlterXVelocity" Parameter1="-32" EndIf="true" Suspended="false" />
    <SpriteRule Name="React to solidity (edges of available inventory)" Sequence="12" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move to new cell" Sequence="13" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="Stop moving" Sequence="14" Type="Do" Function="LimitVelocity" Parameter1="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select inventory item under cursor" Sequence="15" Type="Do" Function="TileGetValue" Parameter1="RelativePosition.CenterMiddle" ResultParameter="Counter.SelectedInventory.CurrentValue" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="16" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If inventory button is not pressed" Sequence="2" Type="If" Function="!IsInputPressed" Parameter1="SpriteBase.InputBits.Button2" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Clear inputs" Sequence="3" Type="Do" Function="ClearInputs" Parameter1="false" EndIf="true" Suspended="false" />
    <SpriteState Name="Main" FramesetName="InventorySelector" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="1" Duration="5" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="ThrownTorch">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Gravity" Sequence="1" Type="Do" Function="+" Parameter1="dy" Parameter2=".3" ResultParameter="dy" EndIf="false" Suspended="false" />
    <SpriteRule Name="Inertia" Sequence="2" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="95" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="3" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on conveyor" Sequence="4" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="5" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="6" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="7" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="8" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move" Sequence="9" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="If burned out" Sequence="17" Type="If" Function="&gt;=" Parameter1="frame" Parameter2="BurnTime" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate" Sequence="18" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If need to ignite" Sequence="10" Type="If" Function="&gt;" Parameter1="NeedIgnite" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset need ignite" Sequence="16" Type="Do" Function="=" Parameter1="0" ResultParameter="NeedIgnite" EndIf="true" Suspended="false" />
    <SpriteRule Name="Create igniter" Sequence="11" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.Igniter)" Parameter2="RelativePosition.TopLeft" Parameter3="RelativePosition.TopLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created igniter" Sequence="12" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set igniter to be on left" Sequence="14" Type="Do" Function="SetTargetParameter" Parameter1="&quot;BecomeFire&quot;" Parameter2="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If need igniter on left" Sequence="13" Type="If" Function="IsInState" Parameter1="(int)Sprites.ThrownTorch.State.Left" Parameter2="(int)Sprites.ThrownTorch.State.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else set ignoter to be on right" Sequence="15" Type="Else" Function="SetTargetParameter" Parameter1="&quot;BecomeFire&quot;" Parameter2="2" EndIf="true" Suspended="false" />
    <SpriteParameter Name="BurnTime" />
    <SpriteParameter Name="NeedIgnite" />
    <SpriteState Name="Left" FramesetName="ThrownTorchFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="Right" FramesetName="ThrownTorchFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="1" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="MenuDummy">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Map player 1 to inputs" Sequence="1" Type="Do" Function="MapPlayerToInputs" Parameter1="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If any inputs are pressed" Sequence="2" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Up|SpriteBase.InputBits.Right|SpriteBase.InputBits.Down|SpriteBase.InputBits.Left|SpriteBase.InputBits.Button1|SpriteBase.InputBits.Button2|SpriteBase.InputBits.Button3|SpriteBase.InputBits.Button4" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="And sprite has never seen all inputs released" Sequence="3" Type="And" Function="==" Parameter1="InputsReleased" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Clear all inputs" Sequence="4" Type="Do" Function="ClearInputs" Parameter1="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else remember that inputs were unpressed" Sequence="5" Type="Else" Function="=" Parameter1="1" ResultParameter="InputsReleased" EndIf="true" Suspended="false" />
    <SpriteParameter Name="InputsReleased" />
    <SpriteState Name="Main" FramesetName="SeedFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="2" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="3" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="4" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="5" FrameValue="3" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="6" FrameValue="2" Duration="5" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="7" FrameValue="1" Duration="5" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="MenuPointer">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="Get inputs" Sequence="1" Type="Do" Function="MapPlayerToInputs" Parameter1="1" EndIf="false" Suspended="false" />
    <SpriteRule Name="If pressed down" Sequence="2" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Down" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move down" Sequence="3" Type="Do" Function="MoveOverTiles" Parameter1="SpriteBase.Direction.Down" Parameter2="2" EndIf="true" Suspended="false" />
    <SpriteRule Name="If pressed up" Sequence="4" Type="If" Function="IsInputPressed" Parameter1="SpriteBase.InputBits.Up" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move up" Sequence="5" Type="Do" Function="MoveOverTiles" Parameter1="SpriteBase.Direction.Up" Parameter2="2" EndIf="true" Suspended="false" />
    <SpriteParameter Name="MenuItemCount" />
    <SpriteState Name="Main" FramesetName="CoolFontFrames" SolidWidth="10" SolidHeight="12" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="136" Duration="1" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteDefinition Name="Eater">
    <BaseClass>SpriteBase</BaseClass>
    <SpriteRule Name="If walking left" Sequence="1" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.WalkLeft" Parameter2="(int)Sprites.Eater.State.WalkLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set inputs left" Sequence="2" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else unset left" Sequence="9" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="If walking right" Sequence="10" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.WalkRight" Parameter2="(int)Sprites.Eater.State.WalkRight" EndIf="false" Suspended="false" />
    <SpriteRule Name="Set input right" Sequence="11" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else unset right" Sequence="21" Type="Else" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="false" EndIf="true" Suspended="false" />
    <SpriteRule Name="Accelerate according to inputs" Sequence="24" Type="Do" Function="AccelerateByInputs" Parameter1="5" Parameter2="3" Parameter3="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to solidity" Sequence="30" Type="Do" Function="ReactToSolid" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on platform" Sequence="26" Type="Do" Function="LandDownOnPlatform" Parameter1="ParentLayer.m_SpriteCategories.Platforms" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to platform" Sequence="29" Type="Do" Function="ReactToPlatform" EndIf="false" Suspended="false" />
    <SpriteRule Name="Land on converyor" Sequence="25" Type="Do" Function="LandOnConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to conveyor" Sequence="28" Type="Do" Function="ReactToConveyor" Parameter1="1.4" EndIf="false" Suspended="false" />
    <SpriteRule Name="Move by velocity" Sequence="32" Type="Do" Function="MoveByVelocity" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to Inertia" Sequence="23" Type="Do" Function="ReactToInertia" Parameter1="100" Parameter2="80" EndIf="false" Suspended="false" />
    <SpriteRule Name="React to gravity" Sequence="22" Type="Do" Function="AlterYVelocity" Parameter1=".3" EndIf="false" Suspended="false" />
    <SpriteRule Name="Animate" Sequence="27" Type="Do" Function="Animate" Parameter1="SpriteBase.SpriteAnimationType.ByFrame" EndIf="false" Suspended="false" />
    <SpriteRule Name="If hole left" Sequence="3" Type="If" Function="!IsPointBlocked" Parameter1="RelativePosition.CenterMiddle" Parameter2="SpriteBase.Direction.Down" Parameter3="SolidWidth" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn right" Sequence="5" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.WalkRight" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If hole right" Sequence="12" Type="If" Function="!IsPointBlocked" Parameter1="RelativePosition.CenterMiddle" Parameter2="SpriteBase.Direction.Down" Parameter3="SolidWidth" EndIf="false" Suspended="false" />
    <SpriteRule Name="Turn left" Sequence="14" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.WalkLeft" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Stop pressing right" Sequence="19" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Right" Parameter2="false" EndIf="false" Suspended="false" />
    <SpriteRule Name="Start pressing left" Sequence="20" Type="Do" Function="SetInputState" Parameter1="SpriteBase.InputBits.Left" Parameter2="true" EndIf="true" Suspended="false" />
    <SpriteRule Name="If blocked left" Sequence="6" Type="If" Function="Blocked" Parameter1="SpriteBase.Direction.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="If blocked right" Sequence="15" Type="If" Function="Blocked" Parameter1="SpriteBase.Direction.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="And solid on left" Sequence="13" Type="And" Function="IsPointBlocked" Parameter1="RelativePosition.BottomLeft" Parameter2="SpriteBase.Direction.Down" Parameter3="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="Snap to ground" Sequence="31" Type="Do" Function="SnapToGround" Parameter1="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="And solid on right" Sequence="4" Type="And" Function="IsPointBlocked" Parameter1="RelativePosition.BottomRight" Parameter2="SpriteBase.Direction.Down" Parameter3="2" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not moving right" Sequence="16" Type="And" Function="!IsMoving" Parameter1="SpriteBase.Direction.Right" EndIf="false" Suspended="false" />
    <SpriteRule Name="And not moving left" Sequence="7" Type="And" Function="!IsMoving" Parameter1="SpriteBase.Direction.Left" EndIf="false" Suspended="false" />
    <SpriteRule Name="Also turn right" Sequence="8" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.WalkRight" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Also turn left" Sequence="17" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.WalkLeft" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="If turned left" Sequence="18" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.WalkLeft" Parameter2="(int)Sprites.Eater.State.WalkLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else (not digesting) test touching water droplet" Sequence="46" Type="Else" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Water" ResultParameter="HitIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If touched water" Sequence="47" Type="If" Function="&gt;=" Parameter1="HitIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="If biting/digesting" Sequence="33" Type="If" Function="!=" Parameter1="Digesting" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Digest water" Sequence="48" Type="Do" Function="=" Parameter1="2" ResultParameter="Digesting" EndIf="true" Suspended="false" />
    <SpriteRule Name="Switch to biting left" Sequence="65" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.BiteLeft" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Reset frame to 0" Sequence="67" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="If done biting" Sequence="34" Type="If" Function="&gt;=" Parameter1="frame" Parameter2="90" EndIf="false" Suspended="false" />
    <SpriteRule Name="If biting right" Sequence="35" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.BiteRight" Parameter2="(int)Sprites.Eater.State.BiteRight" EndIf="true" Suspended="false" />
    <SpriteRule Name="If walking left when started digesting" Sequence="62" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.WalkLeft" Parameter2="(int)Sprites.Eater.State.WalkLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="If started digesting something" Sequence="61" Type="If" Function="!=" Parameter1="Digesting" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else bite right" Sequence="66" Type="Else" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.BiteRight" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Switch to burping rightward" Sequence="36" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.BurpRight" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else switch to burping left" Sequence="37" Type="Else" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.BurpLeft" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="Reset frame for burping" Sequence="45" Type="Do" Function="=" Parameter1="0" ResultParameter="frame" EndIf="true" Suspended="false" />
    <SpriteRule Name="If burping right" Sequence="41" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.BurpRight" Parameter2="(int)Sprites.Eater.State.BurpRight" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select created sprite" Sequence="39" Type="Do" Function="SelectLastCreatedSprite" EndIf="false" Suspended="false" />
    <SpriteRule Name="Create burped item" Sequence="38" Type="Do" Function="AddSpriteHere" Parameter1="typeof(Sprites.CrystalizedBot)" Parameter2="RelativePosition.CenterMiddle" Parameter3="RelativePosition.CenterMiddle" EndIf="false" Suspended="false" />
    <SpriteRule Name="Convert to crystal of digested type" Sequence="40" Type="Do" Function="SetTargetParameter" Parameter1="&quot;Contents&quot;" Parameter2="Digesting" EndIf="false" Suspended="false" />
    <SpriteRule Name="Push regurgitated item rightward" Sequence="42" Type="Do" Function="SetTargetParameter" Parameter1="&quot;dx&quot;" Parameter2="5" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else push regurgitated item leftward" Sequence="43" Type="Else" Function="SetTargetParameter" Parameter1="&quot;dx&quot;" Parameter2="-5" EndIf="true" Suspended="false" />
    <SpriteRule Name="End digesting" Sequence="68" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="And burping" Sequence="70" Type="And" Function="IsInState" Parameter1="(int)Sprites.Eater.State.BurpLeft" Parameter2="(int)Sprites.Eater.State.BurpRight" EndIf="false" Suspended="false" />
    <SpriteRule Name="And done burping" Sequence="71" Type="And" Function="&gt;=" Parameter1="frame" Parameter2="60" EndIf="false" Suspended="false" />
    <SpriteRule Name="If facing left" Sequence="73" Type="If" Function="IsInState" Parameter1="(int)Sprites.Eater.State.BurpLeft" Parameter2="(int)Sprites.Eater.State.BurpLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="Resume walk left" Sequence="74" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.WalkLeft" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else resume walk right" Sequence="75" Type="Else" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.WalkRight" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End if burping" Sequence="80" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Reset digesting" Sequence="44" Type="Do" Function="=" Parameter1="0" ResultParameter="Digesting" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or standing left when started digesting" Sequence="63" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Eater.State.StandLeft" Parameter2="(int)Sprites.Eater.State.StandLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="If walk after burp" Sequence="72" Type="If" Function="!=" Parameter1="WalkAfterBurp" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else (if not walk after burp) if facing left" Sequence="76" Type="ElseIf" Function="IsInState" Parameter1="(int)Sprites.Eater.State.BurpLeft" Parameter2="(int)Sprites.Eater.State.BurpLeft" EndIf="false" Suspended="false" />
    <SpriteRule Name="Resume standing left" Sequence="77" Type="Do" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.StandLeft" Parameter2="RelativePosition.BottomCenter" EndIf="false" Suspended="false" />
    <SpriteRule Name="Else resume standing right" Sequence="78" Type="Else" Function="SwitchToState" Parameter1="(int)Sprites.Eater.State.StandRight" Parameter2="RelativePosition.BottomCenter" EndIf="true" Suspended="false" />
    <SpriteRule Name="End resume activity after burp" Sequence="79" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="Test touching enemies" Sequence="49" Type="Do" Function="TestCollisionRect" Parameter1="ParentLayer.m_SpriteCategories.Enemies" ResultParameter="HitIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="Select touched enemy" Sequence="51" Type="Do" Function="SelectTargetSprite" Parameter1="ParentLayer.m_SpriteCategories.Enemies" Parameter2="HitIndex" EndIf="false" Suspended="false" />
    <SpriteRule Name="If touched an enemy" Sequence="50" Type="If" Function="&gt;=" Parameter1="HitIndex" Parameter2="0" EndIf="false" Suspended="false" />
    <SpriteRule Name="End touched an enemy" Sequence="60" Type="End" Function="End" EndIf="true" Suspended="false" />
    <SpriteRule Name="If enemy is worm" Sequence="52" Type="If" Function="IsSpriteForTargetOfType" Parameter1="&quot;&quot;" Parameter2="typeof(Sprites.Worm)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Digest worm" Sequence="54" Type="Do" Function="=" Parameter1="11" ResultParameter="Digesting" EndIf="true" Suspended="false" />
    <SpriteRule Name="Eat (remove) worm" Sequence="53" Type="Do" Function="DeactivateTargetSpriteFor" Parameter1="&quot;&quot;" EndIf="false" Suspended="false" />
    <SpriteRule Name="If enemy is spider" Sequence="55" Type="If" Function="IsSpriteForTargetOfType" Parameter1="&quot;&quot;" Parameter2="typeof(Sprites.Spider)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Digest spider" Sequence="57" Type="Do" Function="=" Parameter1="12" ResultParameter="Digesting" EndIf="true" Suspended="false" />
    <SpriteRule Name="If enemy is explosion" Sequence="58" Type="If" Function="IsSpriteForTargetOfType" Parameter1="&quot;&quot;" Parameter2="typeof(Sprites.Explosion)" EndIf="false" Suspended="false" />
    <SpriteRule Name="Deactivate this eater" Sequence="59" Type="Do" Function="Deactivate" EndIf="true" Suspended="false" />
    <SpriteRule Name="If sprite is still active" Sequence="69" Type="If" Function="==" Parameter1="isActive" Parameter2="true" EndIf="false" Suspended="false" />
    <SpriteRule Name="Eat (remove) spider" Sequence="56" Type="Do" Function="DeactivateTargetSpriteFor" Parameter1="&quot;&quot;" EndIf="false" Suspended="false" />
    <SpriteRule Name="Or burping left when started digesting" Sequence="64" Type="Or" Function="IsInState" Parameter1="(int)Sprites.Eater.State.BurpLeft" Parameter2="(int)Sprites.Eater.State.BurpLeft" EndIf="false" Suspended="false" />
    <SpriteParameter Name="Digesting" />
    <SpriteParameter Name="HitIndex" />
    <SpriteParameter Name="WalkAfterBurp" />
    <SpriteState Name="WalkLeft" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="1">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="15" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="1" Duration="15" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="WalkRight" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="2">
      <SpriteFrame Sequence="0" FrameValue="6" Duration="15" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="7" Duration="15" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="BiteRight" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="4">
      <SpriteFrame Sequence="0" FrameValue="8" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="9" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="10" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="11" Duration="20" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="4" FrameValue="6" Duration="40" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="StandLeft" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="5">
      <SpriteFrame Sequence="0" FrameValue="0" Duration="20" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="StandRight" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="6">
      <SpriteFrame Sequence="0" FrameValue="6" Duration="20" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="BurpLeft" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="7">
      <SpriteFrame Sequence="0" FrameValue="3" Duration="20" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="BurpRight" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="8">
      <SpriteFrame Sequence="0" FrameValue="9" Duration="20" MaskAlphaLevel="0" />
    </SpriteState>
    <SpriteState Name="BiteLeft" FramesetName="EaterFrames" SolidWidth="32" SolidHeight="32" Sequence="3">
      <SpriteFrame Sequence="4" FrameValue="0" Duration="40" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="0" FrameValue="2" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="1" FrameValue="3" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="2" FrameValue="4" Duration="10" MaskAlphaLevel="0" />
      <SpriteFrame Sequence="3" FrameValue="5" Duration="20" MaskAlphaLevel="0" />
    </SpriteState>
  </SpriteDefinition>
  <SpriteCategory Name="Platforms">
    <SpriteCategorySprite DefinitionName="Platform" />
    <SpriteCategorySprite DefinitionName="Package" />
  </SpriteCategory>
  <SpriteCategory Name="Pusher">
    <SpriteCategorySprite DefinitionName="Player" />
    <SpriteCategorySprite DefinitionName="Package" />
    <SpriteCategorySprite DefinitionName="Platform" />
  </SpriteCategory>
  <SpriteCategory Name="Pushback">
    <SpriteCategorySprite DefinitionName="Package" />
  </SpriteCategory>
  <SpriteCategory Name="Enemies">
    <SpriteCategorySprite DefinitionName="Explosion" />
    <SpriteCategorySprite DefinitionName="Bombot" />
    <SpriteCategorySprite DefinitionName="Worm" />
    <SpriteCategorySprite DefinitionName="Jumper" />
    <SpriteCategorySprite DefinitionName="Spider" />
  </SpriteCategory>
  <SpriteCategory Name="Water">
    <SpriteCategorySprite DefinitionName="Droplet" />
  </SpriteCategory>
  <SpriteCategory Name="Igniters">
    <SpriteCategorySprite DefinitionName="Igniter" />
    <SpriteCategorySprite DefinitionName="Explosion" />
    <SpriteCategorySprite DefinitionName="Rocket" />
  </SpriteCategory>
  <SpriteCategory Name="Player">
    <SpriteCategorySprite DefinitionName="Player" />
  </SpriteCategory>
  <SpriteCategory Name="Web">
    <SpriteCategorySprite DefinitionName="Web" />
  </SpriteCategory>
  <SpriteCategory Name="NeedsPower">
    <SpriteCategorySprite DefinitionName="BotMover" />
    <SpriteCategorySprite DefinitionName="BotBomber" />
  </SpriteCategory>
  <SpriteCategory Name="BotEnergies">
    <SpriteCategorySprite DefinitionName="BotEnergy" />
  </SpriteCategory>
  <SpriteCategory Name="Bot">
    <SpriteCategorySprite DefinitionName="BotEnergySource" />
    <SpriteCategorySprite DefinitionName="BotMover" />
    <SpriteCategorySprite DefinitionName="BotDestructor" />
    <SpriteCategorySprite DefinitionName="BotEnergy" />
    <SpriteCategorySprite DefinitionName="BotBomber" />
  </SpriteCategory>
  <SpriteCategory Name="BotCenter">
    <SpriteCategorySprite DefinitionName="BotMover" />
  </SpriteCategory>
  <SpriteCategory Name="BotEnergySources">
    <SpriteCategorySprite DefinitionName="BotEnergySource" />
  </SpriteCategory>
  <SpriteCategory Name="BotBombs">
    <SpriteCategorySprite DefinitionName="BotBomber" />
  </SpriteCategory>
  <SpriteCategory Name="ThrownTorch">
    <SpriteCategorySprite DefinitionName="ThrownTorch" />
  </SpriteCategory>
  <Solidity Name="Standard">
    <SolidityShape CategoryName="Solid" ShapeName="SolidTileShape" />
    <SolidityShape CategoryName="Uphill" ShapeName="UphillTileShape" />
    <SolidityShape CategoryName="Downhill" ShapeName="DownhillTileShape" />
    <SolidityShape CategoryName="HalfUpLeft" ShapeName="UphillLeftTileShape" />
    <SolidityShape CategoryName="HalfUpRight" ShapeName="UphillRightTileShape" />
    <SolidityShape CategoryName="HalfDownLeft" ShapeName="DownhillLeftTileShape" />
    <SolidityShape CategoryName="HalfDownRight" ShapeName="DownhillRightTileShape" />
    <SolidityShape CategoryName="TopSolid" ShapeName="TopSolidTileShape" />
    <SolidityShape CategoryName="TopSolidMid" ShapeName="TopSolidMidTileShape" />
    <SolidityShape CategoryName="UpCeiling" ShapeName="UpCeilingTileShape" />
    <SolidityShape CategoryName="DownCeiling" ShapeName="DownCeilingTileShape" />
  </Solidity>
  <Solidity Name="Climbing solidity">
    <SolidityShape CategoryName="Solid" ShapeName="SolidTileShape" />
    <SolidityShape CategoryName="Uphill" ShapeName="UphillTileShape" />
    <SolidityShape CategoryName="Downhill" ShapeName="DownhillTileShape" />
    <SolidityShape CategoryName="HalfUpLeft" ShapeName="UphillLeftTileShape" />
    <SolidityShape CategoryName="HalfUpRight" ShapeName="UphillRightTileShape" />
    <SolidityShape CategoryName="HalfDownLeft" ShapeName="DownhillLeftTileShape" />
    <SolidityShape CategoryName="HalfDownRight" ShapeName="DownhillRightTileShape" />
    <SolidityShape CategoryName="TopSolidClimbing" ShapeName="TopSolidTileShape" />
  </Solidity>
  <SourceCode Name="TileCategoryMembership.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Stores information about which categories a tile is in.
/// &lt;/summary&gt;
public abstract partial class TileCategoryMembershipBase
{
}

/// &lt;summary&gt;
/// Represents membership information in which the membership of a tile does not
/// change based on its state.
/// &lt;/summary&gt;
public partial class TileCategorySimpleMembership : TileCategoryMembershipBase
{
   private System.Collections.BitArray m_membership;

   /// &lt;summary&gt;
   /// Constructs membership information given a list of category designators.
   /// &lt;/summary&gt;
   /// &lt;param name="membership"&gt;Designates the categories in which a tile is a member.&lt;/param&gt;
   public TileCategorySimpleMembership(params TileCategoryName[] membership)
   {
      m_membership = new System.Collections.BitArray((int)TileCategoryName.Count);
      foreach(TileCategoryName cat in membership)
         m_membership[(int)cat] = true;
   }

   /// &lt;summary&gt;
   /// Returns true if the tile is a member of the specified category
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This algorithm is simple and executes in O(1) time (it is not
   /// proportional to the number of tiles, number of categories, or number
   /// of memberships).&lt;/remarks&gt;
   public bool this[TileCategoryName category]
   {
      get
      {
         return m_membership[(int)category];
      }
   }
}

/// &lt;summary&gt;
/// Represents membership information for a tile whose membership changes based on
/// which frame is active.
/// &lt;/summary&gt;
public partial class TileCategoryFrameMembership : TileCategoryMembershipBase
{
   private System.Collections.BitArray[] m_frames;

   /// &lt;summary&gt;
   /// Constructs membership information for tile given all the information for the membership
   /// &lt;/summary&gt;
   /// &lt;param name="nFrameSequenceCount"&gt;The number of distinct frames the tile has&lt;/param&gt;
   /// &lt;param name="membership"&gt;A list of memberships for some or all of the tile's frames.
   /// For each category that contains one or more of the tile's frames, there should be
   /// one element in this list.&lt;/param&gt;
   /// &lt;remarks&gt;The &lt;paramref name="membership"/&gt; parameter is only a temporary object used
   /// in the process of constructing this object and is discarded when construction is
   /// complete. This is done to abbreviate the code that constructs these memberships since
   /// the number of distinct categories in which the tile's various frames are members is
   /// usually low, but there may be many distinct frames that are included in each category.
   /// This information is converted to a more optimal format during construction, which allows
   /// the code to determine if a frame is in a category without doing any searching. So the
   /// original membership data is no longer required.&lt;/remarks&gt;
   public TileCategoryFrameMembership(int nFrameSequenceCount, params TileFrameMembership[] membership)
   {
      m_frames = new System.Collections.BitArray[nFrameSequenceCount];
      for (int i=0; i&lt;(int)nFrameSequenceCount; i++)
         m_frames[i] = new System.Collections.BitArray((int)TileCategoryName.Count);

      foreach(TileFrameMembership mbr in membership)
         for (int frameIdx = 0; frameIdx &lt; mbr.frames.Length; frameIdx++)
            m_frames[mbr.frames[frameIdx]][(int)mbr.category] = true;
   }

   /// &lt;summary&gt;
   /// Returns true if the specified zero-based frame (not counter value) of the tile
   /// is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;nFrameSequenceIndex refers to the index within the list of distinct
   /// frames in the tile's animation sequence, not the counter value that corresponds
   /// to that frame. This operation is simple and will return in O(1) time (it does not
   /// depend on the number of frames, categories or memberships involved).
   /// &lt;see cref="AnimTile.FrameSequenceIndex"/&gt;&lt;/remarks&gt;
   public bool this[int nFrameSequenceIndex, TileCategoryName category]
   {
      get
      {
         return m_frames[nFrameSequenceIndex][(int)category];
      }
   }
}

/// &lt;summary&gt;
/// Defines an object that can be used to provide information to the construction of a
/// &lt;see cref="TileCategoryFrameMembership"/&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Instances of this class are not retained, but rather converted into a more optimal
/// form during the construction of the &lt;see cref="TileCategoryFrameMembership"/&gt;.&lt;/remarks&gt;
public partial struct TileFrameMembership
{
   /// &lt;summary&gt;
   /// Represents a category designated to contain one or more specific frames from an animated tile.
   /// &lt;/summary&gt;
   public TileCategoryName category;
   /// &lt;summary&gt;
   /// Represents a list of frame indexes from a tile that are to be included in a category.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Note that this refers to frame sequence index as described
   /// in &lt;see cref="AnimTile. FrameSequenceIndex"/&gt;, and not a counter value.&lt;/remarks&gt;
   public int[] frames;

   /// &lt;summary&gt;
   /// Constructs membership information given all the parameters
   /// &lt;/summary&gt;
   /// &lt;param name="category"&gt;Specifies a category that will contain one or more
   /// frames from an animated tile.&lt;/param&gt;
   /// &lt;param name="frames"&gt;Specifies the indexes of the tile's frames that will be
   /// included in this category. Note that this refers to frame sequence index as described
   /// in &lt;see cref="AnimTile. FrameSequenceIndex"/&gt;, and not a counter value.&lt;/param&gt;
   public TileFrameMembership(TileCategoryName category, int[] frames)
   {
      this.frames = frames;
      this.category = category;
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="CollisionMask.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;

/// &lt;summary&gt;
/// Defines the shape of a sprite for the purpose of collision detection with other sprites
/// &lt;/summary&gt;
/// &lt;remarks&gt;An instance of this object is associated with each sprite frame that contains any
/// sub-frames with non-zero mask alpha levels. When testing for collisions between two sprites,
/// if both sprites have a collision mask, the masks will be used to determine if "solid"
/// pixels of the two sprites overlap.&lt;/remarks&gt;
public partial class CollisionMask
{
   private int[,] m_Mask;
   private int m_Width;
   private int m_Height;
   private Point m_Origin;
   private static System.Collections.Hashtable m_RectangularMasks = new System.Collections.Hashtable(10);
	
   /// &lt;summary&gt;
   /// Create a collision mask of the specified size for a combination of the specified frames
   /// from a frameset based on the respective alpha levels of those frames.
   /// &lt;/summary&gt;
   /// &lt;param name="localBounds"&gt;A rectangle relative to the frame's origin for which the
   /// mask is generated. This is generally generated by determining the rectangle that
   /// encloses all the graphics of all the transformed frames.&lt;/param&gt;
   /// &lt;param name="frameset"&gt;Frameset containing all the frames referenced for the creation
   /// of this mask.&lt;/param&gt;
   /// &lt;param name="subFrames"&gt;Indexes of the frames to be overlayed before generating the mask.&lt;/param&gt;
   /// &lt;param name="alphas"&gt;Respective alpha values for the frames in &lt;paramref name="subFrames"/&gt;&lt;/param&gt;
   public CollisionMask(Rectangle localBounds, Frameset frameset, int[] subFrames, byte[] alphas)
   {
      m_Mask = GenerateMaskFromFrame(localBounds, frameset, subFrames, alphas);
      m_Width = localBounds.Width;
      m_Height = localBounds.Height;
      m_Origin = new Point(-localBounds.X, -localBounds.Y);
   }

   private CollisionMask(Size size)
   {
      m_Mask = new int[size.Height, (int)Math.Ceiling(size.Width / 32f)];
      for (int x = 0; x &lt; (int)(size.Width / 32); x++)
      {
         for (int y = 0; y &lt; size.Height; y++)
         {
            m_Mask[y,x] = unchecked((int)0xFFFFFFFF);
         }
      }
      if (size.Width % 32 &gt; 0)
      {
         int lastColMask = 0;
         lastColMask |= (-1) &lt;&lt; (32 - (size.Width % 32));
         int lastColIdx = (int)Math.Ceiling(size.Width / 32f)-1;
         for (int y = 0; y &lt; size.Height; y++)
         {
            m_Mask[y, lastColIdx] = lastColMask;
         }
      }
      m_Width = size.Width;
      m_Height = size.Height;
      m_Origin = new Point(0,0);
   }

   /// &lt;summary&gt;
   /// Retrieve a solid rectangular collision mask of the specified size
   /// &lt;/summary&gt;
   /// &lt;param name="size"&gt;Size of the mask&lt;/param&gt;
   /// &lt;returns&gt;A rectangular masks is used when testing a collision
   /// between a sprite that has a mask and a sprite that doesn't.
   /// Once a rectangualar mask is generated, it is cached and returned for
   /// all requests for a mask of the same size. These
   /// masks are generally based on the solidity size of the sprite that
   /// does not have the mask (mask alpha level = 0).&lt;/returns&gt;
   public static CollisionMask GetRectangularMask(Size size)
   {
      CollisionMask result = m_RectangularMasks[size] as CollisionMask;
      if (result != null)
         return result;
      m_RectangularMasks[size] = result = new CollisionMask(size);
      return result;
   }

   /// &lt;summary&gt;
   /// Determine if this mask is colliding with the specified target mask
   /// &lt;/summary&gt;
   /// &lt;param name="target"&gt;Mask to test against&lt;/param&gt;
   /// &lt;param name="offsetX"&gt;Horizontal offset from this mask's position to the target mask's position&lt;/param&gt;
   /// &lt;param name="offsetY"&gt;Vertical offset from this mask's position to the target mask's position&lt;/param&gt;
   /// &lt;returns&gt;True if solid bits in the masks collide when positioned at the specified offset&lt;/returns&gt;
   public bool TestCollisionWith(CollisionMask target, int offsetX, int offsetY)
   {
      offsetX += m_Origin.X - target.m_Origin.X;
      offsetY += m_Origin.Y - target.m_Origin.Y;

      if ((offsetY &gt;= m_Height) || (offsetY &lt;= -target.m_Height) ||
         (offsetX &gt;= m_Width) || (offsetX &lt;= -target.m_Width))
         return false;

      int maxY;
      int myMinY, targetMinY;
      if (offsetY &gt; 0)
      {
         myMinY = offsetY;
         targetMinY = 0;
         if (target.m_Height &gt;= m_Height - offsetY)
            maxY = m_Height - offsetY;
         else
            maxY = target.m_Height;
      }
      else
      {
         myMinY = 0;
         targetMinY = -offsetY;
         if (m_Height &gt;= target.m_Height + offsetY)
            maxY = target.m_Height + offsetY;
         else
            maxY = m_Height;
      }

      int maxX;
      int myMinX, targetMinX;
      if (offsetX &gt; 0)
      {
         myMinX = offsetX;
         targetMinX = 0;
         if (target.m_Width &gt;= m_Width - offsetX)
            maxX = m_Width - offsetX;
         else
            maxX = target.m_Width;
      }
      else
      {
         myMinX = 0;
         targetMinX = -offsetX;
         if (m_Width &gt;= target.m_Width + offsetX)
            maxX = target.m_Width + offsetX;
         else
            maxX = m_Width;
      }

      for(int y=0; y &lt; maxY; y++)
      {
         for(int x=0; x &lt; maxX; x+=32)
         {
            int myColIdx = (int)((x+myMinX)/32);
            int myColOff = myMinX % 32;
            int targetColIdx = (int)((x+targetMinX)/32);
            int targetColOff = targetMinX % 32;
            int myMask = m_Mask[y+myMinY,myColIdx] &lt;&lt; myColOff;
            int targetMask = target.m_Mask[y+targetMinY,targetColIdx] &lt;&lt; targetColOff;
            if (myColOff != 0)
            {
               if (myColIdx + 1 &lt; m_Mask.GetUpperBound(1))
                  myMask |= (m_Mask[y+myMinY,myColIdx+1] &gt;&gt; (32-myColOff)) &amp;
                     ~(unchecked((int)0x80000000) &gt;&gt; (31-myColOff));
            }
            else if (targetColOff != 0)
            {
               if (targetColIdx + 1 &lt; target.m_Mask.GetUpperBound(1))
                  targetMask |= (target.m_Mask[y+targetMinY,targetColIdx+1] &gt;&gt; (32-targetColOff)) &amp;
                     ~(unchecked((int)0x80000000) &gt;&gt; (31-targetColOff));
            }
            if ((myMask &amp; targetMask) != 0)
               return true;
         }
      }
      return false;
   }

   private static int[,] GenerateMaskFromFrame(Rectangle rcBound, Frameset frameset, int[] subFrames, byte[] alphas)
   {
      BitmapData bmpData;
      int[] pixels;

      using (Bitmap bmpSingle = new Bitmap(rcBound.Width, rcBound.Height, PixelFormat.Format32bppArgb))
      {
         int maskColumns = (int)Math.Ceiling(bmpSingle.Width / 32f);
         int[,] arbt = new int[bmpSingle.Height, maskColumns];
         using (Graphics gfxSingle = Graphics.FromImage(bmpSingle))
         {
            gfxSingle.CompositingMode = CompositingMode.SourceCopy;
            gfxSingle.PixelOffsetMode = PixelOffsetMode.Half;

            for (int subFrameIdx = 0; subFrameIdx &lt; subFrames.Length; subFrameIdx++)
            {
               int subFrame = subFrames[subFrameIdx];
               gfxSingle.Clear(Color.Transparent);
               Frame SFrame = frameset[subFrame];

               Bitmap bmpGfxSheet = (Bitmap)Project.Resources.GetObject(SFrame.GraphicSheetTexture.Name);
               PointF[] corners = new PointF[] {
                  new PointF(SFrame.Corners[0].X - rcBound.X, SFrame.Corners[0].Y - rcBound.Y),
                  new PointF(SFrame.Corners[3].X - rcBound.X, SFrame.Corners[3].Y - rcBound.Y),
                  new PointF(SFrame.Corners[1].X - rcBound.X, SFrame.Corners[1].Y - rcBound.Y)};
               gfxSingle.DrawImage(bmpGfxSheet, corners, SFrame.SourceRect, GraphicsUnit.Pixel);
               bmpData = bmpSingle.LockBits(new Rectangle(Point.Empty, rcBound.Size), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
               pixels = new int[bmpSingle.Height * Math.Abs(bmpData.Stride) / 4];
               System.Runtime.InteropServices.Marshal.Copy(bmpData.Scan0, pixels, 0, bmpSingle.Height * Math.Abs(bmpData.Stride) / 4);
               bmpSingle.UnlockBits(bmpData);
               for (int rowIdx = 0; rowIdx &lt; bmpSingle.Height; rowIdx++)
               {
                  for (int pixIdx = 0; pixIdx &lt; bmpSingle.Width; pixIdx++)
                  {
                     if (Color.FromArgb(pixels[rowIdx * bmpData.Stride / 4 + pixIdx]).A &gt; alphas[subFrameIdx])
                        arbt[rowIdx, pixIdx / 32] |= 1 &lt;&lt; (31 - (pixIdx % 32));
                  }
               }
            }
         }
         return arbt;
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="KeyboardState.cs" IsCustomObject="false">
    <Text>using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;

public interface IKeyboard
{
   void Poll();
   bool IsKeyDown(Key key);
   Key GetFirstKey();
}

/// &lt;summary&gt;
/// Identifies a key on the keyboard.
/// &lt;/summary&gt;
public enum Key
{
   None = 0,
   Backspace,
   Tab,
   Enter,
   Pause,
   CapsLock,
   Escape,
   Space,
   PageUp,
   PageDown,
   End,
   Home,
   Left,
   Up,
   Right,
   Down,
   PrintScreen,
   Insert,
   Delete,
   Digit0,
   Digit1,
   Digit2,
   Digit3,
   Digit4,
   Digit5,
   Digit6,
   Digit7,
   Digit8,
   Digit9,
   A,
   B,
   C,
   D,
   E,
   F,
   G,
   H,
   I,
   J,
   K,
   L,
   M,
   N,
   O,
   P,
   Q,
   R,
   S,
   T,
   U,
   V,
   W,
   X,
   Y,
   Z,
   LWindow,
   RWindow,
   ContextMenu,
   NumPad0,
   NumPad1,
   NumPad2,
   NumPad3,
   NumPad4,
   NumPad5,
   NumPad6,
   NumPad7,
   NumPad8,
   NumPad9,
   NumPadMultiply,
   NumPadAdd,
   NumPadEnter,
   NumPadSubtract,
   NumPadDecimal,
   NumPadDivide,
   F1,
   F2,
   F3,
   F4,
   F5,
   F6,
   F7,
   F8,
   F9,
   F10,
   F11,
   F12,
   NumLock,
   ScrollLock,
   LShift,
   RShift,
   LControl,
   RControl,
   LAlt,
   RAlt,
   SemiColon,
   Equal,
   Comma,
   Minus,
   Period,
   Slash,
   Backtick,
   LeftBracket,
   BackSlash,
   RightBracket,
   Quote
}

public partial class KeyboardState : IKeyboard
{
   IKeyboard kbImpl;
   
   public KeyboardState()
   {
      if (Environment.OSVersion.Platform == PlatformID.Unix)
         kbImpl = new XKeyboard();
      else
         kbImpl = new WinKeyboard();
   }
   
   public bool IsKeyDown(Key key)
   {
      return kbImpl.IsKeyDown(key);
   }
   
   public Key GetFirstKey()
   {
      return kbImpl.GetFirstKey();
   }
   
   public void Poll()
   {
      kbImpl.Poll();
   }
   
   public bool this[Key key]
   {
      get
      {
         return IsKeyDown(key);
      }
   }
}

/// &lt;summary&gt;
/// Represents the current state of all keys on the keyboard.
/// &lt;/summary&gt;
public partial class WinKeyboard : IKeyboard
{
   private byte[] keyMap = new byte[] {
      /*None =*/ 0,
      /*Backspace =*/ 0x08,
      /*Tab = */0x09,
      /*Enter = */0x0D,
      /*Pause = */0x13,
      /*CapsLock = */0x14,
      /*Escape = */0x1B,
      /*Space = */0x20,
      /*PageUp = */0x21,
      /*PageDown = */0x22,
      /*End = */0x23,
      /*Home = */0x24,
      /*Left = */0x25,
      /*Up = */0x26,
      /*Right = */0x27,
      /*Down = */0x28,
      /*PrintScreen = */0x2C,
      /*Insert = */0x2D,
      /*Delete = */0x2E,
      /*Digit0 = */0x30,
      /*Digit1 = */0x31,
      /*Digit2 = */0x32,
      /*Digit3 = */0x33,
      /*Digit4 = */0x34,
      /*Digit5 = */0x35,
      /*Digit6 = */0x36,
      /*Digit7 = */0x37,
      /*Digit8 = */0x38,
      /*Digit9 = */0x39,
      /*A = */0x41,
      /*B = */0x42,
      /*C = */0x43,
      /*D = */0x44,
      /*E = */0x45,
      /*F = */0x46,
      /*G = */0x47,
      /*H = */0x48,
      /*I = */0x49,
      /*J = */0x4A,
      /*K = */0x4B,
      /*L = */0x4C,
      /*M = */0x4D,
      /*N = */0X4E,
      /*O = */0X4F,
      /*P = */0X50,
      /*Q = */0X51,
      /*R = */0X52,
      /*S = */0X53,
      /*T = */0X54,
      /*U = */0X55,
      /*V = */0X56,
      /*W = */0X57,
      /*X = */0X58,
      /*Y = */0X59,
      /*Z = */0X5A,
      /*LWindow = */0x5B,
      /*RWindow = */0x5C,
      /*ContextMenu = */0x5D,
      /*NumPad0 = */0x60,
      /*NumPad1 = */0x61,
      /*NumPad2 = */0x62,
      /*NumPad3 = */0x63,
      /*NumPad4 = */0x64,
      /*NumPad5 = */0x65,
      /*NumPad6 = */0x66,
      /*NumPad7 = */0x67,
      /*NumPad8 = */0x68,
      /*NumPad9 = */0x69,
      /*NumPadMultiply = */0x6A,
      /*NumPadAdd = */0x6B,
      /*NumPadEnter = */0x6C,
      /*NumPadSubtract = */0x6D,
      /*NumPadDecimal = */0x6E,
      /*NumPadDivide = */0x6F,
      /*F1 = */0x70,
      /*F2 = */0x71,
      /*F3 = */0x72,
      /*F4 = */0x73,
      /*F5 = */0x74,
      /*F6 = */0x75,
      /*F7 = */0x76,
      /*F8 = */0x77,
      /*F9 = */0x78,
      /*F10 = */0x79,
      /*F11 = */0x7A,
      /*F12 = */0x7B,
      /*NumLock = */0x90,
      /*ScrollLock = */0x91,
      /*LShift = */0xA0,
      /*RShift = */0xA1,
      /*LControl = */0xA2,
      /*RControl = */0xA3,
      /*LAlt = */0xA4,
      /*RAlt = */0xA5,
      /*SemiColon = */0xBA,
      /*Equal = */0xBB,
      /*Comma = */0xBC,
      /*Minus = */0xBD,
      /*Period = */0xBE,
      /*Slash = */0xBF,
      /*Backtick = */0xC0,
      /*LeftBracket = */0xDB,
      /*BackSlash = */0xDC,
      /*RightBracket = */0xDD,
      /*Quote = */0xDE
   };

   [DllImport("user32.dll")]
   private static extern bool GetKeyboardState(byte[] lpKeyState);

   private byte[] keyStates = new byte[256];

   /// &lt;summary&gt;
   /// Gets or sets the state of the specified key on the keyboard.
   /// &lt;/summary&gt;
   /// &lt;param name="key"&gt;Which key is affected.&lt;/param&gt;
   /// &lt;returns&gt;True if the key is pressed of false if it is not pressed.&lt;/returns&gt;
   public bool this[Key key]
   {
      get
      {
         return IsKeyDown(key);
      }
   }

   /// &lt;summary&gt;
   /// Get the currently pressed key.  If more than one key is pressed, get the first one.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;&lt;see cref="Key.None"/&gt; is returned if no key is pressed.&lt;/returns&gt;
   public Key GetFirstKey()
   {
      foreach (Key specificKey in new Key[] {
         Key.LControl, Key.RControl, Key.LShift, Key.RShift,
         Key.NumPadEnter})
         if (this[specificKey])
            return specificKey;

      foreach (Key k in System.Enum.GetValues(typeof(Key)))
         if (this[k]) return k;
      return Key.None;
   }
   
   public bool IsKeyDown(Key key)
   {
      return 0 != (keyStates[keyMap[(int)key]] &amp; 0x80);
   }
   
   public void Poll()
   {
      GetKeyboardState(keyStates);
   }
}

class XKeyboard : IKeyboard
{
   private enum KeySym
   {
      None = 0,
      Space = 0x20,
      Quote = 0x27,
      Comma = 0x2c,
      Minus = 0x2d,
      Period = 0x2e,
      Slash = 0x2f,
      Digit0 = 0x30,
      Digit1,
      Digit2,
      Digit3,
      Digit4,
      Digit5,
      Digit6,
      Digit7,
      Digit8,
      Digit9,
      SemiColon = 0x3b,
      Equal = 0x3d,
      A = 0x41,
      B,
      C,
      D,
      E,
      F,
      G,
      H,
      I,
      J,
      K,
      L,
      M,
      N,
      O,
      P,
      Q,
      R,
      S,
      T,
      U,
      V,
      W,
      X,
      Y,
      Z,
      LeftBracket = 0x5b,
      Backslash,
      RightBracket,
      Grave = 0x60,
      PrintScreen = 0xfd1d,
      Backspace = 0xff08,
      Tab = 0xff09,
      Enter = 0xff0d,
      Pause = 0xff13,
      ScrollLock = 0xff14,
      SysRq = 0xff15,
      Escape = 0xff1b,
      Home = 0xff50,
      Left,
      Up,
      Right,
      Down,
      PageUp,
      PageDown,
      End,
      Insert = 0xff63,
      Menu = 0xff67,
      Break = 0xff6b,
      NumLock = 0xff7f,
      KeyPadEnter = 0xff8d,
      KeyPadAsterisk = 0xffaa,
      KeyPadPlus = 0xffab,
      KeyPadMinus = 0xffad,
      KeyPadDot = 0xffae,
      KeyPadSlash = 0xffaf,
      KeyPad0 = 0xffb0,
      KeyPad1,
      KeyPad2,
      KeyPad3,
      KeyPad4,
      KeyPad5,
      KeyPad6,
      KeyPad7,
      KeyPad8,
      KeyPad9,
      F1 = 0xffbe,
      F2,
      F3,
      F4,
      F5,
      F6,
      F7,
      F8,
      F9,
      F10,
      F11,
      F12,
      LeftShift = 0xffe1,
      RightShift = 0xffe2,
      LeftCtrl = 0xffe3,
      RightCtrl = 0xffe4,
      CapsLock = 0xffe5,
      LeftAlt = 0xffe9,
      RightAlt = 0xffea,
      LeftSuper = 0xffeb, // aka Left Windows Key
      RightSuper = 0xffec, // aka Right Windows Key
      Delete = 0xffff
   }

   private readonly KeySym[] keyMap = new KeySym[] {
   /*None =*/ KeySym.None,
   /*Backspace =*/ KeySym.Backspace,
   /*Tab = */KeySym.Tab,
   /*Enter = */KeySym.Enter,
   /*Pause = */KeySym.Pause,
   /*CapsLock = */KeySym.CapsLock,
   /*Escape = */KeySym.Escape,
   /*Space = */KeySym.Space,
   /*PageUp = */KeySym.PageUp,
   /*PageDown = */KeySym.PageDown,
   /*End = */KeySym.End,
   /*Home = */KeySym.Home,
   /*Left = */KeySym.Left,
   /*Up = */KeySym.Up,
   /*Right = */KeySym.Right,
   /*Down = */KeySym.Down,
   /*PrintScreen = */KeySym.PrintScreen,
   /*Insert = */KeySym.Insert,
   /*Delete = */KeySym.Delete,
   /*Digit0 = */KeySym.Digit0,
   /*Digit1 = */KeySym.Digit1,
   /*Digit2 = */KeySym.Digit2,
   /*Digit3 = */KeySym.Digit3,
   /*Digit4 = */KeySym.Digit4,
   /*Digit5 = */KeySym.Digit5,
   /*Digit6 = */KeySym.Digit6,
   /*Digit7 = */KeySym.Digit7,
   /*Digit8 = */KeySym.Digit8,
   /*Digit9 = */KeySym.Digit9,
   /*A = */KeySym.A,
   /*B = */KeySym.B,
   /*C = */KeySym.C,
   /*D = */KeySym.D,
   /*E = */KeySym.E,
   /*F = */KeySym.F,
   /*G = */KeySym.G,
   /*H = */KeySym.H,
   /*I = */KeySym.I,
   /*J = */KeySym.J,
   /*K = */KeySym.K,
   /*L = */KeySym.L,
   /*M = */KeySym.M,
   /*N = */KeySym.N,
   /*O = */KeySym.O,
   /*P = */KeySym.P,
   /*Q = */KeySym.Q,
   /*R = */KeySym.R,
   /*S = */KeySym.S,
   /*T = */KeySym.T,
   /*U = */KeySym.U,
   /*V = */KeySym.V,
   /*W = */KeySym.W,
   /*X = */KeySym.X,
   /*Y = */KeySym.Y,
   /*Z = */KeySym.Z,
   /*LWindow = */KeySym.LeftSuper,
   /*RWindow = */KeySym.RightSuper,
   /*ContextMenu = */KeySym.Menu,
   /*NumPad0 = */KeySym.KeyPad0,
   /*NumPad1 = */KeySym.KeyPad1,
   /*NumPad2 = */KeySym.KeyPad2,
   /*NumPad3 = */KeySym.KeyPad3,
   /*NumPad4 = */KeySym.KeyPad4,
   /*NumPad5 = */KeySym.KeyPad5,
   /*NumPad6 = */KeySym.KeyPad6,
   /*NumPad7 = */KeySym.KeyPad7,
   /*NumPad8 = */KeySym.KeyPad8,
   /*NumPad9 = */KeySym.KeyPad9,
   /*NumPadMultiply = */KeySym.KeyPadAsterisk,
   /*NumPadAdd = */KeySym.KeyPadPlus,
   /*NumPadEnter = */KeySym.KeyPadEnter,
   /*NumPadSubtract = */KeySym.KeyPadMinus,
   /*NumPadDecimal = */KeySym.KeyPadDot,
   /*NumPadDivide = */KeySym.KeyPadSlash,
   /*F1 = */KeySym.F1,
   /*F2 = */KeySym.F2,
   /*F3 = */KeySym.F3,
   /*F4 = */KeySym.F4,
   /*F5 = */KeySym.F5,
   /*F6 = */KeySym.F6,
   /*F7 = */KeySym.F7,
   /*F8 = */KeySym.F8,
   /*F9 = */KeySym.F9,
   /*F10 = */KeySym.F10,
   /*F11 = */KeySym.F11,
   /*F12 = */KeySym.F12,
   /*NumLock = */KeySym.NumLock,
   /*ScrollLock = */KeySym.ScrollLock,
   /*LShift = */KeySym.LeftShift,
   /*RShift = */KeySym.RightShift,
   /*LControl = */KeySym.LeftCtrl,
   /*RControl = */KeySym.RightCtrl,
   /*LAlt = */KeySym.LeftAlt,
   /*RAlt = */KeySym.RightAlt,
   /*SemiColon = */KeySym.SemiColon,
   /*Equal = */KeySym.Equal,
   /*Comma = */KeySym.Comma,
   /*Minus = */KeySym.Minus,
   /*Period = */KeySym.Period,
   /*Slash = */KeySym.Slash,
   /*Backtick = */KeySym.Grave,
   /*LeftBracket = */KeySym.LeftBracket,
   /*BackSlash = */KeySym.Backslash,
   /*RightBracket = */KeySym.RightBracket,
   /*Quote = */KeySym.Quote
   };
   [DllImport("libX11")]
   private static extern IntPtr XOpenDisplay(string display_name);
   [DllImport("libX11")]
   private static extern void XQueryKeymap(IntPtr display, System.UInt32[] keys);
   [DllImport("libX11")]
   private static extern IntPtr XGetKeyboardMapping(IntPtr display, byte first_keycode, int keycode_count, out int keysyms_per_keycode);
   [DllImport("libX11")]
   private static extern void XDisplayKeycodes(IntPtr display, out int min_keycodes, out int max_keycodes);
   [DllImport("libX11")]
   private static extern IntPtr XFree(IntPtr data);

   private System.Collections.Generic.Dictionary&lt;KeySym, byte&gt; symbolMap;
   private KeySym[] revSymbolMap;
   private System.Collections.Generic.Dictionary&lt;KeySym, Key&gt; revKeyMap;
   private IntPtr display;
   private System.UInt32[] currentKeys = new System.UInt32[8];

   public XKeyboard()
   {
      display = XOpenDisplay(null);
      GetKeyboardMap();
   }

   private void GetKeyboardMap()
   {
      int minkey, maxkey;
      int keysyms_per_keycode;
      XDisplayKeycodes(display, out minkey, out maxkey);
      int count = maxkey - minkey + 1;
      IntPtr kmap_ptr = XGetKeyboardMapping(display, (byte)minkey, count, out keysyms_per_keycode);
      int[] kmap = new int[keysyms_per_keycode * count];
      System.Runtime.InteropServices.Marshal.Copy(kmap_ptr, kmap, 0, count * keysyms_per_keycode);
      XFree(kmap_ptr);

      symbolMap = new System.Collections.Generic.Dictionary&lt;KeySym, byte&gt;();
      revSymbolMap = new KeySym[256];
      for (int i = 0; i &lt; count * keysyms_per_keycode; i++)
      {
         byte keyCode = (byte)(i / keysyms_per_keycode + minkey);
         int keySym = kmap[i];
         if (keySym == 0)
            continue;
         if ((System.Enum.IsDefined(typeof(KeySym), keySym)))
         {
            KeySym symbol = (KeySym)keySym;
            if (!symbolMap.ContainsKey(symbol))
               symbolMap[symbol] = keyCode;
            if (revSymbolMap[keyCode] == 0)
               revSymbolMap[keyCode] = symbol;
         }
      }
      foreach (KeySym sym in Enum.GetValues(typeof(KeySym)))
         if (!symbolMap.ContainsKey(sym))
            symbolMap[sym] = 0;
      revKeyMap = new System.Collections.Generic.Dictionary&lt;KeySym, Key&gt;();
      foreach (Key k in Enum.GetValues(typeof(Key)))
      {
         revKeyMap[keyMap[(int)k]] = k;
      }
   }

   public void Poll()
   {
      XQueryKeymap(display, currentKeys);
   }

   public bool IsKeyDown(Key key)
   {
      return this[keyMap[(int)key]];
   }

   public bool this[Key key]
   {
      get
      {
         return IsKeyDown(key);
      }
   }

   private bool this[KeySym key]
   {
      get
      {
         byte keyCode = symbolMap[key];
         return 0 != ((currentKeys[(keyCode &gt;&gt; 5)] &gt;&gt; (keyCode % 32)) &amp; 1);
      }
   }

   public Key GetFirstKey()
   {
      for (int i = 0; i &lt; currentKeys.Length; i++)
      {
         if (currentKeys[i] != 0)
         {
            uint val = currentKeys[i];
            int bit;
            for (bit = 0; 0 == ((val &gt;&gt; bit) &amp; 1); bit++)
               ;
            return revKeyMap[revSymbolMap[(byte)((i &lt;&lt; 5) | bit)]];
         }
      }
      return Key.None;
   }
}</Text>
  </SourceCode>
  <SourceCode Name="MapBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;

/// &lt;summary&gt;
/// Base class for all maps.
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class MapBase
{
   protected Display m_Display;
   /// &lt;summary&gt;
   /// Stores the type of the map that was previously the current map.
   /// &lt;/summary&gt;
   /// &lt;value&gt;A &lt;see cref="System.Type"/&gt; referring to the type of the previously
   /// active map if any existed, or a null reference if there was none.&lt;/value&gt;
   /// &lt;remarks&gt;This is set by &lt;see cref="GeneralRules.SwitchToMap"/&gt; and used by
   /// &lt;see cref="GeneralRules.ReturnToPreviousMap"/&gt;.&lt;/remarks&gt;
   public Type m_CameFromMapType = null;
   private ViewLayout viewLayout = ViewLayout.Single;
   private static byte currentViewIndex = 0;
   /// &lt;summary&gt;
   /// Stores a set of arbitrary boolean/flag values that can be used for any purpose
   /// on each map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Technically this value can be used to store any data that will
   /// fit in a 32-bit integer, but it's designed to be used with functions in
   /// &lt;see cref="GeneralRules"/&gt; to store individually accessible bits. These
   /// can be set with &lt;see cref="GeneralRules.SetMapFlag"/&gt; and checked with
   /// &lt;see cref="GeneralRules.IsMapFlagOn"/&gt;.&lt;/remarks&gt;
   public int MapFlags = 0;

   /// &lt;summary&gt;
   /// Constructs a new map and links it to the display.
   /// &lt;/summary&gt;
   /// &lt;param name="Disp"&gt;Display object on which the map will be drawn&lt;/param&gt;
   public MapBase(Display Disp)
   {
      m_Display = Disp;
   }

   /// &lt;summary&gt;
   /// Draws all the layers of this map in the current view.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;To draw all layers for all views, see &lt;see cref="DrawAllViews"/&gt;.
   /// &lt;seealso cref="CurrentView"/&gt;
   /// &lt;seealso cref="CurrentViewIndex"/&gt;&lt;/remarks&gt;
   protected abstract void Draw();

   /// &lt;summary&gt;
   /// Execute the rules of each layer in the map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This executes all the rules for all the plans and active sprites for all layers
   /// in the map. See &lt;see cref="ExecuteRules"/&gt; for information on overiding this.&lt;/remarks&gt;
   public abstract void ExecuteRulesInternal();

   /// &lt;summary&gt;
   /// Allows customization of the way &lt;see cref="ExecuteRulesInternal"/&gt; is called.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The default implementation simply calls ExecuteRulesInternal,
   /// but a partial class on the class derived from this base class may
   /// override this behavior and call ExecuteRulesInternal conditionally.&lt;/remarks&gt;
   public virtual void ExecuteRules() { ExecuteRulesInternal(); }

   /// &lt;summary&gt;
   /// Scroll all layers to the specified coordinates after calculating relative scroll rates
   /// &lt;/summary&gt;
   /// &lt;param name="position"&gt;New coordinate. int.MinValue indicates no scrolling on this axis.&lt;/param&gt;
   public abstract void Scroll(Point position);

   /// &lt;summary&gt;
   /// Return the left scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginLeft
   {
      get;
   }
   /// &lt;summary&gt;
   /// Return the top scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginTop
   {
      get;
   }
   /// &lt;summary&gt;
   /// Return the right scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginRight
   {
      get;
   }
   /// &lt;summary&gt;
   /// Return the bottom scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginBottom
   {
      get;
   }

   /// &lt;summary&gt;
   /// Gets or sets the current arrangement of views within the display.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By changing this you can affect the number and arrangement of views
   /// that are being managed by the map and its layers. Activating a multi-view layout
   /// will cause the layers to maintain multiple scroll positions, one for each view.
   /// And when a layer is scrolled, it will only be scrolled for the current view (as
   /// indicated by &lt;see cref="CurrentViewIndex"/&gt;.  The number of views must not exceed
   /// the maximum set in the project and stored in &lt;see cref="Project.MaxViews"/&gt;.
   /// The view layout can be set from a rule function by calling
   /// &lt;see cref="GeneralRules.SetViewLayout"/&gt;, and the current view can be changed with
   /// &lt;see cref="GeneralRules.CurrentView"/&gt;.
   /// &lt;seealso cref="CurrentView"/&gt;
   /// &lt;seealso cref="CurrentViewIndex"/&gt;
   /// &lt;seealso cref="GetView"/&gt;
   /// &lt;/remarks&gt;
   public ViewLayout ViewLayout
   {
      get
      {
         return viewLayout;
      }
      set
      {
         if (value == ViewLayout.FourCorners)
            if (Project.MaxViews &lt; 4)
            {
               System.Diagnostics.Debug.Fail("Attempted to use 4-corner view with max views less than 4");
               return;
            }
         if ((value == ViewLayout.TopBottom) || (value == ViewLayout.LeftRight))
            if (Project.MaxViews &lt; 2)
            {
               System.Diagnostics.Debug.Fail("Attempted to use double view with max views less than 2");
               return;
            }
         viewLayout = value;
      }
   }

   /// &lt;summary&gt;
   /// Retrieve the area within the display that the current view occupies.
   /// &lt;/summary&gt;
   /// &lt;param name="viewNumber"&gt;Number from 0 to &lt;see cref="Project.MaxViews"/&gt;-1 specifying
   /// which view to retrieve.&lt;/param&gt;
   /// &lt;returns&gt;Rectangle containing the area on the display object occupied by the view.&lt;/returns&gt;
   /// &lt;remarks&gt;Views are numbered in reading order, left to right and top to bottom.
   /// &lt;seealso cref="ViewLayout"/&gt;
   /// &lt;seealso cref="CurrentView"/&gt;
   /// &lt;seealso cref="CurrentViewIndex"/&gt;
   /// &lt;/remarks&gt;
   public Rectangle GetView(int viewNumber)
   {
      Rectangle result = TotalView;
      switch (viewLayout)
      {
         case ViewLayout.Single:
            return result;
         case ViewLayout.TopBottom:
            result.Height /= 2;
         switch (viewNumber)
         {
            case 0:
               return result;
            default:
               result.Y += TotalView.Height / 2;
               return result;
         }
         case ViewLayout.LeftRight:
            result.Width /= 2;
         switch(viewNumber)
         {
            case 0:
               return result;
            default:
               result.X += TotalView.Width / 2;
               return result;
         }
         default:
            result.Width /= 2;
            result.Height /= 2;
         switch(viewNumber)
         {
            case 0:
               return result;
            case 1:
               result.X += TotalView.Width / 2;
               return result;
            case 2:
               result.Y += TotalView.Height / 2;
               return result;
            default:
               result.X += TotalView.Width / 2;
               result.Y += TotalView.Height / 2;
               return result;
         }
      }
   }

   /// &lt;summary&gt;
   /// Returns the rectangle for the currently active view within the map's total view area
   /// &lt;seealso cref="GetView"/&gt;
   /// &lt;/summary&gt;
   public Rectangle CurrentView
   {
      get
      {
         return GetView(CurrentViewIndex);
      }
   }

   /// &lt;summary&gt;
   /// Which view is currently being processed (0 to &lt;see cref="Project.MaxViews"/&gt; - 1)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;
   /// This can be retrieved and set from rule functions by using
   /// &lt;see cref="GeneralRules.CurrentView"/&gt;.
   /// &lt;seealso cref="ViewLayout"/&gt;
   /// &lt;/remarks&gt;
   public byte CurrentViewIndex
   {
      get
      {
         return currentViewIndex;
      }
      set
      {
         if ((value &gt;= 0) &amp;&amp; (value &lt; Project.MaxViews))
            currentViewIndex = value;
         else
            System.Diagnostics.Debug.Fail("Bad CurrentViewIndex value ignored");
      }
   }

   /// &lt;summary&gt;
   /// Draws all layers in the map on all views according to the map's current ViewLayout
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each layer is drawn according to its respective scroll position in the view.
   /// currentViewIndex is reset to 0 after this function called.
   /// &lt;seealso cref="MapBase.ViewLayout"/&gt;&lt;/remarks&gt;
   public void DrawAllViews()
   {
      switch(viewLayout)
      {
         case ViewLayout.Single:
            currentViewIndex = 0;
            Draw();
            break;
         case ViewLayout.TopBottom:
         case ViewLayout.LeftRight:
            for (currentViewIndex = 0; currentViewIndex &lt; 2; currentViewIndex++)
               Draw();
            currentViewIndex = 0;
            break;
         case ViewLayout.FourCorners:
            for (currentViewIndex = 0; currentViewIndex &lt; 4; currentViewIndex++)
               Draw();
            currentViewIndex = 0;
            break;
      }
   }

   /// &lt;summary&gt;
   /// Returns the entire view area for this map (including all sub-views if multiple views exist)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The total view area is based on the size of the display, which depends on the
   /// display mode setting of the project. Changing this is not supported.&lt;/remarks&gt;
   public virtual Rectangle TotalView
   {
      get
      {
         return m_Display.DisplayRectangle;
      }
      set
      {
         System.Diagnostics.Debug.Assert(System.Drawing.Rectangle.Intersect(m_Display.DisplayRectangle, value).Equals(value));
      }
   }

   /// &lt;summary&gt;
   /// Returns the display on which this map is drawn.
   /// &lt;/summary&gt;
   public Display Display
   {
      get
      {
         return m_Display;
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="SpriteCollection.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Categorizes / collects sprite instances
/// &lt;/summary&gt;
/// &lt;remarks&gt;Instances of this class are used both to represent the entire collection
/// of sprites contained within a layer &lt;see cref="LayerBase.m_Sprites"/&gt; as well
/// as sub-collections of these sprites divided into individual categories, exposed by
/// &lt;see cref="LayerBase.m_SpriteCategories"/&gt;. Sprite collections can contain static
/// and dynamic sprites. For more information about this distinction, see remarks in
/// &lt;see cref="staticSize"/&gt;.&lt;/remarks&gt;
[Serializable()]
public partial class SpriteCollection : System.Collections.CollectionBase
{
   /// &lt;summary&gt;
   /// Indicates the initial size of this collection, and the size below which
   /// sprites are never removed.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;para&gt;Sprites defined in the map editor are considered "static" and will always
   /// exist, although they may be inactive (invisible and excluded from processing rules).
   /// But sprites can also be added at runtime. These are referred to as "dynamic"
   /// sprites. When a dynamic sprite is added, it is appended to the end of the main
   /// sprite collection for the layer (&lt;see cref="LayerBase.m_Sprites"/&gt;) as well as
   /// all categories designated to include the specified sprite type (which are also
   /// &lt;see cref="SpriteCollection"/&gt; objects). So each sprite collection has a segment
   /// (at the beginning) of static sprites and a segment at the end (beginning at index
   /// determined by staticSize) containing zero or more dynamic sprites.&lt;/para&gt;
   /// &lt;para&gt;This value, then, represents the number of static sprites in the collection
   /// (whether it be a layer's main collection or a category within the layer).
   /// It is used to ensure that no static sprite can ever be completely removed from
   /// the collection because these should always be available for activation. And sprites
   /// in the collection beyond this range are the only sprites that need to be considered
   /// for removal after a layer's rules are done executing. Only the range of dynamic
   /// sprites will be checked for inactive sprites. Inactive dynamic sprites are removed
   /// from all the categories in which they were a member.&lt;/para&gt;
   /// &lt;seealso cref="SpriteBase.TileAddSprite"/&gt;
   /// &lt;seealso cref="SpriteBase.AddSpriteHere"/&gt;
   /// &lt;seealso cref="PlanBase.AddSpriteAtPlan"/&gt;
   /// &lt;seealso cref="Clean"/&gt;&lt;/remarks&gt;
   public readonly int staticSize;

   /// &lt;summary&gt;
   /// Defines a maximum sprite collection size to help ensure dynamic sprites are not
   /// "leaking" into the system without getting cleaned up.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.&lt;/remarks&gt;
   public const int maxCollectionSize = 100;

   /// &lt;summary&gt;
   /// Constructs a sprite collection given a list of all the sprites it should contain.
   /// &lt;/summary&gt;
   /// &lt;param name="sprites"&gt;Array of sprite instances contained in the collection.&lt;/param&gt;
   public SpriteCollection(params SpriteBase[] sprites)
   {
      InnerList.AddRange(sprites);
      staticSize = sprites.Length;
   }

   /// &lt;summary&gt;
   /// Return a sprite instance from the collection given its 0-based index.
   /// &lt;/summary&gt;
   public SpriteBase this[int index]
   {
      get
      {
         return (SpriteBase)InnerList[index];
      }
   }

   /// &lt;summary&gt;
   /// Add a dynamic sprite to the end of this sprite collection.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to be added&lt;/param&gt;
   /// &lt;returns&gt;Index of the new sprite in the collection&lt;/returns&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.
   /// This function will fail if the number of sprites in the collection is already equal to
   /// or greater than &lt;see cref="maxCollectionSize"/&gt;.&lt;/remarks&gt;
   public int Add(SpriteBase sprite)
   {
      if (List.Count &gt;= maxCollectionSize)
         throw new ApplicationException("A sprite collection has reached the maximum size of " + maxCollectionSize.ToString() + ". This may be a result of failing to properly clean up dynamic sprites, or it may be the result of a maximum that is too small. To increase it, change the value associated with maxCollectionSize in SpriteCollection.cs");
      return List.Add(sprite);
   }

   protected override void OnRemove( int index, Object value )  
   {
      if (index &lt; staticSize)
         throw new ApplicationException("Attempted to remove from a collection a sprite that was not dynamically added");
   }

   /// &lt;summary&gt;
   /// Determine the index of the specified sprite in the collection.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to search for&lt;/param&gt;
   /// &lt;returns&gt;Zero-based index of the sprite if found, otherwise -1.&lt;/returns&gt;
   public int IndexOf(SpriteBase sprite)
   {
      return List.IndexOf(sprite);
   }

   /// &lt;summary&gt;
   /// Remove the specified sprite from this collection.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to be removed. This must be a dynamic sprite&lt;/param&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.
   /// An error will occur if an attempt is made to remove a static sprite.&lt;/remarks&gt;
   public void Remove(SpriteBase sprite)
   {
      List.Remove(sprite);
   }

   /// &lt;summary&gt;
   /// Remove inactive dynamic sprites from the collection
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.
   /// This function is called after all rules for a layer are processed
   /// (at the end of &lt;see cref="LayerBase.ProcessSprites"/&gt;).&lt;/remarks&gt;
   public void Clean()
   {
      for (int index=staticSize; index &lt; List.Count; index++)
      {
         SpriteBase sprite = this[index];
         if (!sprite.isActive)
         {
            RemoveAt(index);
            sprite.RemoveFromCategories();
         }
      }
   }
}

/// &lt;summary&gt;
/// Enumerates only the currently active sprites on a layer
/// &lt;/summary&gt;
public class ActiveSpriteEnumerator : System.Collections.IEnumerator
{
   private System.Collections.IEnumerator SpriteEnumerator;

   public ActiveSpriteEnumerator(SpriteCollection sprites)
   {
      SpriteEnumerator = sprites.GetEnumerator();
   }

   #region IEnumerator Members

   /// &lt;summary&gt;
   /// Re-start enumerating active sprites.
   /// &lt;/summary&gt;
   public void Reset()
   {
      SpriteEnumerator.Reset();
   }

   /// &lt;summary&gt;
   /// The current sprite being enumerated.
   /// &lt;/summary&gt;
   public object Current
   {
      get
      {
         return SpriteEnumerator.Current;
      }
   }

   /// &lt;summary&gt;
   /// Move to the next active sprite in the collection.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if another active sprite exists, or false if there are no more.&lt;/returns&gt;
   public bool MoveNext()
   {
      bool result;
      while ((result = SpriteEnumerator.MoveNext()) &amp;&amp; (!((SpriteBase)Current).isActive))
         ;
      return result;
   }

   #endregion
}
</Text>
  </SourceCode>
  <SourceCode Name="About.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

/// &lt;summary&gt;
/// About dialog displayed from game's help menu.
/// &lt;/summary&gt;
public partial class frmAbout : System.Windows.Forms.Form
{
   private System.Windows.Forms.Button btnOK;
   private System.Windows.Forms.Label lblHeader;
   private System.Windows.Forms.Label lblSGDK2;
   private System.Windows.Forms.LinkLabel llbURL;
   private System.Windows.Forms.Label lblCredits;
   private System.Windows.Forms.TextBox txtCredits;
	/// &lt;summary&gt;
	/// Required designer variable.
	/// &lt;/summary&gt;
	private System.ComponentModel.Container components = null;

	public frmAbout()
	{
		//
		// Required for Windows Form Designer support
		//
		InitializeComponent();

      txtCredits.Text = Project.GameCredits;
	}

	/// &lt;summary&gt;
	/// Clean up any resources being used.
	/// &lt;/summary&gt;
	protected override void Dispose( bool disposing )
	{
		if( disposing )
		{
			if(components != null)
			{
				components.Dispose();
			}
		}
		base.Dispose( disposing );
	}

	#region Windows Form Designer generated code
	/// &lt;summary&gt;
	/// Required method for Designer support - do not modify
	/// the contents of this method with the code editor.
	/// &lt;/summary&gt;
	private void InitializeComponent()
	{
      this.btnOK = new System.Windows.Forms.Button();
      this.lblHeader = new System.Windows.Forms.Label();
      this.lblSGDK2 = new System.Windows.Forms.Label();
      this.llbURL = new System.Windows.Forms.LinkLabel();
      this.lblCredits = new System.Windows.Forms.Label();
      this.txtCredits = new System.Windows.Forms.TextBox();
      this.SuspendLayout();
      // 
      // btnOK
      // 
      this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
      this.btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
      this.btnOK.Location = new System.Drawing.Point(206, 168);
      this.btnOK.Name = "btnOK";
      this.btnOK.Size = new System.Drawing.Size(72, 24);
      this.btnOK.TabIndex = 0;
      this.btnOK.Text = "OK";
      // 
      // lblHeader
      // 
      this.lblHeader.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.lblHeader.Location = new System.Drawing.Point(8, 8);
      this.lblHeader.Name = "lblHeader";
      this.lblHeader.Size = new System.Drawing.Size(272, 16);
      this.lblHeader.TabIndex = 1;
      this.lblHeader.Text = "This game was created with:";
      // 
      // lblSGDK2
      // 
      this.lblSGDK2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.lblSGDK2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
      this.lblSGDK2.Location = new System.Drawing.Point(8, 24);
      this.lblSGDK2.Name = "lblSGDK2";
      this.lblSGDK2.Size = new System.Drawing.Size(272, 16);
      this.lblSGDK2.TabIndex = 2;
      this.lblSGDK2.Text = "Scrolling Game Development Kit 2";
      this.lblSGDK2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // llbURL
      // 
      this.llbURL.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.llbURL.Location = new System.Drawing.Point(8, 40);
      this.llbURL.Name = "llbURL";
      this.llbURL.Size = new System.Drawing.Size(272, 16);
      this.llbURL.TabIndex = 3;
      this.llbURL.TabStop = true;
      this.llbURL.Text = "http://sgdk2.sf.net/";
      this.llbURL.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.Link_Clicked);
      // 
      // lblCredits
      // 
      this.lblCredits.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.lblCredits.Location = new System.Drawing.Point(8, 64);
      this.lblCredits.Name = "lblCredits";
      this.lblCredits.Size = new System.Drawing.Size(272, 16);
      this.lblCredits.TabIndex = 4;
      this.lblCredits.Text = "Game Credits:";
      // 
      // txtCredits
      // 
      this.txtCredits.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
         | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.txtCredits.Location = new System.Drawing.Point(8, 80);
      this.txtCredits.Multiline = true;
      this.txtCredits.Name = "txtCredits";
      this.txtCredits.ReadOnly = true;
      this.txtCredits.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
      this.txtCredits.Size = new System.Drawing.Size(270, 80);
      this.txtCredits.TabIndex = 5;
      this.txtCredits.Text = "";
      // 
      // frmAbout
      // 
      this.AcceptButton = this.btnOK;
      this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
      this.ClientSize = new System.Drawing.Size(290, 199);
      this.Controls.Add(this.txtCredits);
      this.Controls.Add(this.lblCredits);
      this.Controls.Add(this.llbURL);
      this.Controls.Add(this.lblSGDK2);
      this.Controls.Add(this.lblHeader);
      this.Controls.Add(this.btnOK);
      this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
      this.Name = "frmAbout";
      this.Text = "About ";
      this.ResumeLayout(false);

   }
	#endregion

   private void Link_Clicked(object sender, System.Windows.Forms.LinkLabelLinkClickedEventArgs e)
   {
      System.Diagnostics.Process.Start(((LinkLabel)sender).Text);
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="Joystick.cs" IsCustomObject="false">
    <Text>using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

public partial class Joystick
{
   #region Embedded Types
   [Flags()]
   private enum JoystickFlags
   {
      JOY_RETURNX = 0x1,
      JOY_RETURNY = 0x2,
      JOY_RETURNZ = 0x4,
      JOY_RETURNR = 0x8,
      JOY_RETURNU = 0x10,
      JOY_RETURNV = 0x20,
      JOY_RETURNPOV = 0x40,
      JOY_RETURNBUTTONS = 0x80,
      JOY_RETURNALL = (JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | JOY_RETURNPOV | JOY_RETURNBUTTONS)
   }

   [StructLayout(LayoutKind.Sequential)]
   private struct JOYCAPS
   {
      public UInt16 wMid;
      public UInt16 wPid;
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
      public string szPname;
      public Int32 wXmin;
      public Int32 wXmax;
      public Int32 wYmin;
      public Int32 wYmax;
      public Int32 wZmin;
      public Int32 wZmax;
      public Int32 wNumButtons;
      public Int32 wPeriodMin;
      public Int32 wPeriodMax;
      public Int32 wRmin;
      public Int32 wRmax;
      public Int32 wUmin;
      public Int32 wUmax;
      public Int32 wVmin;
      public Int32 wVmax;
      public Int32 wCaps;
      public Int32 wMaxAxes;
      public Int32 wNumAxes;
      public Int32 wMaxButtons;
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
      public string szRegKey;
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
      public string szOEMVxD;
   }

   [StructLayout(LayoutKind.Sequential)]
   private struct JOYINFOEX
   {
      public UInt32 dwSize;
      [MarshalAs(UnmanagedType.I4)]
      public JoystickFlags dwFlags;
      public Int32 dwXpos;
      public Int32 dwYpos;
      public Int32 dwZpos;
      public Int32 dwRpos;
      public Int32 dwUpos;
      public Int32 dwVpos;
      public UInt32 dwButtons;
      public UInt32 dwButtonNumber;
      public Int32 dwPOV;
      public UInt32 dwReserved1;
      public UInt32 dwReserved2;
   }
   #endregion

   #region Private Members
   private int deviceNum;

   private JOYCAPS joyCaps;
   private JOYINFOEX joyInfo;
   #endregion

   [DllImport("Winmm.dll")]
   private static extern UInt32 joyGetDevCaps(Int32 uJoyID, out JOYCAPS pjc, Int32 cbjc);
   [DllImport("Winmm.dll")]
   private static extern UInt32 joyGetPosEx(Int32 uJoyID, out JOYINFOEX pji);

   /// &lt;summary&gt;
   /// Returns the number of joysticks available on the system.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;A number from 0 to 16&lt;/returns&gt;
   public static int GetDeviceCount()
   {
      JOYCAPS joyCaps = new JOYCAPS();
      int count = 0;
      if ((Environment.OSVersion.Platform == PlatformID.Win32NT) ||
          (Environment.OSVersion.Platform == PlatformID.Win32Windows))
      {
         for (count = 0; count &lt; 16; count++)
         {
            if (0 != joyGetDevCaps(count, out joyCaps, Marshal.SizeOf(joyCaps)))
               return count;
         }
      }
      return count;
   }

   /// &lt;summary&gt;
   /// Create an object which can be used to acces information about the specified
   /// joystick number.
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNum"&gt;Number from 0 to 15 indicating a joystick number&lt;/param&gt;
   public Joystick(int deviceNum)
   {
      this.deviceNum = deviceNum;
      if ((Environment.OSVersion.Platform == PlatformID.Win32NT) ||
          (Environment.OSVersion.Platform == PlatformID.Win32Windows))
      {
         if (0 != joyGetDevCaps(deviceNum, out joyCaps, Marshal.SizeOf(joyCaps)))
            throw new InvalidOperationException("Failed to access specified joystick");
      }
   }

   /// &lt;summary&gt;
   /// Read all data from the device associated with this Joystick into the
   /// Position, POVAngle and Button properties.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Buttons are retrieved by accessing the Joystick's indexer
   /// property&lt;/remarks&gt;
   /// &lt;example&gt;
   /// if (myJoy[0])
   /// {
   ///    // button 0 is pressed
   /// }
   /// &lt;/example&gt;
   public void Read()
   {
      joyInfo.dwSize = (UInt32)Marshal.SizeOf(joyInfo);
      joyInfo.dwFlags = JoystickFlags.JOY_RETURNALL;
      if ((Environment.OSVersion.Platform == PlatformID.Win32NT) ||
          (Environment.OSVersion.Platform == PlatformID.Win32Windows))
         joyGetPosEx(deviceNum, out joyInfo);
   }

   /// &lt;summary&gt;
   /// The position of the joystick's x-axis input during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   public int XPosition
   {
      get
      {
         return joyInfo.dwXpos;
      }
   }

   /// &lt;summary&gt;
   /// The position of the joystick's y-axis input during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   public int YPosition
   {
      get
      {
         return joyInfo.dwYpos;
      }
   }

   /// &lt;summary&gt;
   /// The position of the joystick's z-axis input during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   public int ZPosition
   {
      get
      {
         return joyInfo.dwZpos;
      }
   }

   /// &lt;summary&gt;
   /// The position of the joystick's rudder input during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   public int RPosition
   {
      get
      {
         return joyInfo.dwRpos;
      }
   }

   /// &lt;summary&gt;
   /// The position of the joystick's u-axis input during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   public int UPosition
   {
      get
      {
         return joyInfo.dwUpos;
      }
   }

   /// &lt;summary&gt;
   /// The position of the joystick's v-axis input during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   public int VPosition
   {
      get
      {
         return joyInfo.dwVpos;
      }
   }

   /// &lt;summary&gt;
   /// The position of the joystick's POV control during the last call to &lt;see cref="Read"/&gt;,
   /// represented as a number between 0 and 35900 in hundredths of degrees
   /// &lt;/summary&gt;
   public int POVAngle
   {
      get
      {
         return joyInfo.dwPOV;
      }
   }

   /// &lt;summary&gt;
   /// Determines which buttons were pressed during the last call to &lt;see cref="Read"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="buttonNum"&gt;A number from 0 to 31 specifying a button number&lt;/param&gt;
   /// &lt;returns&gt;True if the button is pressed, or False otherwise.&lt;/returns&gt;
   public bool this[byte buttonNum]
   {
      get
      {
         if (buttonNum &gt;= 32)
            throw new ArgumentException("Invalid button number", "buttonNum");
         return 0 != (joyInfo.dwButtons &amp; (1 &lt;&lt; buttonNum));
      }
   }

   /// &lt;summary&gt;
   /// Returns a string identifying the joystick in plain text
   /// &lt;/summary&gt;
   public string Name
   {
      get
      {
         return joyCaps.szPname;
      }
   }

   /// &lt;summary&gt;
   /// Returns the minimum value of &lt;see cref="XPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MinimumX
   {
      get
      {
         return joyCaps.wXmin;
      }
   }

   /// &lt;summary&gt;
   /// Returns the maximum value of &lt;see cref="XPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MaximumX
   {
      get
      {
         return joyCaps.wXmax;
      }
   }

   /// &lt;summary&gt;
   /// Returns the minimum value of &lt;see cref="YPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MinimumY
   {
      get
      {
         return joyCaps.wYmin;
      }
   }

   /// &lt;summary&gt;
   /// Returns the maximum value of &lt;see cref="YPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MaximumY
   {
      get
      {
         return joyCaps.wYmax;
      }
   }

   /// &lt;summary&gt;
   /// Returns the minimum value of &lt;see cref="ZPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MinimumZ
   {
      get
      {
         return joyCaps.wZmin;
      }
   }

   /// &lt;summary&gt;
   /// Returns the maximum value of &lt;see cref="ZPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MaximumZ
   {
      get
      {
         return joyCaps.wZmax;
      }
   }

   /// &lt;summary&gt;
   /// Returns the minimum value of &lt;see cref="RPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MinimumR
   {
      get
      {
         return joyCaps.wRmin;
      }
   }

   /// &lt;summary&gt;
   /// Returns the maximum value of &lt;see cref="RPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MaximumR
   {
      get
      {
         return joyCaps.wRmax;
      }
   }

   /// &lt;summary&gt;
   /// Returns the minimum value of &lt;see cref="UPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MinimumU
   {
      get
      {
         return joyCaps.wUmin;
      }
   }

   /// &lt;summary&gt;
   /// Returns the maximum value of &lt;see cref="UPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MaximumU
   {
      get
      {
         return joyCaps.wUmax;
      }
   }

   /// &lt;summary&gt;
   /// Returns the minimum value of &lt;see cref="VPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MinimumV
   {
      get
      {
         return joyCaps.wVmin;
      }
   }

   /// &lt;summary&gt;
   /// Returns the maximum value of &lt;see cref="VPosition"/&gt;.
   /// &lt;/summary&gt;
   public int MaximumV
   {
      get
      {
         return joyCaps.wVmax;
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="GeneralRules.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.ComponentModel;
using System.Diagnostics;

/// &lt;summary&gt;
/// Implements rules common to sprites and plans
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class GeneralRules
{
   protected static SaveUnit saveUnit = null;
   protected static System.Collections.Hashtable memorySaveSlots = new System.Collections.Hashtable();
   protected static System.Random randomGen = new System.Random();
   protected static long fpsStartTime;
   protected static long fpsFrameCount;

   /// &lt;summary&gt;
   /// Contains the last sprite created with &lt;see cref="PlanBase.AddSpriteAtPlan"/&gt;,
   /// &lt;see cref="SpriteBase.TileAddSprite"/&gt; or &lt;see cref="SpriteBase.AddSpriteHere"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This reference can be used to initialize various properties of a sprite
   /// that was just created. It can't be used to set parameters on the sprite that are
   /// specific to that sprite type unless it is cast to the correct type (which is not
   /// supported in the interface for defining rules). That should be done from within
   /// the sprite's rules by checking for a specific parameter value (like "IsInitialized")
   /// being 0 or 1, for example.&lt;/remarks&gt;
   public static SpriteBase lastCreatedSprite;

   /// &lt;summary&gt;
   /// Retrieves the layer that contains this object.
   /// &lt;/summary&gt;
   public abstract LayerBase ParentLayer
   {
      get;
   }

   /// &lt;summary&gt;
   /// Limit the frame rate of the game to the specified number of frames per second.  Call this only once per frame.
   /// &lt;/summary&gt;
   /// &lt;param name="fps"&gt;Frames per second.&lt;/param&gt;
   /// &lt;remarks&gt;If this is called twice per frame, the effect would be to
   /// limit the frame rate to half the specified value, and more calls will
   /// make the game run even slower.&lt;/remarks&gt;
   [Description("Limit the frame rate of the game to the specified number of frames per second.  Call this only once per frame.")]
   public virtual void LimitFrameRate(int fps)
   {
      long freq;
      long frame;
      freq = System.Diagnostics.Stopwatch.Frequency;
      frame = System.Diagnostics.Stopwatch.GetTimestamp();
      while ((frame - fpsStartTime) * fps &lt; freq * fpsFrameCount)
      {
         int sleepTime = (int)((fpsStartTime * fps + freq * fpsFrameCount - frame * fps) * 1000 / (freq * fps));
         if (sleepTime &gt; 0) System.Threading.Thread.Sleep(sleepTime);
         frame = System.Diagnostics.Stopwatch.GetTimestamp();
      }
      if (++fpsFrameCount &gt; fps)
      {
         fpsFrameCount = 0;
         fpsStartTime = frame;
      }
   }


   /// &lt;summary&gt;
   /// Write a string to the debug output without moving to the next line.
   /// &lt;/summary&gt;
   /// &lt;param name="Label"&gt;String value to write to the debug output&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;By default, the debug output is reset each frame, so in order to
   /// force a piece of debug output to be visible long enough to see it, it must be
   /// logged during each frame.&lt;/para&gt;
   /// &lt;para&gt;Debug output is drawn to the display in &lt;see cref="GameForm.OutputDebugInfo"/&gt;,
   /// which is called from the main game loop in &lt;see cref="GameForm.Run"/&gt;. The behavior
   /// of debug output can be customized there.&lt;/para&gt;
   /// &lt;para&gt;This function is often used in conjunction with &lt;see cref="LogDebugValue"/&gt;
   /// because LogDebugLabel leaves the position of the output on the same line allowing for a
   /// value to be appended to the end of the line.&lt;/para&gt;
   /// &lt;seealso cref="LogDebugValue"/&gt;
   /// &lt;seealso cref="GameForm.debugText"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;This will add the string "Counter 1 value: " followed by the value
   /// contained in a counter named "Counter 1" to the debug output for the current frame.
   /// &lt;code&gt;LogDebugLabel("Counter 1 value: ");
   /// LogDebugValue(Counter.Counter_1.CurrentValue);&lt;/code&gt;&lt;/example&gt;
   [Description("Write a string to the debug output without moving to the next line"),
   System.Diagnostics.Conditional("DEBUG")]
   public virtual void LogDebugLabel(string Label)
   {
      Project.GameWindow.debugText.Write(Label);
   }

   /// &lt;summary&gt;
   /// Write a number to the debug output and move to the next line.
   /// &lt;/summary&gt;
   /// &lt;param name="DebugValue"&gt;Specifies a numeric value to be logged to the output&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;By default, the debug output is reset each frame, so in order to
   /// force a piece of debug output to be visible long enough to see it, it must be
   /// logged during each frame.&lt;/para&gt;
   /// &lt;para&gt;Debug output is drawn to the display in &lt;see cref="GameForm.OutputDebugInfo"/&gt;,
   /// which is called from the main game loop in &lt;see cref="GameForm.Run"/&gt;. The behavior
   /// of debug output can be customized there.&lt;/para&gt;
   /// &lt;para&gt;This function is often used in conjunction with &lt;see cref="LogDebugLabel"/&gt;
   /// because &lt;see cref="LogDebugLabel"/&gt; leaves the position of the output on the same
   /// line allowing for a label to be provided on the same line as the value.&lt;/para&gt;
   /// &lt;seealso cref="LogDebugLabel"/&gt;
   /// &lt;seealso cref="GameForm.debugText"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;See &lt;see cref="LogDebugLabel"/&gt; for an example&lt;/example&gt;
   [Description("Write a number to the debug output and move to the next line"),
   System.Diagnostics.Conditional("DEBUG")]
   public virtual void LogDebugValue(int DebugValue)
   {
      Project.GameWindow.debugText.WriteLine(DebugValue.ToString());
   }

   /// &lt;summary&gt;
   /// Sets a different map as the one to be drawn on the game display.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies the map to switch to.&lt;/param&gt;
   /// &lt;param name="UnloadCurrent"&gt;If true, the current map will be unloaded first&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;&lt;paramref name="MapType"/&gt; specifies a type of map rather than a specific
   /// instance of a map.
   /// This accomplishes two things. First, it allows the function to switch to a map that hasn't
   /// been initialized/created yet, thus allowing the map instance to only be created when
   /// necessary, and not before switching to it. This can improve performance because an instance
   /// of each map doesn't have to be created during game initialization. Secondly, it allows maps
   /// to be unloaded so that maps instances that don't need to remember their state can be released,
   /// freeing up whatever memory they were occupying. Each map defined in the IDE is compiled/generated as its
   /// own class when the project is compiled, and each map instance becomes an instance of the
   /// class. This conceivably allows multiple instances of the same map to exist, but this is not
   /// fully supported by default in the code provided with this environment.&lt;/para&gt;
   /// &lt;para&gt;When &lt;paramref name="UnloadCurrent"/&gt; is true, the old map will be unloaded while
   /// switching to the new map, freeing up the memory used by the old map's sprites and tiles
   /// (if no other references to the map exist). Eliminating the map from memory also reduces the
   /// amount of data that would be written to a saved game file. Finally it causes the map to be
   /// recreated/reset when returning to it in the future. When &lt;paramref name="UnloadCurrent"/&gt;
   /// is false, the map is retained and re-used next time the game switches to the map, which
   /// means the state of all the tiles and sprites will be remembered as they were when switching
   /// away from the map.&lt;/para&gt;
   /// &lt;seealso cref="UnloadMap"/&gt;&lt;/remarks&gt;
   [Description("Sets a different map as the one to be drawn on the game display.  If UnloadCurrent is true, the current map will be unloaded first (which causes it to be recreated/reset when returning to it).")]
   public virtual void SwitchToMap([Editor("MapType", "UITypeEditor")] Type MapType, bool UnloadCurrent)
   {
      System.Type source = Project.GameWindow.CurrentMap.GetType();
      if (UnloadCurrent)
         Project.GameWindow.UnloadMap(source);
      (Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(MapType)).m_CameFromMapType = source;
   }

   /// &lt;summary&gt;
   /// Return to the map that was active before the last &lt;see cref="SwitchToMap"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="UnloadCurrent"&gt;If true, the current map will be unloaded first&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;Each map remembers where the game was before it became the current map.
   /// Calling this will return to that map, recreating it if it was unloaded. Since each
   /// map can only remember one previous map, you can't keep multiple instances of the same
   /// map in the history. For example, if you switch from a map called "Level1" to "Level2"
   /// then to "Level3" and then back to "Level2", you won't be able to return back to
   /// Level1 using ReturnToPreviousMap. Level2 would switch back to Level3 each time
   /// ReturnToPreviousMap is called.&lt;/para&gt;
   /// &lt;para&gt;If there is no previous map to return to, this function will have no effect.&lt;/para&gt;
   /// &lt;para&gt;See &lt;see cref="SwitchToMap"/&gt; for more information about unloading maps.&lt;/para&gt;&lt;/remarks&gt;
   [Description("Return to the map that was active before the last SwitchToMap.  If UnloadCurrent is true, the current map will be unloaded first (which causes it to be recreated/reset when returning to it).")]
   public virtual void ReturnToPreviousMap(bool UnloadCurrent)
   {
      System.Type source = Project.GameWindow.CurrentMap.m_CameFromMapType;
      if (source == null)
         source = Project.GameWindow.CurrentMap.GetType();
      if (UnloadCurrent)
         Project.GameWindow.UnloadMap(Project.GameWindow.CurrentMap.GetType());
      Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(source);
   }

   /// &lt;summary&gt;
   /// Determines if there is a previous map to return to.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if calling &lt;see cref="ReturnToPreviousMap"/&gt; will have any effect,
   /// false otherwise.&lt;/returns&gt;
   [Description("Determines if there is a previous map to return to.")]
   public virtual bool CanReturnToPreviousMap()
   {
      return Project.GameWindow.CurrentMap.m_CameFromMapType != null;
   }

   /// &lt;summary&gt;
   /// Unloads the specified map.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies the class of map whose instance will be unloaded if
   /// it is loaded.&lt;/param&gt;
   /// &lt;remarks&gt;Unloading a map will free up any memory used by its tiles and sprites if no other
   /// code is referencing it. It also excludes it from the saved game data if the game is saved,
   /// which can significantly reduce the size of a saved game file. Finally it causes the tiles
   /// and sprites to be recreated/reset next time the map is loaded (switched to).
   /// &lt;seealso cref="SwitchToMap"/&gt;
   /// &lt;seealso cref="ReturnToPreviousMap"/&gt;&lt;/remarks&gt;
   [Description("Unloads the specified map, which will force it to be recreated/reset next time it is used.")]
   public virtual void UnloadMap([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      Project.GameWindow.UnloadMap(MapType);
   }

   /// &lt;summary&gt;
   /// Includes a specified set of objects in the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Include"&gt;Specifies a category of objects that should be included&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;There are many functions that can be used to specify what elements should be
   /// included in a saved game file.  This function is designed for setting up a very rough
   /// outline of what kind of data will be included in the save file.
   /// After this is called, the selection can be fine tuned with further calls to
   /// related functions in the See Also list.  If nothing is included in the &lt;see cref="SaveUnit"/&gt;
   /// before &lt;see cref="SaveGame"/&gt; is called, everything will be included by default.
   /// See &lt;see cref="SaveUnitInclusion"/&gt; for details about the meaning of different categories.&lt;/para&gt;
   /// &lt;para&gt;By including maps in a &lt;see cref="SaveUnit"/&gt;, all the tiles and sprites are remembered exactly as they
   /// were when the game was saved, but only for those maps that are included.  Maps that aren't
   /// included will be reset to their initial state next time they become active after loading
   /// that game.&lt;/para&gt;
   /// &lt;para&gt;By including only counters (and not maps) in a &lt;see cref="SaveUnit"/&gt;, you can store some
   /// general information in a &lt;see cref="SaveUnit"/&gt; in a significantly smaller file, and use that information
   /// to re-initialize some general properties of the game. For example, the number of lives
   /// and inventory owned by the player (assuming inventory is stored in counters) might be
   /// adequate for some games (if you don't have to worry about items being available again
   /// on maps that have been reset to their initial state, or if you have few enough items that
   /// you can initialize them based on counter values).&lt;/para&gt;
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Includes a specified set of objects in the SaveUnit that will be saved with the next call to SaveGame")]
   public virtual void IncludeInSaveUnit(SaveUnitInclusion Include)
   {
      if (saveUnit == null)
         saveUnit = new SaveUnit();

      switch (Include)
      {
         case SaveUnitInclusion.AllMaps:
            saveUnit.Maps = Project.GameWindow.LoadedMaps;
            saveUnit.AllMaps = true;
            break;
         case SaveUnitInclusion.AllCounters:
            {
               saveUnit.Counters = new System.Collections.ArrayList();
               System.Reflection.PropertyInfo[] counterProps = typeof(Counter).GetProperties(
                  System.Reflection.BindingFlags.Public |
                  System.Reflection.BindingFlags.GetProperty |
                  System.Reflection.BindingFlags.Static);
               foreach (System.Reflection.PropertyInfo counterProp in counterProps)
                  saveUnit.Counters.Add(new CounterRef((Counter)counterProp.GetValue(null, null)));
            }
            break;
         case SaveUnitInclusion.WhichMapIsCurrent:
            saveUnit.CurrentMapType = Project.GameWindow.CurrentMap.GetType();
            break;
         case SaveUnitInclusion.WhichMapIsOverlaid:
            if (Project.GameWindow.OverlayMap == null)
               saveUnit.OverlayMapType = typeof(System.DBNull);
            else
               saveUnit.OverlayMapType = Project.GameWindow.OverlayMap.GetType();
            break;
         case SaveUnitInclusion.PlayerOptions:
            saveUnit.PlayerOptions = Project.GameWindow.Players;
            break;
      }
   }

   /// &lt;summary&gt;
   /// Include the specified counter in the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Counter"&gt;Specifies a counter whose value will be saved when &lt;see cref="SaveGame"/&gt;
   /// is called.&lt;/param&gt;
   /// &lt;remarks&gt;If you want to include only a few select counters in a &lt;see cref="SaveUnit"/&gt;,
   /// you can use this function to select them before calling &lt;see cref="SaveGame"/&gt;.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Include the specified counter in the SaveUnit that will be saved with the next call to SaveGame")]
   public virtual void IncludeCounterInSaveUnit(Counter Counter)
   {
      if (saveUnit == null)
      {
         saveUnit = new SaveUnit();
      }
      if (saveUnit.Counters == null)
      {
         saveUnit.Counters = new System.Collections.ArrayList();
         saveUnit.Counters.Add(new CounterRef(Counter));
         return;
      }
      foreach (CounterRef cr in saveUnit.Counters)
      {
         if (cr.instance == Counter)
            return;
      }
      saveUnit.Counters.Add(Counter);
   }

   /// &lt;summary&gt;
   /// Exclude the specified counter from the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Counter"&gt;Specifies a counter to remove from the &lt;see cref="SaveUnit"/&gt;&lt;/param&gt;
   /// &lt;remarks&gt;If you want to save most counters, but exclude a few, you can call
   /// &lt;see cref="IncludeInSaveUnit"/&gt; to include all counters and then exclude a few
   /// with this function.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Exclude the specified counter from the SaveUnit that will be saved with the next call to SaveGame")]
   public virtual void ExcludeCounterFromSaveUnit(Counter Counter)
   {
      if ((saveUnit == null) || (saveUnit.Counters == null))
         return;
      for (int i = 0; i &lt; saveUnit.Counters.Count; i++)
      {
         if (((CounterRef)(saveUnit.Counters[i])).instance == Counter)
         {
            saveUnit.Counters.RemoveAt(i);
            return;
         }
      }
   }

   /// &lt;summary&gt;
   /// Include the specified map in the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map to include in the &lt;see cref="SaveUnit"/&gt;&lt;/param&gt;
   /// &lt;remarks&gt;If you only want to include a few maps in a &lt;see cref="SaveUnit"/&gt;, specify
   /// which maps to save with this function. Only loaded maps will be saved. If this function
   /// is called on a map type that refers to a map that is not loaded, it will be ignored, and
   /// the specified map type will still be reset next time it becomes active after loading
   /// the game.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Include the specified map in the SaveUnit that will be saved with the next call to SaveGame.")]
   public virtual void IncludeMapInSaveUnit([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      if (Project.GameWindow.LoadedMaps.ContainsKey(MapType))
      {
         if (saveUnit == null)
            saveUnit = new SaveUnit();
         if (saveUnit.Maps == null)
            saveUnit.Maps = new System.Collections.Hashtable();
         saveUnit.Maps[MapType] = Project.GameWindow.LoadedMaps[MapType];
      }
   }

   /// &lt;summary&gt;
   /// Remove the specified map in from the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map to exclude from the &lt;see cref="SaveUnit"/&gt;&lt;/param&gt;
   /// &lt;remarks&gt;
   /// If you want to save most maps, but not all, you can call &lt;see cref="IncludeInSaveUnit"/&gt;
   /// to include all maps, and then call this to exclude a few. Maps not included in the save
   /// unit (and maps that were not loaded when the game was saved, even if they are "included")
   /// will be reset next time they become active after loading that &lt;see cref="SaveUnit"/&gt;. Often times an
   /// overly map does not contain any important state information, so excluding an overlay map
   /// from a &lt;see cref="SaveUnit"/&gt; might be a good use of this function.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Remove the specified map in from the SaveUnit that will be saved with the next call to SaveGame.")]
   public virtual void ExcludeMapFromSaveUnit([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      if ((saveUnit == null) || (saveUnit.Maps == null))
         return;
      if (saveUnit.Maps.ContainsKey(MapType))
         saveUnit.Maps.Remove(MapType);
   }

   /// &lt;summary&gt;
   /// Save the current &lt;see cref="SaveUnit"/&gt; into the specified save slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number to uniquely identify this &lt;see cref="SaveUnit"/&gt;. If saved to a file, this number plue the ".sav" extension becomes the filename.&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If true, no file will be created; the current state of the game is stored in a "slot" in memory (and lost when the game exits). Otherwise the game data is saved to a file.&lt;/param&gt;
   /// &lt;remarks&gt;After saving the game, the &lt;see cref="SaveUnit"/&gt; is cleared so that any further inclusions
   /// will start from an empty set.  When the game is saved, the state of the maps and counters
   /// are saved in their current state rather than the state they were in when
   /// &lt;see cref="IncludeInSaveUnit"/&gt; and related functions were called. One exception to this
   /// rule is &lt;see cref="SaveUnitInclusion.WhichMapIsCurrent"/&gt;, which will store the map that
   /// was current when &lt;see cref="IncludeInSaveUnit"/&gt; was called rather than than when the
   /// game is actually saved (if these happen to be different). It's possible to save a game
   /// in a memory slot as well as a file slot. These are considered different slots and can
   /// store different save images even if they use the same number. Otherwise, if a game
   /// already exists in a particular slot, it is overwritten.
   /// &lt;seealso cref="IncludeInSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="LoadGame"/&gt;
   /// &lt;seealso cref="DeleteSave"/&gt;
   /// &lt;/remarks&gt;
   [Description("Save the current save unit into the specified save slot, and reset the save unit. If InMemory is true, no file will be created, otherwise the game is saved to a file.")]
   public virtual void SaveGame(int Slot, bool InMemory)
   {
      System.IO.Stream stm;
      if (InMemory)
         stm = new System.IO.MemoryStream();
      else
         stm = new System.IO.FileStream(System.IO.Path.Combine(
            System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"),
            System.IO.FileMode.Create, System.IO.FileAccess.Write);
      using (stm)
      {
         if (saveUnit == null)
         {
            IncludeInSaveUnit(SaveUnitInclusion.AllMaps);
            IncludeInSaveUnit(SaveUnitInclusion.AllCounters);
            IncludeInSaveUnit(SaveUnitInclusion.WhichMapIsCurrent);
            IncludeInSaveUnit(SaveUnitInclusion.WhichMapIsOverlaid);
            IncludeInSaveUnit(SaveUnitInclusion.PlayerOptions);
         }
         System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bf = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
         bf.Serialize(stm, saveUnit);
         if (InMemory)
            memorySaveSlots[Slot] = ((System.IO.MemoryStream)stm).ToArray();
         saveUnit = null;
      }
   }

   /// &lt;summary&gt;
   /// Restore the state of the objects contained in the specified save slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number that uniquely identifies which game to load&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If true, the memory slot is used, otherwise the file associated with the slot is loaded&lt;/param&gt;
   /// &lt;remarks&gt;
   /// If there is no data in the specified slot, an error occurs. Use &lt;see cref="SaveExists"/&gt;
   /// to determine if data is available to load from a particular slot.
   /// Counters that were not included in the &lt;see cref="SaveUnit"/&gt; will retain the same value they
   /// had before the game was loaded. Similarly, maps that are not included in the save
   /// unit will retain the same state they had before the game was loaded instead of
   /// being reset or loaded from the file. One exception is if
   /// &lt;see cref="SaveUnitInclusion.AllMaps"/&gt; was ever included in the &lt;see cref="SaveUnit"/&gt; (even
   /// if some maps were later excluded). In this case, all maps that were not included
   /// in the &lt;see cref="SaveUnit"/&gt; will be reset next time they are visited.
   /// &lt;seealso cref="SaveGame"/&gt;
   /// &lt;seealso cref="SaveExists"/&gt;
   /// &lt;seealso cref="DeleteSave"/&gt;
   /// &lt;/remarks&gt;
   [Description("Restore the state of the objects contained in the specified save slot. If InMemory is true, the memory slot is used, otherwise the file associated with the slot is loaded.")]
   public virtual void LoadGame(int Slot, bool InMemory)
   {
      System.IO.Stream stm;

      if (InMemory)
         stm = new System.IO.MemoryStream((byte[])memorySaveSlots[Slot], false);
      else
         stm = new System.IO.FileStream(System.IO.Path.Combine(
            System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"),
            System.IO.FileMode.Open, System.IO.FileAccess.Read);

      using (stm)
      {
         System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bf = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
         SaveUnit unit = (SaveUnit)bf.Deserialize(stm);
         if (unit.Maps != null)
         {
            if (unit.AllMaps)
               Project.GameWindow.LoadedMaps = unit.Maps;
            else
               foreach (System.Collections.DictionaryEntry de in unit.Maps)
                  Project.GameWindow.LoadedMaps[de.Key] = de.Value;
            // If sprites exist on any layer of any map whose static state cache has not
            // been initialized, initialize them now.
            foreach (MapBase mb in Project.GameWindow.LoadedMaps.Values)
            {
               // Loop through each property of each map class
               foreach (System.Reflection.PropertyInfo lpi in mb.GetType().GetProperties())
               {
                  // If the property represents a map layer
                  if (lpi.PropertyType.IsSubclassOf(typeof(LayerBase)))
                  {
                     // Retrieve the layer object
                     LayerBase l = (LayerBase)lpi.GetValue(mb, null);
                     // Loop though each sprite in the layer's sprite collection
                     foreach (SpriteBase sp in l.m_Sprites)
                     {
                        Type spriteType = sp.GetType();
                        // Get the property containing the sprite type's cached list of states
                        System.Reflection.FieldInfo statesField = spriteType.GetField("m_SpriteStates",
                           System.Reflection.BindingFlags.GetField |
                           System.Reflection.BindingFlags.NonPublic |
                           System.Reflection.BindingFlags.Static);
                        // If the sprite has not initialized its states
                        if (statesField.GetValue(sp) == null)
                        {
                           // Call the static method that initializes the sprite's states.
                           System.Reflection.MethodInfo initMethod = spriteType.GetMethod("InitializeStates",
                              System.Reflection.BindingFlags.InvokeMethod |
                              System.Reflection.BindingFlags.NonPublic |
                              System.Reflection.BindingFlags.Static);
                           initMethod.Invoke(null, new object[] { Project.GameWindow.GameDisplay });
                        }
                     }
                  }
               }
            }
         }
         if (unit.CurrentMapType != null)
            Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(unit.CurrentMapType);
         else
            Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(Project.GameWindow.CurrentMap.GetType());
         if (unit.OverlayMapType != null)
         {
            if (unit.OverlayMapType == typeof(System.DBNull))
               Project.GameWindow.OverlayMap = null;
            else
               Project.GameWindow.OverlayMap = Project.GameWindow.GetMap(unit.OverlayMapType);
         }
         else if (Project.GameWindow.OverlayMap != null)
            Project.GameWindow.OverlayMap = Project.GameWindow.GetMap(Project.GameWindow.OverlayMap.GetType());
         if (unit.PlayerOptions != null)
            Project.GameWindow.Players = unit.PlayerOptions;
         // Counters auto-magically take care of themselves via CounterRef
      }
   }

   /// &lt;summary&gt;
   /// Determines if saved game data exists in the specified slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number that uniquely identifies the slot to check&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If true, checks to see if the specified memory slot has saved
   /// game data available, otherwise checks to see if a file with the specified number
   /// exists for loading game data.&lt;/param&gt;
   /// &lt;returns&gt;True if data can be loaded from the specified slot, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;
   /// Memory slots and file slots are distinct. If a memory slot has game data in it,
   /// a file slot with the same number may not, and vice versa.  Furthermore a memory slot may
   /// have different game data stored in it than a file slot with the same number.
   /// &lt;seealso cref="LoadGame"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;
   /// &lt;seealso cref="DeleteSave"/&gt;&lt;/remarks&gt;
   [Description("Determines if saved game data exists in the specified slot.  Checks for the existence of a file if InMemory is false.")]
   public virtual bool SaveExists(int Slot, bool InMemory)
   {
      if (InMemory)
         return memorySaveSlots.ContainsKey(Slot);
      return System.IO.File.Exists(System.IO.Path.Combine(
         System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"));
   }

   /// &lt;summary&gt;
   /// Empties the specified save slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number that uniquely identifies a saved game&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If false, a file is deleted, otherwise a memory slot is cleared.&lt;/param&gt;
   /// &lt;remarks&gt;An error occurs if the specified slot is a file slot and there is no data to delete.
   /// Memory slots and file slots are distinct. If a memory slot has game data in it,
   /// a file slot with the same number may not, and vice versa.  Furthermore a memory slot may
   /// have different game data stored in it than a file slot with the same number.
   /// &lt;seealso cref="LoadGame"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;
   /// &lt;seealso cref="SaveExists"/&gt;&lt;/remarks&gt;
   [Description("Empties the specified save slot.  If InMemory is false, a file is deleted, otherwise a memory slot is cleared.")]
   public virtual void DeleteSave(int Slot, bool InMemory)
   {
      if (InMemory)
         memorySaveSlots.Remove(Slot);
      else
         System.IO.File.Delete(System.IO.Path.Combine(
            System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"));
   }

   /// &lt;summary&gt;
   /// If multiple views are visible, this determines which view is currently active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Only the currently active view is affected by functions like
   /// &lt;see cref="PlanBase.ScrollSpriteIntoView"/&gt;, and only the current view is
   /// drawn by &lt;see cref="MapBase.Draw"/&gt;. &lt;see cref="MapBase.DrawAllViews"/&gt; is called
   /// during the main loop to cycle through each visible view (changing this value)
   /// and draw it. The scope of this value is limited to the map, so setting it
   /// affects only the map containing this object.&lt;/remarks&gt;
   [Browsable(false)]
   public virtual int CurrentView
   {
      get
      {
         return ParentLayer.ParentMap.CurrentViewIndex;
      }
      set
      {
         ParentLayer.ParentMap.CurrentViewIndex = (byte)value;
      }
   }

   /// &lt;summary&gt;
   /// Sets the layout of multiple views for the current map.
   /// &lt;/summary&gt;
   /// &lt;param name="Layout"&gt;Specifies the number and arrangement of views to be activated.&lt;/param&gt;
   /// &lt;remarks&gt;The number of views designated by &lt;paramref name="Layout"/&gt; must not exceed
   /// &lt;see cref="Project.MaxViews"/&gt; defined by the project.&lt;/remarks&gt;
   [Description("Sets the layout of multiple views for the current map.")]
   public virtual void SetViewLayout(ViewLayout Layout)
   {
      ParentLayer.ParentMap.ViewLayout = Layout;
   }

   /// &lt;summary&gt;
   /// Sets the current state of a sprite based on a category and index into the category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Category containing the sprite to be affected&lt;/param&gt;
   /// &lt;param name="SpriteIndex"&gt;Zero-based index into the category, specifying a sprite&lt;/param&gt;
   /// &lt;param name="State"&gt;Numeric value referring to a state of the specified sprite.&lt;/param&gt;
   [Description("Sets the current state of a sprite based on a category and index into the category.")]
   public virtual void SetCategorySpriteState(SpriteCollection Category, int SpriteIndex, int State)
   {
      Debug.Assert(Category[SpriteIndex].isActive, "SetCategorySpriteState attempted to set the state of an inactive sprite.");
      Category[SpriteIndex].state = State;
   }

   /// &lt;summary&gt;
   /// Turn off the overlay map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This disables all drawing and rules in the overlay map.&lt;/remarks&gt;
   [Description("Turn off the overlay map. This disables all drawing and rules in the overlay map.")]
   public virtual void ClearOverlay()
   {
      Project.GameWindow.OverlayMap = null;
   }

   /// &lt;summary&gt;
   /// Set the overlay map.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map that should be loaded into the overlay&lt;/param&gt;
   /// &lt;remarks&gt;This is very similar to &lt;see cref="SwitchToMap"/&gt;, but it affects the overlay
   /// map instead of the main map.&lt;/remarks&gt;
   [Description("Set the overlay map.")]
   public virtual void SetOverlay([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      Project.GameWindow.OverlayMap = Project.GameWindow.GetMap(MapType);
   }

   /// &lt;summary&gt;
   /// Turn on or off a flag associated with the current map.
   /// &lt;/summary&gt;
   /// &lt;param name="FlagIndex"&gt;A value from 0 to 30 indicating which flag to set or clear&lt;/param&gt;
   /// &lt;param name="Value"&gt;True to set the flag or false to clear it&lt;/param&gt;
   /// &lt;remarks&gt;Each map has a built-in variable &lt;see cref="MapBase.MapFlags"/&gt; that can be used
   /// to store 30 boolean values associated with the map.  This could be used instead of counters
   /// to turn on or off major features of the map, for example, whether the map has been
   /// completed and will allow the player to exit the map without completing it. Such a task is
   /// more suited to a map flag than a counter because there must be exactly one flag per map,
   /// and the flag will automatically be available for each map that is created.
   /// &lt;seealso cref="SetTargetMapFlag"/&gt;
   /// &lt;seealso cref="IsMapFlagOn"/&gt;&lt;/remarks&gt;
   [Description("Turn on or off a flag associated with the current map.  FlagIndex must be a value from 0 through 30.")]
   public virtual void SetMapFlag(int FlagIndex, bool Value)
   {
      if (Value)
         ParentLayer.ParentMap.MapFlags |= 1 &lt;&lt; FlagIndex;
      else
         ParentLayer.ParentMap.MapFlags &amp;= ~(1 &lt;&lt; FlagIndex);
   }

   /// &lt;summary&gt;
   /// Turn on or off a flag associated with the specified map.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map whose flag will be set&lt;/param&gt;
   /// &lt;param name="FlagIndex"&gt;A value from 0 to 30 specifying which flag to set or clear&lt;/param&gt;
   /// &lt;param name="Value"&gt;True to set the flag or false to clear it&lt;/param&gt;
   /// &lt;remarks&gt;This operates like &lt;see cref="SetMapFlag"/&gt;, but can operate on any map
   /// rather than just the current map.  This could be used, for example, to set a flag that
   /// would cause all the sprites on any particular map (even if it is not the current map)
   /// to be frozen next time the player visits it, assuming all sprite definitions check
   /// the flag before allowing the sprite to move.
   /// &lt;seealso cref="SetMapFlag"/&gt;
   /// &lt;seealso cref="IsMapFlagOn"/&gt;&lt;/remarks&gt;
   [Description("Turn on or off a flag associated with the specified map. FlagIndex must be a value from 0 through 30.")]
   public virtual void SetTargetMapFlag([Editor("MapType", "UITypeEditor")] Type MapType, int FlagIndex, bool Value)
   {
      if (Value)
         Project.GameWindow.GetMap(MapType).MapFlags |= 1 &lt;&lt; FlagIndex;
      else
         Project.GameWindow.GetMap(MapType).MapFlags &amp;= ~(1 &lt;&lt; FlagIndex);
   }

   /// &lt;summary&gt;
   /// Determine if the specified map-specific flag on the current map is on.
   /// &lt;/summary&gt;
   /// &lt;param name="FlagIndex"&gt;A number from 0 to 30 specifying which flag to check&lt;/param&gt;
   /// &lt;returns&gt;True if the specified flag is set, or false if it is not.&lt;/returns&gt;
   [Description("Determine if the specified map-specific flag on the current map is on.")]
   public virtual bool IsMapFlagOn(int FlagIndex)
   {
      return ((ParentLayer.ParentMap.MapFlags &amp; (1 &lt;&lt; FlagIndex)) != 0);
   }

   /// &lt;summary&gt;
   /// Unload all maps that aren't currently visible.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This unloads all maps except the current map and the overlay map.
   /// They will be reset next time they become active.&lt;/remarks&gt;
   [Description("Unload all maps that aren't currently visible (as the current map or overlay map).")]
   public virtual void UnloadBackgroundMaps()
   {
      Project.GameWindow.UnloadBackgroundMaps();
   }

   /// &lt;summary&gt;
   /// Quit the game by closing the main window.
   /// &lt;/summary&gt;
   [Description("Quit the game by closing the main window.")]
   public virtual void QuitGame()
   {
      Project.GameWindow.Quit();
   }

   /// &lt;summary&gt;
   /// Determines if a specified key is being pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="key"&gt;Which key to check&lt;/param&gt;
   /// &lt;returns&gt;True if the specified key is currently pressed, false otherwise&lt;/returns&gt;
   [Description("Returns true if the specified key is currently pressed")]
   public virtual bool IsKeyPressed(Key key)
   {
      return Project.GameWindow.KeyboardState[key];
   }

   /// &lt;summary&gt;
   /// Return a random number within a specified range.
   /// &lt;/summary&gt;
   /// &lt;param name="Minimum"&gt;Minimum value that can be returned&lt;/param&gt;
   /// &lt;param name="Maximum"&gt;Maximum bound of the range; this value will never be returned&lt;/param&gt;
   /// &lt;returns&gt;A random integer greater than or equal to Minimum and less than Maximum.
   /// This value is based on a random seed that was generated based on the current time when
   /// the program started.&lt;/returns&gt;
   [Description("Return a random number greater than or equal to Minimum and less than Maximum.")]
   public virtual int GetRandomNumber(int Minimum, int Maximum)
   {
      return randomGen.Next(Minimum, Maximum);
   }

   /// &lt;summary&gt;
   /// Change a counter's value with a pre-defined operation.
   /// &lt;/summary&gt;
   /// &lt;param name="Operation"&gt;Specified a pre-defined operation to execute on a counter&lt;/param&gt;
   /// &lt;returns&gt;True if the counter value hit a limit, false otherwise. For an operation that
   /// stops at a limit, true will only be returned if the counter was unable to change. For an
   /// operation that loops, true indicates that the counter looped. For operators that set the
   /// counter to a limit, true is returned if the counter was already at the limit value, false
   /// otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;Counter values can be changed directly with the "=" function, but
   /// using a pre-defined operation, you can easily cause the counter to loop when
   /// it hits a limit, which is useful for counters linked to tile animations.&lt;/remarks&gt;
   [Description("Change a counter's value with a pre-defined operation. Return true if the counter hits a limit or is left unchanged.")]
   public virtual bool ChangeCounter(Counter Counter, CounterOperation Operation)
   {
      switch (Operation)
      {
         case CounterOperation.IncrementAndStop:
            if (Counter.CurrentValue &lt; Counter.MaxValue)
               Counter.CurrentValue += 1;
            else
               return true;
            return false;
         case CounterOperation.DecrementAndStop:
            if (Counter.CurrentValue &gt; Counter.MinValue)
               Counter.CurrentValue -= 1;
            else
               return true;
            return false;
         case CounterOperation.IncrementAndLoop:
            if (Counter.CurrentValue &lt; Counter.MaxValue)
            {
               Counter.CurrentValue += 1;
               return false;
            }
            Counter.CurrentValue = Counter.MinValue;
            return true;
         case CounterOperation.DecrementAndLoop:
            if (Counter.CurrentValue &gt; Counter.MinValue)
            {
               Counter.CurrentValue -= 1;
               return false;
            }
            Counter.CurrentValue = Counter.MaxValue;
            return true;
         case CounterOperation.SetToMinimum:
            if (Counter.CurrentValue == Counter.MinValue)
               return true;
            Counter.CurrentValue = Counter.MinValue;
            return false;
         case CounterOperation.SetToMaximum:
            if (Counter.CurrentValue == Counter.MaxValue)
               return true;
            Counter.CurrentValue = Counter.MaxValue;
            return false;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified mouse button is pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Button"&gt;Specifies which button to check.&lt;/param&gt;
   /// &lt;returns&gt;True if the button is pressed, false if it is not pressed.&lt;/returns&gt;
   [Description("Determines if the specified mouse button is pressed.")]
   public virtual bool IsMouseButtonPressed(System.Windows.Forms.MouseButtons Button)
   {
      return 0 != (System.Windows.Forms.Control.MouseButtons &amp; Button);
   }

   /// &lt;summary&gt;
   /// Determines if the specified mouse button is pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Button"&gt;Specifies which button to check.&lt;/param&gt;
   /// &lt;returns&gt;True if the button is pressed, false if it is not pressed.&lt;/returns&gt;
   [Description("Determines if touch was initiated or mouse was clicked this frame.")]
   public virtual bool Clicked()
   {
      return (0 != System.Windows.Forms.Control.MouseButtons) &amp;&amp;
         ((GameForm.oldMouseButtons &amp; System.Windows.Forms.Control.MouseButtons) == 0);
   }

   /// &lt;summary&gt;
   /// When the mouse drags over the display, scroll the map along with it.
   /// &lt;/summary&gt;
   [Description("When the mouse drags over the display, scroll the map along with it.")]
   public virtual void DragMap()
   {
      if (0 != (GameForm.oldMouseButtons &amp; GameForm.curMouseButtons &amp; System.Windows.Forms.MouseButtons.Left))
      {
         int mapX = (int)((ParentLayer.CurrentPosition.X - ParentLayer.AbsolutePosition.X) / ParentLayer.ScrollRate.Width);
         int mapY = (int)((ParentLayer.CurrentPosition.Y - ParentLayer.AbsolutePosition.Y) / ParentLayer.ScrollRate.Height);
         int mouseOffsetX = GameForm.curMousePosition.X - GameForm.oldMousePosition.X;
         int mouseOffsetY = GameForm.curMousePosition.Y - GameForm.oldMousePosition.Y;
         Project.GameWindow.CurrentMap.Scroll(new System.Drawing.Point(mapX + mouseOffsetX, mapY + mouseOffsetY));
      }
   }

   #region Collections
   protected static System.Collections.Specialized.HybridDictionary selectedSprites = new System.Collections.Specialized.HybridDictionary();

   /// &lt;summary&gt;
   /// Returns the sprite currently selected for the specified target name.
   /// &lt;/summary&gt;
   /// &lt;param name="TargetName"&gt;Which target name's currently selected sprite will be returned.&lt;/param&gt;
   /// &lt;returns&gt;SpriteBase object or null if no sprite is selected for the specified target.&lt;/returns&gt;
   public SpriteBase GetSelectedTargetFor(string TargetName)
   {
      if (selectedSprites.Contains(TargetName))
         return (SpriteBase)selectedSprites[TargetName];
      return null;
   }

   /// &lt;summary&gt;
   /// Selects a sprite within a collection, using a 0-based index, to be the target of &lt;see cref="SetTargetParameter"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprites"&gt;Collection from which sprite is selected&lt;/param&gt;
   /// &lt;param name="Index"&gt;0-based index within the collection of the sprite to be selected&lt;/param&gt;
   /// &lt;returns&gt;True if the specified index is within the bounds of the collection, False otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;This function is provided for compatibility; see &lt;see cref="SelectTargetSpriteFor"/&gt;.
   /// This function in equivalent to &lt;see cref="SelectTargetSpriteFor"/&gt; with an empty string as TargetName.&lt;/remarks&gt;
   [Description("Selects a sprite within a collection, using a 0-based index, to be the target of SetTargetParameter. This function is provided for compatibility; see SelectTargetSpriteFor.")]
   public virtual bool SelectTargetSprite(SpriteCollection Sprites, int Index)
   {
      return SelectTargetSpriteFor(Sprites, Index, String.Empty);
   }

   /// &lt;summary&gt;
   /// Selects a sprite within a collection, using a 0-based index, to be the target of &lt;see cref="SetTargetParameterFor"/&gt;.
   /// &lt;paramref name="TargetName"/&gt; allows any number of unique targets to be selected by assigning unique names.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprites"&gt;Collection from which sprite is selected&lt;/param&gt;
   /// &lt;param name="Index"&gt;0-based index within the collection of the sprite to be selected&lt;/param&gt;
   /// &lt;param name="TargetName"&gt;A global name (quoted string) to indicate for what this sprite is being selected&lt;/param&gt;
   /// &lt;returns&gt;True if the specified index is within the bounds of the collection, False otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;If the Index is beyond the bounds of the collection, the target reference cleared.
   /// This function is useful in conjunction with &lt;see cref="SetTargetParameterFor"/&gt; and
   /// &lt;see cref="GetTargetParameterFor"/&gt; to set properties of arbitrary sprites within a
   /// collection to trigger various behaviors based on their rules, or get properties to affect
   /// the currently executing rules based on other sprites.
   /// &lt;paramref name="TargetName"/&gt; allows you to select any number of sprites by assigning each a globally
   /// unique name to be used by any plan or sprite rules. Only one sprite can ever be associated with that
   /// target name at a time. Assigning another to that name will replace the existing target with the new
   /// one. Specify -1 for &lt;paramref name="Index"/&gt; to clear selection for the specified target.
   /// &lt;seealso cref="SelectLastCreatedSpriteFor"/&gt;
   /// &lt;seealso cref="SetTargetParameterFor"/&gt;
   /// &lt;seealso cref="GetTargetParameterFor"/&gt;
   /// &lt;seealso cref="DeactivateTargetSpriteFor"/&gt;&lt;/remarks&gt;
   [Description("Selects a sprite within a collection, using a 0-based index, to be the target of SetTargetParameterFor. TargetName allows any number of unique targets to be selected by assigning unique names.")]
   public virtual bool SelectTargetSpriteFor(SpriteCollection Sprites, int Index, string TargetName)
   {
      if ((Index &gt;= 0) &amp;&amp; (Sprites.Count &gt; Index))
      {
         selectedSprites[TargetName] = Sprites[Index];
         return true;
      }
      else
      {
         selectedSprites[TargetName] = null;
         return false;
      }
   }

   /// &lt;summary&gt;
   /// Select the most recently created sprite to be the target of &lt;see cref="SetTargetParameter"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is the same as &lt;see cref="SelectLastCreatedSpriteFor"/&gt; using an empty string
   /// as the Target Name. This function is provided for compatibility; use SelectLastCreatedSpriteFor.
   /// &lt;/remarks&gt;
   [Description("Selects the most recently created sprite to be the target of SetTargetParameter.")]
   public virtual void SelectLastCreatedSprite()
   {
      SelectLastCreatedSpriteFor(String.Empty);
   }

   /// &lt;summary&gt;
   /// Selects the most recently created sprite to be the target of &lt;see cref="SetTargetParameterFor"/&gt;
   /// or &lt;see cref="GetTargetParameterFor"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;seealso cref="SetTargetParameterFor"/&gt;
   /// &lt;seealso cref="GetTargetParameterFor"/&gt;
   /// &lt;seealso cref="SelectTargetSpriteFor"/&gt;
   /// &lt;seealso cref="DeactivateTargetSpriteFor"/&gt;&lt;/remarks&gt;
   [Description("Selects the most recently created sprite to be the target of SetTargetParameterFor.")]
   public virtual void SelectLastCreatedSpriteFor(string TargetName)
   {
      selectedSprites[TargetName] = lastCreatedSprite;
   }

   /// &lt;summary&gt;
   /// Determine if a sprite has been selected with &lt;see cref="SelectLastCreatedSpriteFor"/&gt; 
   /// or &lt;see cref="SelectTargetSpriteFor"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="TargetName"&gt;Check on whether a sprite has been selected for this target name.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;seealso cref="SelectTargetSpriteFor"/&gt;&lt;/remarks&gt;
   [Description("Determines if a sprite has been selected with SelectLastCreatedSpriteFor or SelectTargetSpriteFor.")]
   public virtual bool IsTargetSpriteSelectedFor(string TargetName)
   {
      return selectedSprites.Contains(TargetName);
   }

   /// &lt;summary&gt;
   /// Set the value of a numeric property or parameter on a sprite selected with &lt;see cref="SelectTargetSprite"/&gt; to the specified value.
   /// &lt;/summary&gt;
   /// &lt;param name="ParameterName"&gt;Name of the parameter on the target sprite that will be affected.&lt;/param&gt;
   /// &lt;param name="Value"&gt;Numeric value that will be assigned to the specified parameter&lt;/param&gt;
   /// &lt;remarks&gt;This function is provided for compatibility; see &lt;see cref="SetTargetParameterFor"/&gt;.
   /// This is equivalent to &lt;see cref="SetTargetParameterFor"/&gt; passing an empty string as Target Name.&lt;/remarks&gt;
   [Description("Set the value of a numeric property or parameter (given its name as a string) on a sprite selected with SelectTargetSprite to the specified value. This function is provided for compatibility; see SetTargetParameterFor.")]
   public virtual void SetTargetParameter(string ParameterName, int Value)
   {
      SetTargetParameterFor(ParameterName, Value, String.Empty);
   }

   /// &lt;summary&gt;
   /// Set the value of a numeric property or parameter on a sprite selected with &lt;see cref="SelectTargetSpriteFor"/&gt; to the specified value.
   /// &lt;/summary&gt;
   /// &lt;param name="ParameterName"&gt;Name of the parameter on the target sprite that will be affected.&lt;/param&gt;
   /// &lt;param name="Value"&gt;Numeric value that will be assigned to the specified parameter.&lt;/param&gt;
   /// &lt;param name="TargetName"&gt;Determines which target's currently selected sprite will be affected.&lt;/param&gt;
   /// &lt;remarks&gt;This is useful for a wide range of effects on sprites in collections. For example,
   /// after determining that some sprite in a collection is within a plan using
   /// &lt;see cref="PlanBase.GetSpriteWithin"/&gt;, you could use &lt;see cref="SelectTargetSpriteFor"/&gt; and
   /// this to set some parameter on that sprite to trigger its rules to react.
   /// Remember that ParameterName and TargetName are provided as strings,
   /// and must be quoted assuming the names are provided as literal values.
   /// &lt;seealso cref="GetTargetParameterFor"/&gt;
   /// &lt;seealso cref="SelectTargetSpriteFor"/&gt;
   /// &lt;seealso cref="SelectLastCreatedSpriteFor"/&gt;&lt;/remarks&gt;
   [Description("Set the value of a numeric property or parameter (given its name as a string) on a sprite selected with SelectTargetSpriteFor to the specified value.")]
   public virtual void SetTargetParameterFor(string ParameterName, int Value, string TargetName)
   {
      if (!selectedSprites.Contains(TargetName))
      {
         Debug.Fail("Tried to set parameter for non-existent target \"" + TargetName + "\".");
         return;
      }
      object selectedTarget = selectedSprites[TargetName];
      if (selectedTarget == null)
      {
         Debug.Fail("Tried to set parameter for target \"" + TargetName + "\" that was cleared.");
         return;
      }
      System.Reflection.PropertyInfo pi = selectedTarget.GetType().GetProperty(ParameterName);
      if (pi == null)
      {
         System.Reflection.FieldInfo fi = selectedTarget.GetType().GetField(ParameterName);
         Debug.Assert(fi != null, "Invalid property name in SetTargetParameter");
         if (fi != null)
            fi.SetValue(selectedTarget, Value);
      }
      else
         pi.SetValue(selectedTarget, Value, null);
   }

   /// &lt;summary&gt;
   /// Get the value of a numeric property or parameter on a sprite selected with &lt;see cref="SelectTargetSpriteFor"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="ParameterName"&gt;Name of the parameter on the target sprite that will be returned.&lt;/param&gt;
   /// &lt;param name="TargetName"&gt;Which target's currently selected sprite contains the parameter being retrieved.&lt;/param&gt;
   /// &lt;returns&gt;Integer property value of specified property.&lt;/returns&gt;
   /// &lt;remarks&gt;Remember that ParameterName and TargetName are provided as strings,
   /// and must be quoted assuming the names are provided directly.
   /// A target is an arbitrary name that distinguishes a sprite selected for one purpose from
   /// sprites selected for other purposes.  A target is defined by calling &lt;see cref="SelectTargetSpriteFor"/&gt;.
   /// &lt;seealso cref="SetTargetParameterFor"/&gt;
   /// &lt;seealso cref="SelectTargetSpriteFor"/&gt;
   /// &lt;seealso cref="SelectLastCreatedSpriteFor"/&gt;&lt;/remarks&gt;
   [Description("Get the value of a numeric property or parameter (given its name as a string) from a sprite selected with SelectTargetSprite.")]
   public virtual int GetTargetParameterFor(string ParameterName, string TargetName)
   {
      if (!selectedSprites.Contains(TargetName))
      {
         Debug.Fail("Tried to get parameter for non-existent target \"" + TargetName + "\".");
         return 0;
      }
      object selectedTarget = selectedSprites[TargetName];
      if (selectedTarget == null)
      {
         Debug.Fail("Tried to get parameter for target \"" + TargetName + "\" that was cleared.");
         return 0;
      }
      System.Reflection.PropertyInfo pi = selectedTarget.GetType().GetProperty(ParameterName);
      if (pi == null)
      {
         System.Reflection.FieldInfo fi = selectedTarget.GetType().GetField(ParameterName);
         Debug.Assert(fi != null, "Invalid property name in GetTargetParameter");
         if (fi != null)
            return (int)fi.GetValue(selectedTarget);
      }
      else
         return (int)pi.GetValue(selectedTarget, null);
      return 0;
   }

   /// &lt;summary&gt;
   /// Deactivate the sprite currently selected as the target for the specified name and clear the sprite selected for that target name.
   /// &lt;/summary&gt;
   /// &lt;param name="TargetName"&gt;For which target name the currently selected sprite should be terminated.&lt;/param&gt;
   /// &lt;returns&gt;True if a sprite was deactivated, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;Does nothing if the sprite is already inactive or no sprite is selected for the specified target name.
   /// &lt;seealso cref="SelectTargetSpriteFor"/&gt;
   /// &lt;seealso cref="SelectLastCreatedSpriteFor"/&gt;&lt;/remarks&gt;
   [Description("Deactivate the sprite currently selected as the target for the specified name.")]
   public virtual bool DeactivateTargetSpriteFor(string TargetName)
   {
      if (selectedSprites.Contains(TargetName))
      {
         object s = selectedSprites[TargetName];
         if (s == null)
            return false;
         bool result;
         SpriteBase sb = (SpriteBase)s;
         result = sb.isActive;
         sb.Deactivate();
         selectedSprites.Remove(TargetName);
         return result;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Determine if the sprite selected for the specified target (selected with SelectTargetSpriteFor)
   /// is of the specified type.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;
   /// True if the selected target is of the specified type, false otherwise.
   /// &lt;/returns&gt;
   [Description("Determine if the sprite selected for the specified target (selected with SelectTargetSpriteFor) is of the specified type.")]
   public bool IsSpriteForTargetOfType(string TargetName, [Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition)
   {
      if (!selectedSprites.Contains(TargetName))
         return false;
      return SpriteDefinition.IsInstanceOfType(selectedSprites[TargetName]);
   }
   #endregion

   #region "Messages"
   /// &lt;summary&gt;
   /// Determines in which view(s) a message will appear.
   /// &lt;/summary&gt;
   public enum MessageView
   {
      /// &lt;summary&gt;
      /// Display messages in the view that is active when the message is created.
      /// &lt;/summary&gt;
      Current,
      /// &lt;summary&gt;
      /// Display messages in all views
      /// &lt;/summary&gt;
      All,
      /// &lt;summary&gt;
      /// Display messages in the first (top or left) view
      /// &lt;/summary&gt;
      First,
      /// &lt;summary&gt;
      /// Display messages in the second view: bottom or right in 2-view layout, top-right in 4-view layout.
      /// &lt;/summary&gt;
      Second,
      /// &lt;summary&gt;
      /// Display messages in the bottom-left view
      /// &lt;/summary&gt;
      Third,
      /// &lt;summary&gt;
      /// Display messages in the bottom-right view
      /// &lt;/summary&gt;
      Fourth
   }
   /// &lt;summary&gt;
   /// Specifies a button or buttons on a player's input controller.
   /// &lt;/summary&gt;
   [Flags()]
   public enum ButtonSpecifier
   {
      /// &lt;summary&gt;
      /// The first button as defined by the player options
      /// &lt;/summary&gt;
      First = 1,
      /// &lt;summary&gt;
      /// The second button as defined by the player options
      /// &lt;/summary&gt;
      Second = 2,
      /// &lt;summary&gt;
      /// The third button as defined by the player options
      /// &lt;/summary&gt;
      Third = 4,
      /// &lt;summary&gt;
      /// The fourth button as defined by the player options
      /// &lt;/summary&gt;
      Fourth = 8,
      /// &lt;summary&gt;
      /// Disable input from the player while waiting for a button;
      /// prevent it from affecting the player's sprite.
      /// &lt;/summary&gt;
      FreezeInputs = 16
   }

   protected static Tileset FontTileset = null;
   protected const int maxMessages = 4;
   protected static MessageLayer[] activeMessages = new MessageLayer[maxMessages];
   protected static int activeMessageCount = 0;
   protected static System.Drawing.Color messageBackground = System.Drawing.Color.FromArgb(128, 64, 0, 255);
   protected static MessageView msgView = MessageView.Current;
   protected static RelativePosition msgPos = RelativePosition.CenterMiddle;
   protected const int messageMargin = 6;
   /// &lt;summary&gt;
   /// Zero-based player index that will be assigned to newly created messages
   /// &lt;/summary&gt;
   protected static int currentPlayer = 0;
   protected static ButtonSpecifier dismissButton = ButtonSpecifier.First | ButtonSpecifier.FreezeInputs;
   protected static byte[] dismissPhase = null;

   /// &lt;summary&gt;
   /// Represents a message created and displayed by &lt;see cref="ShowMessage"/&gt;.
   /// &lt;/summary&gt;
   public partial class MessageLayer : ByteLayer
   {
      public readonly System.Drawing.Color background;
      public MessageView view;
      public ButtonSpecifier dismissButton;
      /// &lt;summary&gt;
      /// 0-based player index whose controls affect this message
      /// &lt;/summary&gt;
      public int player;

      /// &lt;summary&gt;
      /// Creates a message layer object
      /// &lt;/summary&gt;
      /// &lt;param name="Tileset"&gt;Each tile in this tileset represents a unicode character starting with
      /// tile number 0 representing unicode character 0.&lt;/param&gt;
      /// &lt;param name="Parent"&gt;Map that will host this layer.&lt;/param&gt;
      /// &lt;param name="nColumns"&gt;Number of columns of text this layer can represent.&lt;/param&gt;
      /// &lt;param name="nRows"&gt;Number of rows of text this layer can represent.&lt;/param&gt;
      /// &lt;param name="Position"&gt;Position of the top-left corner of this layer within the map.&lt;/param&gt;
      /// &lt;param name="background"&gt;Background color for the box containing this message.&lt;/param&gt;
      /// &lt;param name="player"&gt;0-based player number whose button can dismiss this message.&lt;/param&gt;
      /// &lt;param name="dismissButton"&gt;Which of the player's buttons can dismiss this message.&lt;/param&gt;
      /// &lt;param name="msgView"&gt;Which view(s) will the message appear in.&lt;/param&gt;
      public MessageLayer(Tileset Tileset, MapBase Parent, int nColumns, int nRows,
         System.Drawing.Point Position, System.Drawing.Color background, int player,
         ButtonSpecifier dismissButton, MessageView msgView) :
         base(Tileset, Parent, 0, 0, 0, 0, nColumns, nRows, 0, 0, Position,
         new System.Drawing.SizeF(0, 0), 0, 0, null)
      {
         this.background = background;
         this.player = player;
         this.dismissButton = dismissButton;
         if (msgView == MessageView.Current)
         {
            switch (Parent.CurrentViewIndex)
            {
               case 0:
                  view = MessageView.First;
                  break;
               case 1:
                  view = MessageView.Second;
                  break;
               case 2:
                  view = MessageView.Third;
                  break;
               case 3:
                  view = MessageView.Fourth;
                  break;
            }
         }
         else
            view = msgView;
      }
   }

   /// &lt;summary&gt;
   /// Handles button pressses from a player with respect to displayed messages
   /// &lt;/summary&gt;
   /// &lt;param name="playerNumber"&gt;1-based player index&lt;/param&gt;
   /// &lt;param name="player"&gt;Player object providing the inputs.&lt;/param&gt;
   /// &lt;returns&gt;True if input can be passed to the player or false if the player
   /// is "frozen" viewing a message.&lt;/returns&gt;
   public static bool PlayerPressButton(int playerNumber, IPlayer player)
   {
      for (int i = 0; i &lt; activeMessageCount; i++)
      {
         MessageLayer msg = activeMessages[i];
         if (msg.player == playerNumber - 1)
         {
            bool dismissPressed = false;
            if ((0 != (msg.dismissButton &amp; ButtonSpecifier.First)) &amp;&amp; player.Button1)
               dismissPressed = true;
            if ((0 != (msg.dismissButton &amp; ButtonSpecifier.Second)) &amp;&amp; player.Button2)
               dismissPressed = true;
            if ((0 != (msg.dismissButton &amp; ButtonSpecifier.Third)) &amp;&amp; player.Button3)
               dismissPressed = true;
            if ((0 != (msg.dismissButton &amp; ButtonSpecifier.Fourth)) &amp;&amp; player.Button4)
               dismissPressed = true;

            // dismissPhase[x]:
            // 0 = No frames have passed yet
            // 1 = Frames have passed and the dismiss button was initially pressed
            // 2 = Frames have passed and the dismiss button is not pressed
            // 3 = Dismiss button was not pressed, but now it is.

            if (dismissPhase == null)
               dismissPhase = new byte[Project.MaxPlayers];

            if (dismissPressed)
            {
               if ((dismissPhase[msg.player] == 0) || (dismissPhase[msg.player] == 2))
                  dismissPhase[msg.player]++;
            }
            else
            {
               if (dismissPhase[msg.player] &lt; 2)
                  dismissPhase[msg.player] = 2;
               else if (dismissPhase[msg.player] &gt; 2)
               {
                  DismissMessage(i);
                  dismissPhase[msg.player] = 0;
               }
            }

            if (0 != (msg.dismissButton &amp; ButtonSpecifier.FreezeInputs))
            {
               return false;
            }
         }
      }
      return true;
   }

   private static void DismissMessage(int messageIndex)
   {
      for (int i = messageIndex; i &lt; activeMessageCount - 1; i++)
         activeMessages[i] = activeMessages[i + 1];
      activeMessageCount--;
   }

   /// &lt;summary&gt;
   /// Sets the background for new messages added with &lt;see cref="ShowMessage"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="background"&gt;Names a color for the background of new messages.&lt;/param&gt;
   /// &lt;param name="alpha"&gt;Transparency level of the color: 255 = opaque, 128=50% transparent.&lt;/param&gt;
   [Description("Sets the background for new messages added with ShowMessage. Alpha 255 = opaque, alpha 128=50% transparent.")]
   public virtual void SetMessageBackground(System.Drawing.KnownColor background, byte alpha)
   {
      System.Drawing.Color c = System.Drawing.Color.FromKnownColor(background);
      messageBackground = System.Drawing.Color.FromArgb(alpha, c.R, c.G, c.B);
   }

   /// &lt;summary&gt;
   /// Determines where newly created messages appear.
   /// &lt;/summary&gt;
   /// &lt;param name="ViewOption"&gt;Determines which view or views messages will appear in.&lt;/param&gt;
   /// &lt;param name="Position"&gt;Determines the area within the view in which the message appears.&lt;/param&gt;
   [Description("Determines where newly created messages appear.")]
   public virtual void SetMessagePosition(MessageView ViewOption, RelativePosition Position)
   {
      msgView = ViewOption;
      msgPos = Position;
   }

   /// &lt;summary&gt;
   /// Determines which player and which button will dismiss newly created messages.
   /// &lt;/summary&gt;
   /// &lt;param name="DismissButton"&gt;Which of the player's buttons will dismiss the message&lt;/param&gt;
   /// &lt;param name="Player"&gt;Player number 1 to 4&lt;/param&gt;
   [Description("Determines which player and which button will dismiss newly created messages. Player is a number 1 to 4.")]
   public virtual void SetMessageDismissal(ButtonSpecifier DismissButton, int Player)
   {
      dismissButton = DismissButton;
      currentPlayer = Player - 1;
   }

   /// &lt;summary&gt;
   /// Adds a message to the display.
   /// &lt;/summary&gt;
   /// &lt;param name="Message"&gt;Message text as a quoted string.  Use \r\n to insert new lines
   /// into the message.&lt;/param&gt;
   /// &lt;remarks&gt;Up to 4 messages may be displayed.  No automatic word wrap or centering
   /// is performed.  All formatting is determined by the content of the string.&lt;/remarks&gt;
   [Description("Adds a message to the display. Up to 4 messages may be displayed.")]
   public virtual void ShowMessage([Editor("Message", "UITypeEditor")] string Message)
   {
      if (activeMessageCount &gt;= maxMessages)
         throw new InvalidOperationException("Maximum number of displayed messages exceeded");
      activeMessages[activeMessageCount++] = CreateMessage(Message);
   }

   /// &lt;summary&gt;
   /// Clears all active messages from the display.
   /// &lt;/summary&gt;
   [Description("Clears all active messages from the display")]
   public virtual void ClearAllMessages()
   {
      activeMessageCount = 0;
   }

   /// &lt;summary&gt;
   /// Draws all active messages.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This function is called by the framework after drawing the overlay map.&lt;/remarks&gt;
   public static void DrawMessages()
   {
      for (int i = 0; i &lt; activeMessageCount; i++)
      {
         MessageLayer msg = activeMessages[i];
         Display disp = msg.ParentMap.Display;
         byte oldView = msg.ParentMap.CurrentViewIndex;
         switch (msg.view)
         {
            case MessageView.Current:
               DrawMessage(msg, disp);
               break;
            case MessageView.All:
               for (byte v = 0; v &lt; Project.MaxViews; v++)
               {
                  msg.ParentMap.CurrentViewIndex = v;
                  DrawMessage(msg, disp);
               }
               break;
            case MessageView.First:
               msg.ParentMap.CurrentViewIndex = 0;
               DrawMessage(msg, disp);
               break;
            case MessageView.Second:
               msg.ParentMap.CurrentViewIndex = 1;
               DrawMessage(msg, disp);
               break;
            case MessageView.Third:
               msg.ParentMap.CurrentViewIndex = 2;
               DrawMessage(msg, disp);
               break;
            case MessageView.Fourth:
               msg.ParentMap.CurrentViewIndex = 3;
               DrawMessage(msg, disp);
               break;
         }
         msg.ParentMap.CurrentViewIndex = oldView;
      }
   }

   protected static void DrawMessage(MessageLayer msg, Display disp)
   {
      disp.Scissor(msg.ParentMap.CurrentView);
      System.Drawing.Rectangle messageRect = new System.Drawing.Rectangle(
         msg.CurrentPosition.X + msg.ParentMap.CurrentView.X,
         msg.CurrentPosition.Y + msg.ParentMap.CurrentView.Y,
         msg.VirtualColumns * msg.Tileset.TileWidth,
         msg.VirtualRows * msg.Tileset.TileHeight);
      messageRect.Inflate(messageMargin, messageMargin);
      disp.SetColor(msg.background);
      disp.FillRectangle(messageRect);
      disp.SetColor(System.Drawing.Color.White);
      disp.DrawRectangle(messageRect, 0);
      msg.Draw();
   }

   /// &lt;summary&gt;
   /// Set the tileset used as the source for characters in messages.
   /// &lt;/summary&gt;
   /// &lt;param name="Tileset"&gt;Tileset whose tiles will be used to represent characters
   /// for messages. The tile numbers correspond to ASCII values of the characters
   /// used in the messages.&lt;/param&gt;
   [Description("Set the tileset used as the source for characters in messages")]
   public virtual void SetMessageFont(Tileset Tileset)
   {
      FontTileset = Tileset;
   }

   protected virtual MessageLayer CreateMessage(string Message)
   {
      if (FontTileset == null)
         FontTileset = (Tileset)(typeof(Tileset).GetProperties(
            System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.GetProperty | System.Reflection.BindingFlags.Public)
            [0].GetValue(null, null));

      byte[] charBytes = System.Text.Encoding.Unicode.GetBytes(Message);
      Display disp = ParentLayer.ParentMap.Display;
      int x = 0, y = 1;
      int maxWidth = 1;
      for (int charIdx = 0; charIdx &lt; charBytes.Length; charIdx += 2)
      {
         if (Message[charIdx / 2] == '\n')
         {
            x = 0;
            y++;
         }
         else if (Message[charIdx / 2] != '\r')
         {
            if (++x &gt; maxWidth)
               maxWidth = x;
         }
      }

      System.Drawing.Size messageSize = new System.Drawing.Size(
         maxWidth * FontTileset.TileWidth, y * FontTileset.TileHeight);
      System.Drawing.Size viewSize = ParentLayer.ParentMap.CurrentView.Size;

      System.Drawing.Point ptMessage = System.Drawing.Point.Empty;

      switch (msgPos)
      {
         case RelativePosition.TopLeft:
         case RelativePosition.LeftMiddle:
         case RelativePosition.BottomLeft:
            ptMessage.X = viewSize.Width / 4 - messageSize.Width / 2;
            if (ptMessage.X &lt; messageMargin)
               ptMessage.X = messageMargin;
            break;
         case RelativePosition.TopCenter:
         case RelativePosition.CenterMiddle:
         case RelativePosition.BottomCenter:
            ptMessage.X = (viewSize.Width - messageSize.Width) / 2;
            break;
         case RelativePosition.TopRight:
         case RelativePosition.RightMiddle:
         case RelativePosition.BottomRight:
            ptMessage.X = viewSize.Width * 3 / 4 - messageSize.Width / 2;
            if (ptMessage.X + messageSize.Width &gt; viewSize.Width - messageMargin)
               ptMessage.X = viewSize.Width - messageSize.Width - messageMargin;
            break;
      }

      switch (msgPos)
      {
         case RelativePosition.TopLeft:
         case RelativePosition.TopCenter:
         case RelativePosition.TopRight:
            ptMessage.Y = viewSize.Height / 4 - messageSize.Height / 2;
            if (ptMessage.Y &lt;= 0)
               ptMessage.Y = 1;
            break;
         case RelativePosition.LeftMiddle:
         case RelativePosition.CenterMiddle:
         case RelativePosition.RightMiddle:
            ptMessage.Y = (viewSize.Height - messageSize.Height) / 2;
            break;
         case RelativePosition.BottomLeft:
         case RelativePosition.BottomCenter:
         case RelativePosition.BottomRight:
            ptMessage.Y = viewSize.Height * 3 / 4 - messageSize.Height / 2;
            if (ptMessage.Y + messageSize.Height &gt;= viewSize.Height)
               ptMessage.Y = viewSize.Height - messageSize.Height - 1;
            break;
      }

      MessageLayer result = new MessageLayer(
         FontTileset, ParentLayer.ParentMap, maxWidth, y, ptMessage,
         messageBackground, currentPlayer, dismissButton, msgView);

      x = 0;
      y = 0;
      for (int charIdx = 0; charIdx &lt; charBytes.Length; charIdx += 2)
      {
         if (Message[charIdx / 2] == '\n')
         {
            x = 0;
            y++;
         }
         else if (Message[charIdx / 2] != '\r')
         {
            result[x++, y] = charBytes[charIdx];
         }
      }

      return result;
   }
   #endregion
}

/// &lt;summary&gt;
/// Specifies an operation to perform on a counter.
/// &lt;/summary&gt;
public enum CounterOperation
{
   /// &lt;summary&gt;
   /// Add 1 to the counter value. If the counter was at it's maximum value, leave it there.
   /// &lt;/summary&gt;
   IncrementAndStop,
   /// &lt;summary&gt;
   /// Subtract 1 from the counter value. If the counter was at it's minimum value, leave it there.
   /// &lt;/summary&gt;
   DecrementAndStop,
   /// &lt;summary&gt;
   /// Add 1 to the counter value. If the counter was at it's maximum value, set it to its minimum value.
   /// &lt;/summary&gt;
   IncrementAndLoop,
   /// &lt;summary&gt;
   /// Subtract 1 from the counter value. If the counter was at it's minimum value, set it to its maximum value.
   /// &lt;/summary&gt;
   DecrementAndLoop,
   /// &lt;summary&gt;
   /// Set the counter to its minimum value.
   /// &lt;/summary&gt;
   SetToMinimum,
   /// &lt;summary&gt;
   /// Set the counter to its maximum value.
   /// &lt;/summary&gt;
   SetToMaximum
}

/// &lt;summary&gt;
/// This is used to specify general categories of objects to be included
/// in a saved game (save unit).
/// &lt;/summary&gt;
/// &lt;remarks&gt;This is used with &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt;.
/// &lt;seealso cref="GeneralRules.IncludeInSaveUnit"/&gt;
/// &lt;seealso cref="GeneralRules.LoadGame"/&gt;&lt;/remarks&gt;
public enum SaveUnitInclusion
{
   /// &lt;summary&gt;
   /// Includes all loaded maps.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Including all maps in a &lt;see cref="SaveUnit"/&gt; causes all maps to be loaded
   /// or reset when the game is loaded. Maps that were in memory when the game was saved
   /// will be loaded from the file, while the rest will be reset. In that sense, it is
   /// including even maps that aren't loaded because it causes all maps to be reset when the
   /// game is loaded, and then only the stored maps are restored from the file.&lt;/remarks&gt;
   AllMaps,
   /// &lt;summary&gt;
   /// Includes the values of all counters defined in the project.
   /// &lt;/summary&gt;
   AllCounters,
   /// &lt;summary&gt;
   /// Includes an indicator of which map was the currently active map when the game was saved.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If this is not included, the current map will be the same map that was active
   /// before the game was loaded, which may be reset if that map was not included in the
   /// &lt;see cref="SaveUnit"/&gt;. The indicator is determined at the time that &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt;
   /// is called, unlike most other members which are stored at the time &lt;see cref="GeneralRules.SaveGame"/&gt;
   /// is called.&lt;/remarks&gt;
   WhichMapIsCurrent,
   /// &lt;summary&gt;
   /// Includes an indicator of which map was set as the overlay map when the game was saved.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If this is not included, the overlay map will remain unchanged when loading
   /// the game stored in this save unit. The indicator is determined at the time that
   /// &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt; is called, unlike most other members
   /// which are stored at the time &lt;see cref="GeneralRules.SaveGame"/&gt; is called.&lt;/remarks&gt;
   WhichMapIsOverlaid,
   /// &lt;summary&gt;
   /// Includes player preferences that determine which input devices the players are using and
   /// the keyboad layout.
   /// &lt;/summary&gt;
   PlayerOptions
}

/// &lt;summary&gt;
/// Specifies an arrangement for multiple scrolling views on a single display
/// &lt;/summary&gt;
/// &lt;remarks&gt;This is used with &lt;see cref="GeneralRules.SetViewLayout"/&gt;.
/// There is no space between the views in any of these layouts, but an overlay layer could
/// be used to draw separators on top of the views.
/// &lt;seealso cref="GeneralRules.SetViewLayout"/&gt;&lt;/remarks&gt;
public enum ViewLayout
{
   /// &lt;summary&gt;
   /// A single view that fills the display
   /// &lt;/summary&gt;
   Single,
   /// &lt;summary&gt;
   /// Two views side by side, equally split
   /// &lt;/summary&gt;
   LeftRight,
   /// &lt;summary&gt;
   /// Two views, one above the other, equally split
   /// &lt;/summary&gt;
   TopBottom,
   /// &lt;summary&gt;
   /// Four views occupying the four corners of the display, equally split
   /// &lt;/summary&gt;
   FourCorners
}

/// &lt;summary&gt;
/// Retains information about what has been included for a saved game.
/// &lt;/summary&gt;
/// &lt;remarks&gt;The information included in a SaveUnit only selects which information
/// will be saved, but does not actually store a copy of it. The data for these objects
/// is copied from the objects referenced in the SaveUnit at the time that
/// &lt;see cref="GeneralRules.SaveGame"/&gt; is called. One exception is &lt;see cref="SaveUnitInclusion.WhichMapIsCurrent"/&gt;,
/// which stores an indicator of the current map at the time &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt; is
/// called.&lt;/remarks&gt;
[Serializable()]
public partial class SaveUnit
{
   public SaveUnit()
   {
   }
   /// &lt;summary&gt;
   /// Indicates whether &lt;see cref="SaveUnitInclusion.AllMaps"/&gt; was included.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is significant because &lt;see cref="GeneralRules.LoadGame"/&gt; behaves differently
   /// with respect to maps that were not stored in the &lt;see cref="SaveUnit"/&gt; when this
   /// is true or false. If all maps were included, then maps that were not stored are
   /// reset while the game ie being loaded, otherwise they are left as they were before
   /// the game was loaded.&lt;/remarks&gt;
   public bool AllMaps = false;
   /// &lt;summary&gt;
   /// Refers to all maps that will be saved
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The key of this collection is the type of the map and the value refers to the
   /// instance of the map data.&lt;/remarks&gt;
   public System.Collections.Hashtable Maps = null;
   /// &lt;summary&gt;
   /// This indicator remembers which map was current, or is null if the indicator is not saved
   /// &lt;/summary&gt;
   public System.Type CurrentMapType = null;
   /// &lt;summary&gt;
   /// This indicator remembers which map was used as an overlay.  It's null if the indicator is
   /// not saved, and typeof(System.DBNull) if the overlay map is empty.
   /// &lt;/summary&gt;
   public System.Type OverlayMapType = null;
   /// &lt;summary&gt;
   /// An array of &lt;see cref="CounterRef"/&gt; objects used to include counters in a &lt;see cref="SaveUnit"/&gt;
   /// &lt;/summary&gt;
   public System.Collections.ArrayList Counters = null;
   /// &lt;summary&gt;
   /// Stores player preferenes.
   /// &lt;/summary&gt;
   public IPlayer[] PlayerOptions = null;
}

/// &lt;summary&gt;
/// This class provides a kind of indirect reference to a counter for the purposes
/// of saving and loading counter values in a &lt;see cref="SaveUnit"/&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Since counters are global objects, it doesn't work well to add a counter
/// directly to the save unit because then loading the save unit will leave the
/// loaded counter values contained in the &lt;see cref="SaveUnit"/&gt; object. But by
/// providing this wrapper that has code specifically for loading ans storing counters,
/// the value of the global counters can automatically be linked to those in a
/// &lt;see cref="SaveUnit"/&gt;.&lt;/remarks&gt;
[Serializable()]
public partial class CounterRef : System.Runtime.Serialization.ISerializable
{
   public string counterName;
   public Counter instance;

   public CounterRef(Counter counter)
   {
      instance = counter;
      System.Reflection.PropertyInfo[] counterProps = typeof(Counter).GetProperties(
         System.Reflection.BindingFlags.Public |
         System.Reflection.BindingFlags.GetProperty |
         System.Reflection.BindingFlags.Static);
      foreach (System.Reflection.PropertyInfo counterProp in counterProps)
      {
         Counter inst = (Counter)counterProp.GetValue(null, null);
         if (inst == counter)
         {
            counterName = counterProp.Name;
            break;
         }
      }
   }

   private CounterRef(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      counterName = info.GetString("CounterName");
      instance = (Counter)(typeof(Counter).GetProperty(counterName,
         System.Reflection.BindingFlags.Public |
         System.Reflection.BindingFlags.GetProperty |
         System.Reflection.BindingFlags.Static).GetValue(null, null));
      instance.CurrentValue = info.GetInt32("CounterValue");
   }

   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      info.AddValue("CounterName", counterName);
      info.AddValue("CounterValue", instance.CurrentValue);
   }
}

/// &lt;summary&gt;
/// Refers to the position of a predefined point relative to a rectangle
/// &lt;/summary&gt;
/// &lt;remarks&gt;Many operations involving the position of one object relative to another
/// object rely on RelativePosition to determine how the two objects' rectangles are
/// aligned. The positions defined in this enumeration generally refer to
/// a point inside the rectangle at the specified position. For example, RightMiddle
/// would refer to the point immediately within the middle of the right side of the
/// rectangle. In the case of aligning two rectangles, this means that the right
/// sides will match up exactly and the vertical center of one rectangle would be
/// aligned with the vertical center of the other.&lt;/remarks&gt;
public enum RelativePosition
{
   TopLeft,
   TopCenter,
   TopRight,
   LeftMiddle,
   CenterMiddle,
   RightMiddle,
   BottomLeft,
   BottomCenter,
   BottomRight
}</Text>
  </SourceCode>
  <SourceCode Name="GameForm.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Windows.Forms;

/// &lt;summary&gt;
/// UI that contains and manages the main display for the game.
/// &lt;/summary&gt;
public partial class GameForm : Form
{
   /// &lt;summary&gt;
   /// Hardware-backed display object embedded in the main window.
   /// &lt;/summary&gt;
   public Display GameDisplay = null;
   private KeyboardState m_keyboardState = null;
   private Joystick[] controllers = null;
   private System.Collections.BitArray controllerEnabled;
   /// &lt;summary&gt;
   /// Refers to the currently active primary map that is being drawn on the display
   /// &lt;/summary&gt;
   public MapBase CurrentMap;
   /// &lt;summary&gt;
   /// Refers to the currently active overlay map being drawn in front of the primary map
   /// &lt;/summary&gt;
   /// &lt;value&gt;This is a null reference if no overlay is active&lt;/value&gt;
   public MapBase OverlayMap;
   /// &lt;summary&gt;
   /// Contains a collection of all currently loaded maps.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The key of this collection is the type of the map class. The value is an
   /// instance of the map.
   /// &lt;seealso cref="UnloadMap"/&gt;
   /// &lt;seealso cref="GeneralRules.SwitchToMap"/&gt;&lt;/remarks&gt;
   public System.Collections.Hashtable LoadedMaps = new System.Collections.Hashtable();
   private int m_fps = 0;
   private int m_frameCount = 0;
   private DateTime m_frameStart;
   /// &lt;summary&gt;
   /// Used to write debug text that will be displayed for the current frame.
   /// &lt;/summary&gt;
   public System.IO.StringWriter debugText = new System.IO.StringWriter();
   private bool m_quit = false;
   /// &lt;summary&gt;
   /// Provides access to the input currently coming from the players' input devices.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each of these objects can refer to a &lt;see cref="KeyboardPlayer"/&gt;
   /// or a &lt;see cref="ControllerPlayer"/&gt;, or you can create your own player input.&lt;/remarks&gt;
   public IPlayer[] Players = new IPlayer[Project.MaxPlayers];
   bool isFullScreen = false;
   private string title;
   public static System.Drawing.Point oldMousePosition;
   public static System.Drawing.Point curMousePosition;
   public static System.Windows.Forms.MouseButtons oldMouseButtons;
   public static System.Windows.Forms.MouseButtons curMouseButtons;

   #region Events
   /// &lt;summary&gt;
   /// Defines a mechanism by which simple notifications without any data can be triggered.
   /// &lt;/summary&gt;
   public delegate void SimpleNotification();
   /// &lt;summary&gt;
   /// Event fires every frame even when the game is not advancing.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The game may not be moving because the window may be minimized, but
   /// this event will still be raised. This might be useful for monitoring sounds that
   /// might continue to play while the window is minimized.&lt;/remarks&gt;
   public event SimpleNotification OnFrameStart;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing right before the scene is started.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnBeforeBeginScene;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing right before executing rules.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnBeforeExecuteRules;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing while the scene is being
   /// generated, right before the overlay map is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnBeforeDrawOverlay;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing after the overlay map is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnAfterDrawOverlay;
   #endregion


   #region Windows Forms Components
   private System.Windows.Forms.MainMenu mnuGame;
   private System.Windows.Forms.MenuItem mnuFile;
   private System.Windows.Forms.MenuItem mnuFileExit;
   private System.Windows.Forms.MenuItem mnuTools;
   private System.Windows.Forms.MenuItem mnuToolsOptions;
   private System.Windows.Forms.MenuItem mnuHelp;
   private System.ComponentModel.IContainer components;
   private System.Windows.Forms.MenuItem mnuHelpAbout;
   #endregion

   /// &lt;summary&gt;
   /// Constructs the main form for containing the game display.
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;Defines the size of the form in windowed mode and the resolution and
   /// color depth of the display in full screen mode.&lt;/param&gt;
   /// &lt;param name="windowed"&gt;Determines whether the display is initially windowed or full screen.&lt;/param&gt;
   /// &lt;param name="title"&gt;Supplies a title for the window when the game is in windowed mode.&lt;/param&gt;
   /// &lt;param name="initMapType"&gt;Defines the map that is initially active when the game starts.&lt;/param&gt;
   /// &lt;param name="overlayMapType"&gt;Defines the map that in initially set as the
   /// &lt;seealso cref="OverlayMap"/&gt; or null if there is no overlay initially.&lt;/param&gt;
   public GameForm(GameDisplayMode mode, bool windowed, string title, System.Type initMapType, System.Type overlayMapType)
   {
      InitializeComponent();
#if DEBUG
      MessageBox.Show("You are running in debug mode.  Unexpected runtime conditions may cause the game to halt, and if an error occurs you will have the opportunity to debug into it if you have a debugger installed and the project's source code handy", "Debug Mode Active");
#endif
      ClientSize = Display.GetScreenSize(mode);
      GameDisplay = new Display(mode, windowed);
      GameDisplay.BorderStyle = System.Windows.Forms.BorderStyle.None;
      GameDisplay.Location = new System.Drawing.Point(0, 0);
      GameDisplay.Name = "GameDisplay";
      GameDisplay.Size = Display.GetScreenSize(mode);
      Controls.Add(this.GameDisplay);
      Name = "GameForm";
      Text = this.title = title;
      KeyPreview = true;
      FormBorderStyle = FormBorderStyle.FixedSingle;
      CurrentMap = GetMap(initMapType);
      if (overlayMapType != null)
         OverlayMap = GetMap(overlayMapType);
      else
         OverlayMap = null;
      if (!windowed)
         FullScreen = true;
   }

   /// &lt;summary&gt;
   /// Clean up any resources being used.
   /// &lt;/summary&gt;
   protected override void Dispose( bool disposing )
   {
      if( disposing )
      {
         if (GameDisplay != null)
         {
            GameDisplay.Dispose();
            GameDisplay = null;
         }
      }
      base.Dispose( disposing );
   }

   /// &lt;summary&gt;
   /// Main game loop initializes input devices and runs the game.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The general sequence of steps performed in this loop are:
   /// &lt;list type="number"&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnFrameStart"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Check if game has been closed/quit, and exit if necessary.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;If game is inactive draw the screen as it was when it
   /// was last active, and skip the rest of the loop.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnBeforeBeginScene"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Draw the main map.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Read players' input devices.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnBeforeExecuteRules"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Execute the main map's rules.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnBeforeDrawOverlay"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;If an overlay map is active, draw it and execute its rules.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Draw the current debug output if debug mode is active, and clear the debug text buffer.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnAfterDrawOverlay"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// &lt;/remarks&gt;
   public void Run()
   {
      int controllerCount = Joystick.GetDeviceCount();
      if (controllerCount &gt; 0)
      {
         controllers = new Joystick[controllerCount];
         controllerEnabled = new System.Collections.BitArray(controllers.Length, false);
      }
      else
      {
         controllers = null;
         controllerEnabled = null;
      }

      // Player 0 always uses keyboard by default
      Players[0] = new KeyboardPlayer(0);

      // Players 1 through (M-N) use keyboard while players (M-N+1) through M use controllers
      // where M is max player number and N is number of controllers.
      for (int playerIdx = 1; playerIdx&lt;Project.MaxPlayers; playerIdx++)
      {
         if ((controllers != null) &amp;&amp; (Project.MaxPlayers - playerIdx &lt;= controllers.Length))
            Players[playerIdx] = new ControllerPlayer(playerIdx - (Project.MaxPlayers - controllers.Length));
         else
            Players[playerIdx] = new KeyboardPlayer(playerIdx);
      }

      m_keyboardState = new KeyboardState();

      Application.DoEvents();
      while(true)
      {
         oldMousePosition = curMousePosition;
         oldMouseButtons = curMouseButtons;
         curMousePosition = System.Windows.Forms.Control.MousePosition;
         curMouseButtons = System.Windows.Forms.Control.MouseButtons;

         if (OnFrameStart != null)
            OnFrameStart();
         if ((GameDisplay == null) || GameDisplay.IsDisposed || m_quit)
         {
            Close();
            return;
         }
         bool isActive;
         isActive = (System.Windows.Forms.Form.ActiveForm == this);
         if (!isActive)
         {
            // Display is minimized or inactive, wait until it is restored
            Application.DoEvents();
            if (GameDisplay != null)
               GameDisplay.SwapBuffers();
            System.Threading.Thread.Sleep(0);
            continue;
         }
         if (OnBeforeBeginScene != null)
            OnBeforeBeginScene();
         CurrentMap.DrawAllViews();
         ReadControllers();
         if (OnBeforeExecuteRules != null)
            OnBeforeExecuteRules();
         CurrentMap.ExecuteRules();
         if (OnBeforeDrawOverlay != null)
            OnBeforeDrawOverlay();
         GeneralRules.DrawMessages();
         if (OverlayMap != null)
         {
            OverlayMap.DrawAllViews();
            OverlayMap.ExecuteRules();
         }
         OutputDebugInfo();
         if (OnAfterDrawOverlay != null)
            OnAfterDrawOverlay();
         GameDisplay.Flush();
         GameDisplay.SwapBuffers();
         Application.DoEvents();
      }
   }

   /// &lt;summary&gt;
   /// Draw the text currently in the &lt;see cref="debugText"/&gt; buffer and clear the buffer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This will only execute in debug mode. It requires that the "CoolFont" graphic
   /// sheet be embedded in the project.&lt;/remarks&gt;
   [System.Diagnostics.Conditional("DEBUG")]
   public void OutputDebugInfo()
   {
      GameDisplay.ScissorOff();
      GameDisplay.SetColor(Color.White);
      GameDisplay.DrawText(debugText.ToString(), 0, 0);

      debugText.GetStringBuilder().Length = 0;
      debugText.WriteLine("fps=" + m_fps.ToString());
      m_frameCount++;
      if (DateTime.Now.Subtract(m_frameStart).TotalSeconds &gt;= 1f)
      {
         m_fps = m_frameCount;
         m_frameCount=0;
         m_frameStart = DateTime.Now;
      }
   }

   protected override void OnClosing(System.ComponentModel.CancelEventArgs e)
   {
      GameDisplay.Dispose();
      GameDisplay = null;
      base.OnClosing(e);
   }

   /// &lt;summary&gt;
   /// Retrieves an instance of the specified map.
   /// &lt;/summary&gt;
   /// &lt;param name="mapType"&gt;Specifies which map to retrieve by its type&lt;/param&gt;
   /// &lt;returns&gt;A newly initialized map if the map was not loaded, or the existing
   /// map if it was already loaded.&lt;/returns&gt;
   /// &lt;remarks&gt;Loaded maps are stored in &lt;see cref="LoadedMaps"/&gt;.
   /// &lt;seealso cref="GeneralRules.UnloadMap"/&gt;
   /// &lt;seealso cref="GeneralRules.SwitchToMap"/&gt;&lt;/remarks&gt;
   public MapBase GetMap(System.Type mapType)
   {
      if (!LoadedMaps.ContainsKey(mapType))
      {
         MapBase result = (MapBase)mapType.GetConstructor(new System.Type[] {typeof(Display)}).Invoke(new object[] {GameDisplay});
         LoadedMaps[mapType] = result;
         return result;
      }
      else
         return (MapBase)(LoadedMaps[mapType]);
   }

   /// &lt;summary&gt;
   /// Unloads the currently loaded instance of the specified map type if it is loaded.
   /// &lt;/summary&gt;
   /// &lt;param name="mapType"&gt;Specifies which map to unload.&lt;/param&gt;
   /// &lt;remarks&gt;This is called by &lt;see cref="GeneralRules.UnloadMap"/&gt;.&lt;/remarks&gt;
   public void UnloadMap(System.Type mapType)
   {
      LoadedMaps.Remove(mapType);
   }

   /// &lt;summary&gt;
   /// Unload all maps that are not the current primary map or overlay map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is called by &lt;see cref="GeneralRules.UnloadBackgroundMaps"/&gt;.
   /// &lt;seealso cref="UnloadMap"/&gt;&lt;/remarks&gt;
   public void UnloadBackgroundMaps()
   {
      System.Collections.ArrayList toRemove = new System.Collections.ArrayList();
      foreach(System.Collections.DictionaryEntry de in LoadedMaps)
      {
         if ((de.Value != CurrentMap) &amp;&amp; (de.Value != OverlayMap))
            toRemove.Add(de.Key);
      }
      foreach(System.Type removeKey in toRemove)
      {
         LoadedMaps.Remove(removeKey);
      }
   }

   private void InitializeComponent()
   {
      this.components = new System.ComponentModel.Container();
      this.mnuGame = new System.Windows.Forms.MainMenu(this.components);
      this.mnuFile = new System.Windows.Forms.MenuItem();
      this.mnuFileExit = new System.Windows.Forms.MenuItem();
      this.mnuTools = new System.Windows.Forms.MenuItem();
      this.mnuToolsOptions = new System.Windows.Forms.MenuItem();
      this.mnuHelp = new System.Windows.Forms.MenuItem();
      this.mnuHelpAbout = new System.Windows.Forms.MenuItem();
      this.SuspendLayout();
      // 
      // mnuGame
      // 
      this.mnuGame.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuFile,
            this.mnuTools,
            this.mnuHelp});
      // 
      // mnuFile
      // 
      this.mnuFile.Index = 0;
      this.mnuFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuFileExit});
      this.mnuFile.Text = "&amp;File";
      // 
      // mnuFileExit
      // 
      this.mnuFileExit.Index = 0;
      this.mnuFileExit.Shortcut = System.Windows.Forms.Shortcut.AltF4;
      this.mnuFileExit.Text = "E&amp;xit";
      this.mnuFileExit.Click += new System.EventHandler(this.mnuFileExit_Click);
      // 
      // mnuTools
      // 
      this.mnuTools.Index = 1;
      this.mnuTools.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuToolsOptions});
      this.mnuTools.Text = "&amp;Tools";
      // 
      // mnuToolsOptions
      // 
      this.mnuToolsOptions.Index = 0;
      this.mnuToolsOptions.Text = "&amp;Options";
      this.mnuToolsOptions.Click += new System.EventHandler(this.mnuToolsOptions_Click);
      // 
      // mnuHelp
      // 
      this.mnuHelp.Index = 2;
      this.mnuHelp.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuHelpAbout});
      this.mnuHelp.Text = "&amp;Help";
      // 
      // mnuHelpAbout
      // 
      this.mnuHelpAbout.Index = 0;
      this.mnuHelpAbout.Text = "&amp;About...";
      this.mnuHelpAbout.Click += new System.EventHandler(this.mnuHelpAbout_Click);
      // 
      // GameForm
      // 
      this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
      this.ClientSize = new System.Drawing.Size(292, 273);
      this.MaximizeBox = false;
      this.Menu = this.mnuGame;
      this.Name = "GameForm";
      this.ResumeLayout(false);

   }

   /// &lt;summary&gt;
   /// Represents the current state of the keyboard.
   /// &lt;/summary&gt;
   public KeyboardState KeyboardState
   {
      get
      {
         return m_keyboardState;
      }
   }

   /// &lt;summary&gt;
   /// Reads the state of all relevant game controller devices into the respective
   /// objects in &lt;see cref="Players"/&gt;.
   /// &lt;/summary&gt;
   public void ReadControllers()
   {
      KeyboardState.Poll();

      if (controllerEnabled == null)
         return;

      foreach(IPlayer plr in Players)
      {
         if (plr is ControllerPlayer)
            controllerEnabled[((ControllerPlayer)plr).deviceNumber] = true;
      }

      for (int i=0; i&lt;controllerEnabled.Count; i++)
      {
         if (controllerEnabled[i])
         {
            if (controllers[i] == null)
               controllers[i] = new Joystick(i);
            controllers[i].Read();
         }
         else if (controllers[i] != null)
            controllers[i] = null;
      }
   }

   /// &lt;summary&gt;
   /// Return the number of available controllers connected to the system
   /// &lt;/summary&gt;
   public int ControllerCount
   {
      get
      {
         if (controllers == null)
            return 0;
         return controllers.Length;
      }
   }

   /// &lt;summary&gt;
   /// Return the name of a specific game controller as displayed in the options window.
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNumber"&gt;Zero-based index of the game controller&lt;/param&gt;
   /// &lt;returns&gt;String containing the display name for the device&lt;/returns&gt;
   public string GetControllerName(int deviceNumber)
   {
      if (controllers[deviceNumber] == null)
         controllers[deviceNumber] = new Joystick(deviceNumber);
      return controllers[deviceNumber].Name;
   }

   /// &lt;summary&gt;
   /// Reads the current state of a game controller
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNumber"&gt;Zero-based index of the game controller&lt;/param&gt;
   public Joystick GetControllerState(int deviceNumber)
   {
      return controllers[deviceNumber];
   }

   /// &lt;summary&gt;
   /// Returns true if the controller is currently enabled for input.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A controller is enabled when a player is using it.&lt;/remarks&gt;
   public System.Collections.BitArray ControllerEnabled
   {
      get
      {
         return controllerEnabled;
      }
   }

   private void mnuFileExit_Click(object sender, System.EventArgs e)
   {
      Quit();
   }
   
   private void mnuToolsOptions_Click(object sender, System.EventArgs e)
   {
      frmControls frm = new frmControls();
      frm.ShowDialog();
      frm.Dispose();
   }

   private void mnuHelpAbout_Click(object sender, System.EventArgs e)
   {
      using (frmAbout frm = new frmAbout())
         frm.ShowDialog();
   }

   /// &lt;summary&gt;
   /// Sets an indicator that causes the game to quit at the beginning of the
   /// next game loop.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is checked during &lt;see cref="Run"/&gt;.&lt;/remarks&gt;
   public void Quit()
   {
      m_quit = true;
   }

   /// &lt;summary&gt;
   /// This function is called by the SGDK2 generated code when a top-level
   /// exception occurs.
   /// &lt;/summary&gt;
   /// &lt;param name="ex"&gt;Refers to the exception that was received at the top level&lt;/param&gt;
   public static void HandleException(System.Exception ex)
   {
      if (Project.GameWindow != null)
         Project.GameWindow.Close();
      MessageBox.Show("A fatal error occurred initializing or running the game:\r\n" + ex.ToString(), "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
   }

   protected override void OnKeyDown(KeyEventArgs e)
   {
      if (e.KeyCode == Keys.Enter &amp;&amp; e.Modifiers == Keys.Alt)
      {
         e.Handled = true;
         e.SuppressKeyPress = true;
         FullScreen = !FullScreen;
      }
   }

   /// &lt;summary&gt;
   /// Determines whether the display will occupy the full screen rather than being contained in a window.
   /// &lt;/summary&gt;
   public bool FullScreen
   {
      get
      {
         return isFullScreen;
      }
      set
      {
         if (value != isFullScreen)
         {
            isFullScreen = value;
            if (isFullScreen)
            {
               Text = String.Empty;
               FormBorderStyle = FormBorderStyle.None;
               ControlBox = false;
               MinimizeBox = false;
               Menu = null;
               GameDisplay.SwitchToResolution();
               WindowState = FormWindowState.Maximized;
            }
            else
            {
               Display.RestoreResolution();
               WindowState = FormWindowState.Normal;
               FormBorderStyle = FormBorderStyle.FixedSingle;
               ControlBox = true;
               MinimizeBox = true;
               Menu = mnuGame;
               ClientSize = Display.GetScreenSize(GameDisplay.GameDisplayMode);
               Text = title;
            }
         }
      }
   }
}</Text>
  </SourceCode>
  <SourceCode Name="TileShapes.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Associates a category of tiles with a solidity shape to which sprites can react.
/// &lt;/summary&gt;
[Serializable()]
public partial struct SolidityMapping : System.Runtime.Serialization.ISerializable
{
   /// &lt;summary&gt;
   /// Designates the category of tiles to which a shape is applied.
   /// &lt;/summary&gt;
   public TileCategoryName category;
   /// &lt;summary&gt;
   /// Designates the shape of the tiles in the associated category.
   /// &lt;/summary&gt;
   public TileShape shape;

   /// &lt;summary&gt;
   /// Constructs a SolidityMapping given all its parameters
   /// &lt;/summary&gt;
   /// &lt;param name="category"&gt;Initial value for &lt;see cref="category"/&gt;&lt;/param&gt;
   /// &lt;param name="shape"&gt;Initial value for &lt;see cref="shape"/&gt;&lt;/param&gt;
   public SolidityMapping(TileCategoryName category, TileShape shape)
   {
      this.category = category;
      this.shape = shape;
   }

   private SolidityMapping(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      category = (TileCategoryName)info.GetInt32("TileCategoryName");
      shape = (TileShape)System.Type.GetType(info.GetString("TileShapeName"), true, false).GetProperty("Value",
         System.Reflection.BindingFlags.GetProperty | System.Reflection.BindingFlags.Static |
         System.Reflection.BindingFlags.Public).GetValue(null, null);
   }

   /// &lt;summary&gt;
   /// This is provided to allow the object to be serialized for the purposes of saving and loading game data.
   /// &lt;/summary&gt;
   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      info.AddValue("TileCategoryName", (System.Int32)category);
      info.AddValue("TileShapeName", shape.GetType().Name);
   }
}

/// &lt;summary&gt;
/// Defines a particular shape that a tile can have at any/all sizes
/// &lt;/summary&gt;
public abstract partial class TileShape
{
   public TileShape()
   {
   }
   /// &lt;summary&gt;
   /// Gets the vertical coordinate of the top-most solid pixel of a tile shape between two horizontal offsets.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Horizontal offset of the left side of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Horizontal offset of the right side of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and height-1, inclusive, or short.MaxValue if there is no solid&lt;/returns&gt;
   public abstract short GetTopSolidPixel(short width, short height, short min, short max);
   /// &lt;summary&gt;
   /// Gets the vertical coordinate of the bottom-most solid pixel of a tile shape between two horizontal offsets.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Horizontal offset of the left side of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Horizontal offset of the right side of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and height-1, inclusive, or short.MinValue if there is no solid&lt;/returns&gt;
   public abstract short GetBottomSolidPixel(short width, short height, short min, short max);
   /// &lt;summary&gt;
   /// Gets the horizontal coordinate of the left-most solid pixel of a tile shape between two vertical offsets
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Vertical offset of the top of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Vertical offset of the bottom of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and width-1, inclusive, or short.MaxValue if there is no solid&lt;/returns&gt;
   public abstract short GetLeftSolidPixel(short width, short height, short min, short max);
   /// &lt;summary&gt;
   /// Gets the horizontal coordinate of the right-most solid pixel of a tile shape between two vertical offsets
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Vertical offset of the top of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Vertical offset of the bottom of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and width-1, inclusive, or short.MinValue if there is no solid&lt;/returns&gt;
   public abstract short GetRightSolidPixel(short width, short height, short min, short max);
}

/// &lt;summary&gt;
/// Represents an empty tile (nothing solid)
/// &lt;/summary&gt;
public partial class EmptyTileShape : TileShape
{
   private static EmptyTileShape m_Value = new EmptyTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static EmptyTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public EmptyTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }
}

/// &lt;summary&gt;
/// Represents a solid tile (flat solid on all 4 sides)
/// &lt;/summary&gt;
public partial class SolidTileShape : TileShape
{
   private static SolidTileShape m_Value = new SolidTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static SolidTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public SolidTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width-1);
   }
}

/*
   +--------+
   |       X|
   |      XX|
   |     XXX|
   |    XXXX|
   |   XXXXX|
   |  XXXXXX|
   | XXXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents an "uphill" shape with a slope leading from the lower left corner
/// to the upper right corner with the lower right half of the tile being solid.
/// &lt;/summary&gt;
public partial class UphillTileShape : TileShape
{
   private static UphillTileShape m_Value = new UphillTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UphillTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UphillTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height * (width-max-1) / width);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width * (height-max-1) / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width-1);
   }
}

/*
   +--------+
   |X       |
   |XX      |
   |XXX     |
   |XXXX    |
   |XXXXX   |
   |XXXXXX  |
   |XXXXXXX |
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents a "downhill" shape with a slope leading from the upper left corner
/// to the lower right corner with the lower left half of the tile being solid.
/// &lt;/summary&gt;
public partial class DownhillTileShape : TileShape
{
   private static DownhillTileShape m_Value = new DownhillTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownhillTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownhillTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(min * height / width);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width - (height - max - 1) * width / height - 1);
   }
}

/*
   +--------+
   |XXXXXXXX|
   |XXXXXXX |
   |XXXXXX  |
   |XXXXX   |
   |XXXX    |
   |XXX     |
   |XX      |
   |X       |
   +--------+
*/
/// &lt;summary&gt;
/// Represents an "upward ceiling" shape with a slope leading from the lower left corner
/// to the upper right corner with the upper left half of the tile being solid.
/// &lt;/summary&gt;
public partial class UpCeilingTileShape : TileShape
{
   private static UpCeilingTileShape m_Value = new UpCeilingTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UpCeilingTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UpCeilingTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((width - min) * height - 1) / width);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((height - min) * width - 1) / height);
   }
}

/*
   +--------+
   |XXXXXXXX|
   | XXXXXXX|
   |  XXXXXX|
   |   XXXXX|
   |    XXXX|
   |     XXX|
   |      XX|
   |       X|
   +--------+
*/
/// &lt;summary&gt;
/// Represents a "downward ceiling" shape with a slope leading from the upper left corner
/// to the lower right corner with the upper right half of the tile being solid.
/// &lt;/summary&gt;
public partial class DownCeilingTileShape : TileShape
{
   private static DownCeilingTileShape m_Value = new DownCeilingTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownCeilingTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownCeilingTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height - (width - max - 1) * height / width - 1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(min * width / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width - 1);
   }
}

/*
   +--------+
   |      XX|
   |    XXXX|
   |  XXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the right half of a gradual "uphill" tile with a slope leading from the
/// middle left to the upper right corner with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public partial class UphillRightTileShape : TileShape
{
   private static UphillRightTileShape m_Value = new UphillRightTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UphillRightTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UphillRightTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height * (width - max - 1) / width / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height - 1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)((max * 2 &gt;= height - 2) ? 0 : width * (height - max * 2 - 2) / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width - 1);
   }
}

/*
   +--------+
   |        |
   |        |
   |        |
   |        |
   |      XX|
   |    XXXX|
   |  XXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the left half of a gradual "uphill" tile with a slope leading from the
/// lower left corner to the middle right with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public partial class UphillLeftTileShape : TileShape
{
   private static UphillLeftTileShape m_Value = new UphillLeftTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UphillLeftTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UphillLeftTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height * (width - max - 1) / width / 2 + height / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height - 1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &lt;= height)?short.MaxValue:width * (height - max - 1) * 2 / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &lt;= height)?short.MinValue:width - 1);
   }
}

/*
   +--------+
   |XX      |
   |XXXX    |
   |XXXXXX  |
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the left half of a gradual "downhill" tile with a slope leading from the
/// upper left corner to the middle right with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public partial class DownhillLeftTileShape : TileShape
{
   private static DownhillLeftTileShape m_Value = new DownhillLeftTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownhillLeftTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownhillLeftTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(min * height / width / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &gt; height) ? width - 1 : width * 2 - (height - max - 1) * width * 2 / height - 1);
   }
}

/*
   +--------+
   |        |
   |        |
   |        |
   |        |
   |XX      |
   |XXXX    |
   |XXXXXX  |
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the right half of a gradual "downhill" tile with a slope leading from the
/// middle left to the lower right corner with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public partial class DownhillRightTileShape : TileShape
{
   private static DownhillRightTileShape m_Value = new DownhillRightTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownhillRightTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownhillRightTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)((height + min * height / width) / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((min + 1) * 2 &lt;= height) ? short.MaxValue : (short)0);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &lt;= height) ? short.MinValue : width - (height - max - 1) * 2 * width / height - 1);
   }
}


/*
   +--------+
   |^^^^^^^^|
   |        |
   |        |
   |        |
   |        |
   |        |
   |        |
   |        |
   +--------+
   (Top is solid only from above)
*/
/// &lt;summary&gt;
/// Represents a tile that is only solid from above. A sprite can move freely through this tile
/// in any direction unless the sprite is fully above the tile in which case it cannot penetrate
/// the top.
/// &lt;/summary&gt;
public partial class TopSolidTileShape : TileShape
{
   private static TopSolidTileShape m_Value = new TopSolidTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static TopSolidTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public TopSolidTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }
}

</Text>
  </SourceCode>
  <SourceCode Name="LayerBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;

/// &lt;summary&gt;
/// Defines the basic operation of a layer of tiles and sprites within a map.
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class LayerBase : System.Collections.IEnumerable
{
   #region Embedded Classes
   /// &lt;summary&gt;
   /// Maintains information about a &lt;see cref="Frame"/&gt; that has been inserted
   /// into the layer for the current loop.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Frames may be inserted behind the layer (drawn before the tiles),
   /// Appended in front of the layer (drawn after all the tiles) or inserted between
   /// rows of tiles in the layer (drawn after the rows above it, and before the rows
   /// below it). Frames are generally injected into a layer by the existence of a
   /// sprite on the layer.&lt;/remarks&gt;
   private class InjectedFrame : IComparable
   {
      /// &lt;summary&gt;
      /// Horizontal pixel coordinate of the frame within the layer
      /// &lt;/summary&gt;
      public int x;
      /// &lt;summary&gt;
      /// Vertical pixel coordinate of the frame within the layer
      /// &lt;/summary&gt;
      public int y;
      /// &lt;summary&gt;
      /// Determines whether the frame is drawn behind the layer, in front of it,
      /// ir interleaved with the tiles.
      /// &lt;/summary&gt;
      /// &lt;value&gt;&lt;list type="table"&gt;
      /// &lt;listheader&gt;&lt;term&gt;Value&lt;/term&gt;&lt;description&gt;Drawing Order&lt;/description&gt;&lt;/listheader&gt;
      /// &lt;item&gt;&lt;term&gt;-1&lt;/term&gt;&lt;description&gt;Behind tiles&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;0&lt;/term&gt;&lt;description&gt;Interleaved with tiles&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;1&lt;/term&gt;&lt;description&gt;In front of tiles&lt;/description&gt;&lt;/item&gt;
      /// &lt;/list&gt;&lt;/value&gt;
      /// &lt;remarks&gt;Although at design time, priorities are generally specified with
      /// a wide range of numbers on the sprite instances, all we need to know at
      /// runtime is whether a frame is behind, interleaved or in front, so this
      /// priority value only has 3 possible values.&lt;/remarks&gt;
      public int priority;
      /// &lt;summary&gt;
      /// Refers to the frame that is drawn "injected" into this layer
      /// &lt;/summary&gt;
      public Frame frame;
      /// &lt;summary&gt;
      /// Speifies any color modulation that is applied to the frame when it is drawn
      /// &lt;/summary&gt;
      public int color;
      /// &lt;summary&gt;
      /// Constructs a new frame provided with all the values
      /// &lt;/summary&gt;
      /// &lt;param name="x"&gt;Initial value for &lt;see cref="x"/&gt;&lt;/param&gt;
      /// &lt;param name="y"&gt;Initial value for &lt;see cref="y"/&gt;&lt;/param&gt;
      /// &lt;param name="priority"&gt;Initial value for &lt;see cref="priority"/&gt;&lt;/param&gt;
      /// &lt;param name="frame"&gt;Initial value for &lt;see cref="frame"/&gt;&lt;/param&gt;
      /// &lt;param name="color"&gt;Initial value for &lt;see cref="color"/&gt;&lt;/param&gt;
      /// &lt;remarks&gt;A frame may have its own color modulation value internally.
      /// If the color provided to this constructor (presumably from the sprite's
      /// color modulation value) and the frame's color are both specified (not the
      /// default of -1) then they are combined.&lt;/remarks&gt;
      public InjectedFrame(int x, int y, int priority, Frame frame, int color)
      {
         this.x = x;
         this.y = y;
         this.frame = frame;
         this.priority = priority;
         if (color == -1)
            this.color = frame.Color;
         else //if (frame.Color == -1)
            this.color = color;
         /*else
            this.color = Microsoft.DirectX.Direct3D.ColorOperator.Modulate(ColorValue.FromArgb(frame.Color), ColorValue.FromArgb(color)).ToArgb();*/
      }
      #region IComparable Members

      /// &lt;summary&gt;
      /// Dertermine whether a specified frame should be drawn before or after this frame.
      /// &lt;/summary&gt;
      /// &lt;param name="obj"&gt;Another &lt;see cref="InjectedFrame"/&gt; object.&lt;/param&gt;
      /// &lt;returns&gt;A signed integer that indicates the sequence of the frames
      /// &lt;list type="table"&gt;
      /// &lt;listheader&gt;&lt;term&gt;Return Value&lt;/term&gt;&lt;item&gt;Description&lt;/item&gt;&lt;/listheader&gt;
      /// &lt;item&gt;&lt;term&gt;Less than zero&lt;/term&gt;&lt;description&gt;This injected frame should be drawn
      /// before &lt;paramref name="obj"/&gt;.&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;Zero&lt;/term&gt;&lt;description&gt;Frames overlap exactly, drawing order indeterminant.&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;Greater than zero&lt;/term&gt;&lt;description&gt;This injected frame should be drawn
      /// after &lt;paramref name="obj"/&gt;.&lt;/description&gt;&lt;/item&gt;
      /// &lt;/list&gt;&lt;/returns&gt;
      /// &lt;remarks&gt;&lt;see cref="InjectFrames"/&gt; relies on this interface to make sure that newly
      /// injected frames will be drawn in the right order. Frames higher up in the layer are
      /// drawn before frames that are lower down in the layer regardless of the order in which
      /// they are injected. Frames at the same vertical position will use the horizontal position
      /// to determine drawing order, frames on the left will draw first.&lt;/remarks&gt;
      public int CompareTo(object obj)
      {
         int result = y.CompareTo((obj as InjectedFrame).y);
         if (result != 0)
            return result;
         result = x.CompareTo((obj as InjectedFrame).x);
         if (result != 0)
            return result;
         return -1;
      }

      #endregion
   }
   #endregion

   #region Fields
   protected readonly Tileset m_Tileset;
   private Frameset m_Frameset;
   [NonSerialized()]
   private System.Collections.ArrayList m_InjectedFrames = null;
   
   private readonly int m_nLeftBuffer;
   private readonly int m_nTopBuffer;
   private readonly int m_nRightBuffer;
   private readonly int m_nBottomBuffer;
   protected readonly int m_nColumns;
   protected readonly int m_nRows;
   private readonly int m_nVirtualColumns;
   private readonly int m_nVirtualRows;
   private System.Drawing.Point m_AbsolutePosition;
   /// &lt;summary&gt;
   /// A "Category" or collection of all sprites contained by the layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;"Static" sprites (sprite instances added at design time in the
   /// map editor) occupy the first portion of this collection. Any dynamically
   /// added sprites (added with functions like &lt;see cref="SpriteBase.TileAddSprite"/&gt;)
   /// are appended to the end. When a dynamically added sprite is deactivated, it is
   /// removed from this collection.&lt;/remarks&gt;
   public SpriteCollection m_Sprites;
   private readonly System.Drawing.SizeF m_ScrollRate;
   private System.Drawing.Point[] m_CurrentPosition = new System.Drawing.Point[Project.MaxViews];
   private MapBase m_ParentMap;
   /// &lt;summary&gt;
   /// Provides access to all sprite categories as they relate to this layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The objects provided by this member will return a collection of all sprites
   /// in the requested category that are on this layer.&lt;/remarks&gt;
   public LayerSpriteCategoriesBase m_SpriteCategories;
   protected readonly int m_nInjectStartIndex;
   protected readonly int m_nAppendStartIndex;
   #endregion

   protected LayerBase(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer, int nBottomBuffer,
      int nColumns, int nRows, int nVirtualColumns, int nVirtualRows, System.Drawing.Point Position,
      System.Drawing.SizeF ScrollRate, int nInjectStartIndex, int nAppendStartIndex)
   {
      this.m_ParentMap = Parent;
      this.m_Tileset = Tileset;
      this.m_Frameset = Tileset.GetFrameset(Parent.Display);
      this.m_nLeftBuffer = nLeftBuffer;
      this.m_nTopBuffer = nTopBuffer;
      this.m_nRightBuffer = nRightBuffer;
      this.m_nBottomBuffer = nBottomBuffer;
      this.m_nColumns = nColumns;
      this.m_nRows = nRows;
      if (nVirtualColumns == 0)
         this.m_nVirtualColumns = nColumns;
      else
         this.m_nVirtualColumns = nVirtualColumns;
      if (nVirtualRows == 0)
         this.m_nVirtualRows = nRows;
      else
         this.m_nVirtualRows = nVirtualRows;
      this.m_AbsolutePosition = Position;
      this.m_ScrollRate = ScrollRate;
      byte origView = Parent.CurrentViewIndex;
      for (byte v = 0; v &lt; Project.MaxViews; v++)
      {
         Parent.CurrentViewIndex = v;
         this.Move(new Point(0, 0));
      }
      Parent.CurrentViewIndex = origView;
      this.m_nInjectStartIndex = nInjectStartIndex;
      this.m_nAppendStartIndex = nAppendStartIndex;
   }

   #region Abstract Members
   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   public abstract int this[int x, int y]
   {
      get;
      set;
   }
   protected abstract int[] GetTileFrame(int x, int y);
   /// &lt;summary&gt;
   /// Retrieves information about the tile at the specified tile coordinate
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal tile coordinate of the tile to retrieve&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical tile coordinate of the tile to retrieve&lt;/param&gt;
   /// &lt;returns&gt;Object describing the tile at the specified position in the layer.&lt;/returns&gt;
   /// &lt;remarks&gt;If the coordinate is beyond the edge of the layer's data, it wraps
   /// to the other side of the layer in order to support layers whose virtual size
   /// is larger than the data size.&lt;/remarks&gt;
   public abstract TileBase GetTile(int x, int y);
   #endregion

   #region IEnumerable Members
   /// &lt;summary&gt;
   /// Enumerates active sprites on the layer.
   /// &lt;/summary&gt;
   public System.Collections.IEnumerator GetEnumerator()
   {
      return new ActiveSpriteEnumerator(m_Sprites);
   }
   #endregion

   #region Properties
   /// &lt;summary&gt;
   /// Get the number of columns of tiles in the layer's tile data
   /// &lt;/summary&gt;
   public int ActualColumns
   {
      get
      {
         return m_nColumns;
      }
   }
   /// &lt;summary&gt;
   /// Get the number of rows of tiles in the layer's tile data
   /// &lt;/summary&gt;
   public int ActualRows
   {
      get
      {
         return m_nRows;
      }
   }

   /// &lt;summary&gt;
   /// Get the number of columns of tiles in the layer's displayed
   /// virtual scroll space (data is wrapped)
   /// &lt;/summary&gt;
   public int VirtualColumns
   {
      get
      {
         return m_nVirtualColumns;
      }
   }
   /// &lt;summary&gt;
   /// Get the number of rows of tiles in the layer's displayed
   /// virtual scroll space (data is wrapped)
   /// &lt;/summary&gt;
   public int VirtualRows
   {
      get
      {
         return m_nVirtualRows;
      }
   }

   /// &lt;summary&gt;
   /// Get or set the position of the layer within the map. 
   /// (Does not affect current position until &lt;see cref="Move"/&gt; is called)
   /// &lt;/summary&gt;
   public System.Drawing.Point AbsolutePosition
   {
      get
      {
         return m_AbsolutePosition;
      }
      set
      {
         m_AbsolutePosition = value;
      }
   }

   /// &lt;summary&gt;
   /// Gets the scroll rate that is applied to &lt;see cref="Move"/&gt; operations.
   /// &lt;/summary&gt;
   public System.Drawing.SizeF ScrollRate
   {
      get
      {
         return m_ScrollRate;
      }
   }

   /// &lt;summary&gt;
   /// Gets/Sets the current pixel position of the layer relative to the screen.
   /// (Setting this directly ignores &lt;see cref="ScrollRate"/&gt; and &lt;see cref="AbsolutePosition"/&gt;.)
   /// &lt;/summary&gt;
   public System.Drawing.Point CurrentPosition
   {
      get
      {
         return m_CurrentPosition[ParentMap.CurrentViewIndex];
      }
      set
      {
         m_CurrentPosition[ParentMap.CurrentViewIndex] = value;
      }
   }

   /// &lt;summary&gt;
   /// Returns the map that owns this layer
   /// &lt;/summary&gt;
   public MapBase ParentMap
   {
      get
      {
         return m_ParentMap;
      }
   }
   
   public Tileset Tileset
   {
      get
      {
         return m_Tileset;
      }
   }
   #endregion

   #region Public methods
   /// &lt;summary&gt;
   /// Move/Scroll the layer to a new position based on the current map position.
   /// The layer's current position is offset by its position on the map and scaled
   /// by the layer's scroll rate.
   /// &lt;/summary&gt;
   /// &lt;param name="MapPosition"&gt;Position of the map. If one component is int.minValue,
   /// that axis is not affected.&lt;/param&gt;
   /// &lt;remarks&gt;Map positions are usually negative because the map position indicates
   /// the position of the top-left corner of the map which is usually scrolled off
   /// the top-left corner of the screen to a negative position.&lt;/remarks&gt;
   public void Move(Point MapPosition)
   {
      if (MapPosition.X != int.MinValue)
         if (MapPosition.Y != int.MinValue)
            CurrentPosition = new Point(m_AbsolutePosition.X + (int)(MapPosition.X * m_ScrollRate.Width), m_AbsolutePosition.Y + (int)(MapPosition.Y * m_ScrollRate.Height));
         else
            CurrentPosition = new Point(m_AbsolutePosition.X + (int)(MapPosition.X * m_ScrollRate.Width), CurrentPosition.Y);
      else if (MapPosition.Y != int.MinValue)
         CurrentPosition = new Point(CurrentPosition.X, m_AbsolutePosition.Y + (int)(MapPosition.Y * m_ScrollRate.Height));
   }

   /// &lt;summary&gt;
   /// Draw the layer according to the currently active view defined by &lt;see cref="MapBase.CurrentView"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Drawing the layer includes drawing of all the tiles and the sprites in the layer.&lt;/remarks&gt;
   public void Draw()
   {
      int nTileWidth = m_Tileset.TileWidth;
      int nTileHeight = m_Tileset.TileHeight;

      int nStartCol = (-m_nLeftBuffer - CurrentPosition.X) / nTileWidth;
      if (nStartCol &lt; 0)
         nStartCol = 0;
      int nStartRow = (-m_nTopBuffer - CurrentPosition.Y) / nTileHeight;
      if (nStartRow &lt; 0)
         nStartRow = 0;

      Rectangle ViewRect = m_ParentMap.CurrentView;
      Display disp = m_ParentMap.Display;
      disp.Scissor(ViewRect);

      int EndCol = (ViewRect.Width - 1 + m_nRightBuffer - CurrentPosition.X) / nTileWidth;
      if (EndCol &gt;= VirtualColumns)
         EndCol = VirtualColumns - 1;
      int EndRow = (ViewRect.Height - 1 + m_nBottomBuffer - CurrentPosition.Y) / nTileHeight;
      if (EndRow &gt;= VirtualRows)
         EndRow = VirtualRows - 1;

      System.Collections.IEnumerator Injected = null;
      InjectedFrame CurFrame;
      if (m_InjectedFrames != null)
      {
         Injected = m_InjectedFrames.GetEnumerator();
         if (!Injected.MoveNext())
            Injected = null;
      }

      int lastColor = 0;

      for (int y = nStartRow; y &lt;= EndRow; y++)
      {
         if (Injected != null)
         {
            while ((((CurFrame = (InjectedFrame)Injected.Current).y &lt; y * nTileHeight)) &amp;&amp; (CurFrame.priority &lt;= 0) ||
                   (CurFrame.priority &lt; 0))
            {
               if (CurFrame.color != lastColor)
               {
                  disp.SetColor(CurFrame.color);
                  lastColor = CurFrame.color;
               }
               disp.DrawFrame(CurFrame.frame.GraphicSheetTexture,
                  CurFrame.frame.SourceRect, CurFrame.frame.Corners,
                  CurFrame.x + CurrentPosition.X + ViewRect.X,
                  CurFrame.y + CurrentPosition.Y + ViewRect.Y);
               if (!Injected.MoveNext())
               {
                  Injected = null;
                  break;
               }
            }
         }

         for (int x = nStartCol; x &lt;= EndCol; x++)
         {
            int[] SubFrames = GetTileFrame(x,y);
            for (int nFrame = 0; nFrame &lt; SubFrames.Length; nFrame++)
            {
               Frame f = m_Frameset[SubFrames[nFrame]];
               if (f.Color != lastColor)
               {
                  disp.SetColor(f.Color);
                  lastColor = f.Color;
               }
               disp.DrawFrame(f.GraphicSheetTexture, f.SourceRect, f.Corners,
                  x * nTileWidth + CurrentPosition.X + ViewRect.X,
                  y * nTileHeight + CurrentPosition.Y + ViewRect.Y);
            }
         }
      }

      while (Injected != null)
      {
         CurFrame = (InjectedFrame)Injected.Current;
         if (CurFrame.color != lastColor)
         {
            disp.SetColor(CurFrame.color);
            lastColor = CurFrame.color;
         }
         disp.DrawFrame(CurFrame.frame.GraphicSheetTexture,
            CurFrame.frame.SourceRect, CurFrame.frame.Corners,
            CurFrame.x + CurrentPosition.X + ViewRect.X,
            CurFrame.y + CurrentPosition.Y + ViewRect.Y);
         if (!Injected.MoveNext())
         {
            Injected = null;
            break;
         }
      }
      disp.SetColor(-1);
   }

   /// &lt;summary&gt;
   /// Returns a rectangle within this layer that represents the currently visible portion.
   /// &lt;/summary&gt;
   public Rectangle VisibleArea
   {
      get
      {
         return new Rectangle(new System.Drawing.Point(-CurrentPosition.X, -CurrentPosition.Y), m_ParentMap.CurrentView.Size);
      }
   }

   /// &lt;summary&gt;
   /// Determines if any part of the specified sprite is visible in the current view.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to test.&lt;/param&gt;
   /// &lt;returns&gt;True if any part of the specified sprite is visible in the map's
   /// &lt;see cref="MapBase.CurrentView"/&gt;.&lt;/returns&gt;
   public bool IsSpriteVisible(SpriteBase sprite)
   {
      return sprite.isActive &amp;&amp; sprite.GetBounds().IntersectsWith(VisibleArea);
   }

   /// &lt;summary&gt;
   /// Injects a series of &lt;see cref="Frame"/&gt; objects into this layer, to be interleaved
   /// with the tiles on the layer.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames to be injected at the specified coordinate&lt;/param&gt;
   /// &lt;remarks&gt;Often times only a single frame is injected, but sprites with compound frames
   /// may inject multiple frames at once.&lt;/remarks&gt;
   public void InjectFrames(int x, int y, Frame[] frames)
   {
      InjectFrames(x, y, frames, -1);
   }

   /// &lt;summary&gt;
   /// Injects a series of &lt;see cref="Frame"/&gt; objects into this layer, to be interleaved
   /// with the tiles on the layer, specifying a color modulation value.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames to be injected at the specified coordinate&lt;/param&gt;
   /// &lt;param name="color"&gt;Specifies how the color channels of the injected frames will be affected.
   /// If the frames include their own color modulation, they will be merged with this.&lt;/param&gt;
   /// &lt;remarks&gt;Often times only a single frame is injected, but sprites with compound frames
   /// may inject multiple frames at once.&lt;/remarks&gt;
   public void InjectFrames(int x, int y, Frame[] frames, int color)
   {
      if (frames.Length &lt;= 0)
         return;

      InjectedFrame[] additions = new InjectedFrame[frames.Length];
      for (int idx=0; idx&lt;frames.Length; idx++)
         additions[idx] = new InjectedFrame(x, y, 0, frames[idx], color);

      int insIdx;
      if (m_InjectedFrames == null)
      {
         m_InjectedFrames = new System.Collections.ArrayList();
         insIdx = 0;
      }
      else
      {
         insIdx = m_InjectedFrames.BinarySearch(additions[0]);
         if (insIdx &lt; 0)
            insIdx = ~insIdx;
      }
      m_InjectedFrames.InsertRange(insIdx, additions);
   }

   /// &lt;summary&gt;
   /// Injects a series of &lt;see cref="Frame"/&gt; objects into this layer, to be drawn behind the
   /// layer or in front of it, specifying a color modulation value.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames to be injected at the specified coordinate&lt;/param&gt;
   /// &lt;param name="color"&gt;Specifies how the color channels of the injected frames will be affected.
   /// If the frames include their own color modulation, they will be merged with this.&lt;/param&gt;
   /// &lt;param name="priority"&gt;&lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Value&lt;/term&gt;&lt;description&gt;Drawing Order&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;-1&lt;/term&gt;&lt;description&gt;Behind tiles&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;1&lt;/term&gt;&lt;description&gt;In front of tiles&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;&lt;/param&gt;
   /// &lt;remarks&gt;Often times only a single frame is injected, but sprites with compound frames
   /// may inject multiple frames at once.&lt;/remarks&gt;
   public void AppendFrames(int x, int y, Frame[] frames, int color, int priority)
   {
      InjectedFrame[] additions = new InjectedFrame[frames.Length];
      for (int idx=0; idx&lt;frames.Length; idx++)
         additions[idx] = new InjectedFrame(x, y, priority, frames[idx], color);
      if (m_InjectedFrames == null)
      {
         m_InjectedFrames = new System.Collections.ArrayList(additions);
      }
      else
         m_InjectedFrames.AddRange(additions);
   }

   /// &lt;summary&gt;
   /// Remove all injected frames from the layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is performed after each time the layer is drawn to
   /// prepare for the next iteration.&lt;/remarks&gt;
   public void ClearInjections()
   {
      if (m_InjectedFrames != null)
         m_InjectedFrames.Clear();
   }

   /// &lt;summary&gt;
   /// Inject frames into the layer to represent the current images and positions of
   /// the sprites contained in this layer for this loop iteration.
   /// &lt;/summary&gt;
   public void InjectSprites()
   {
      for (int i = 0; (i &lt; m_nInjectStartIndex) &amp;&amp; (i &lt; m_Sprites.Count); i++)
      {
         SpriteBase sprite = m_Sprites[i];
         if (IsSpriteVisible(sprite))
            AppendFrames(sprite.PixelX, sprite.PixelY, sprite.GetCurrentFramesetFrames(), sprite.color, -1);
      }
      for (int i = m_nInjectStartIndex; (i &lt; m_nAppendStartIndex) &amp;&amp; (i &lt; m_Sprites.Count); i++)
      {
         SpriteBase sprite = m_Sprites[i];
         if (IsSpriteVisible(sprite))
            InjectFrames(sprite.PixelX, sprite.PixelY, sprite.GetCurrentFramesetFrames(), sprite.color);
      }
      for (int i = m_nAppendStartIndex; (i &lt; m_Sprites.Count); i++)
      {
         SpriteBase sprite = m_Sprites[i];
         if (IsSpriteVisible(sprite))
            AppendFrames(sprite.PixelX, sprite.PixelY, sprite.GetCurrentFramesetFrames(), sprite.color, 1);
      }
   }

   /// &lt;summary&gt;
   /// Execute the rules of all active sprites on this layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;After the rules are executed, the function checks to see if
   /// any dynamic sprites have been de-activated and removes them.
   /// This function can be overridden in the derived layer to customize how
   /// and when ProcessRules is called on each sprite.&lt;/remarks&gt;
   public virtual void ProcessSprites()
   {
      foreach(SpriteBase sprite in m_Sprites)
         // Assuming it's more efficient to just set them all to false rather than
         // try and only enumerate the active ones.
         sprite.Processed = false;
      for(int i=0; i &lt; m_Sprites.Count; i++)
         if (m_Sprites[i].isActive)
            m_Sprites[i].ProcessRules();
      m_Sprites.Clean();
   }

   /// &lt;summary&gt;
   /// Executes the rules for all the plans on this layer
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;See &lt;see cref="ExecuteRules"/&gt; for information on overriding this.&lt;/remarks&gt;
   public virtual void ExecuteRulesInternal()
   {
      throw new NotImplementedException("ExecuteRules called on a layer without rules");
   }

   public virtual void ExecuteRules() { ExecuteRulesInternal(); }
  
   /// &lt;summary&gt;
   /// Retrieve the current mouse position
   /// &lt;/summary&gt;
   /// &lt;returns&gt;Layer-relative coordinate representing the current position of the mouse.&lt;/returns&gt;
   /// &lt;remarks&gt;This can be used to set a sprite's position at the mouse cursor and make it behave
   /// like a mouse pointer.
   /// &lt;seealso cref="PlanBase.TransportToPoint"/&gt;&lt;/remarks&gt;
   public Point GetMousePosition()
   {
      Point dispPos;
      dispPos = m_ParentMap.Display.PointToClient(GameForm.curMousePosition);
      dispPos.Offset(-CurrentPosition.X, -CurrentPosition.Y);
      return dispPos;
   }

   /// &lt;summary&gt;
   /// Scroll the currently active view on the map so the specified sprite is visible.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to scroll into view&lt;/param&gt;
   /// &lt;param name="useScrollMargins"&gt;True to scroll the sprite so that it is also within
   /// the scroll margins, false to only scroll it so it is fully visible in the view.&lt;/param&gt;
   public void ScrollSpriteIntoView(SpriteBase sprite, bool useScrollMargins)
   {
      Rectangle spriteBounds = sprite.GetBounds();
      int newX = int.MinValue;
      int newY = int.MinValue;
      int marginLeft;
      int marginTop;
      int marginRight;
      int marginBottom;
      if (useScrollMargins)
      {
         marginLeft = ParentMap.ScrollMarginLeft;
         marginTop = ParentMap.ScrollMarginTop;
         marginRight = ParentMap.ScrollMarginRight;
         marginBottom = ParentMap.ScrollMarginBottom;
      }
      else
      {
         marginLeft = 0;
         marginTop = 0;
         marginRight = 0;
         marginBottom = 0;
      }
      if (spriteBounds.Left + CurrentPosition.X &lt; marginLeft)
      {
         if (ScrollRate.Width &gt; 0)
            newX = (int)((-spriteBounds.Left + marginLeft - AbsolutePosition.X) / ScrollRate.Width);
         else
            CurrentPosition = new Point(-spriteBounds.Left + marginLeft, CurrentPosition.Y);
      }
      else if (spriteBounds.Right + CurrentPosition.X &gt; VisibleArea.Width - marginRight)
      {
         if (ScrollRate.Width &gt; 0)
            newX = (int)((-spriteBounds.Right + VisibleArea.Width - marginRight - AbsolutePosition.X) / ScrollRate.Width);
         else
            CurrentPosition = new Point(-spriteBounds.Right + VisibleArea.Width - marginRight, CurrentPosition.Y);
      }

      if (spriteBounds.Top + CurrentPosition.Y &lt; marginTop)
      {
         if (ScrollRate.Height &gt; 0)
            newY = (int)((-spriteBounds.Top + marginTop - AbsolutePosition.Y) / ScrollRate.Height);
         else
            CurrentPosition = new Point(CurrentPosition.X, -spriteBounds.Top + marginTop);
      }
      else if (spriteBounds.Bottom + CurrentPosition.Y &gt; VisibleArea.Height - marginBottom)
      {
         if (ScrollRate.Height &gt; 0)
            newY = (int)((-spriteBounds.Bottom + VisibleArea.Height - marginBottom - AbsolutePosition.Y) / ScrollRate.Height);
         else
            CurrentPosition = new Point(CurrentPosition.X, -spriteBounds.Bottom + VisibleArea.Height - marginBottom);
      }
      ParentMap.Scroll(new Point(newX, newY));
   }

   /// &lt;summary&gt;
   /// Push the specified sprite into the currently active view.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to be pushed&lt;/param&gt;
   /// &lt;param name="stayInScrollMargins"&gt;True to push the sprite until it's within the scroll
   /// margins, or false to only push it until it's fully visible in the view.&lt;/param&gt;
   /// &lt;remarks&gt;This only affects the sprites intended velocity and does not actually move it.
   /// Solidity ot other factors could still impede the sprite's ability to stay in the view.&lt;/remarks&gt;
   public void PushSpriteIntoView(SpriteBase sprite, bool stayInScrollMargins)
   {
      Rectangle spriteBounds = sprite.GetBounds();
      int marginLeft;
      int marginTop;
      int marginRight;
      int marginBottom;
      if (stayInScrollMargins)
      {
         marginLeft = ParentMap.ScrollMarginLeft;
         marginTop = ParentMap.ScrollMarginTop;
         marginRight = ParentMap.ScrollMarginRight;
         marginBottom = ParentMap.ScrollMarginBottom;
      }
      else
      {
         marginLeft = 0;
         marginTop = 0;
         marginRight = 0;
         marginBottom = 0;
      }

      if (spriteBounds.Left + CurrentPosition.X &lt; marginLeft)
      {
         if (double.IsNaN(sprite.LocalDX))
            sprite.dx = marginLeft - CurrentPosition.X - spriteBounds.Left;
         else
            sprite.LocalDX = marginLeft - CurrentPosition.X - spriteBounds.Left - sprite.RidingOn.dx;
      }
      else if (spriteBounds.Right + CurrentPosition.X &gt; VisibleArea.Width - marginRight)
      {
         if (double.IsNaN(sprite.LocalDX))
            sprite.dx = VisibleArea.Width - marginRight - CurrentPosition.X - spriteBounds.Right;
         else
            sprite.LocalDX = VisibleArea.Width - marginRight - CurrentPosition.X - spriteBounds.Right - sprite.RidingOn.dx;
      }

      if (spriteBounds.Top + CurrentPosition.Y &lt; marginTop)
      {
         if (double.IsNaN(sprite.LocalDY))
            sprite.dy = marginTop - spriteBounds.Top - CurrentPosition.Y;
         else
            sprite.LocalDY = marginTop - spriteBounds.Top - CurrentPosition.Y - sprite.RidingOn.dy;
      }
      else if (spriteBounds.Bottom + CurrentPosition.Y &gt; VisibleArea.Height - marginBottom)
      {
         if (double.IsNaN(sprite.LocalDY))
            sprite.dy = VisibleArea.Height - marginBottom - spriteBounds.Bottom - CurrentPosition.Y;
         else
            sprite.LocalDY = VisibleArea.Height - marginBottom - spriteBounds.Bottom - CurrentPosition.Y - sprite.RidingOn.dy;
      }
   }

   /// &lt;summary&gt;
   /// Determine the vertical offset of the top-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative vertical coordinate (y) of the top-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetTopSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileWidth) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short minTileTop = (short)(testArea.Top % m_Tileset.TileHeight);
      int tileLeft = leftTile * m_Tileset.TileWidth;
      for (int y = topTile; y &lt;= bottomTile; y++)
      {
         if (rightTile == leftTile)
         {
            short topMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               topMost = 0;
            else
               topMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetTopSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft),
                  (short)(testArea.Left + testArea.Width - 1 - tileLeft));
            if ((topMost != short.MaxValue) &amp;&amp; ((y &gt; topTile) || (topMost &gt;= minTileTop)))
            {
               int result = topMost + y * m_Tileset.TileHeight;
               if (result &lt; testArea.Top + testArea.Height)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short topMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               topMost = 0;
            else
               topMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetTopSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft), (short)(m_Tileset.TileWidth - 1));
            if ((y == topTile) &amp;&amp; (topMost &lt; minTileTop))
               topMost = short.MaxValue;
            short top;
            for (int x = leftTile + 1; x &lt; rightTile; x++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  top = 0;
               else
                  top = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetTopSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileWidth - 1));
               if ((top &lt; topMost) &amp;&amp; ((y &gt; topTile) || (top &gt;= minTileTop)))
                  topMost = top;
            }
            if (outOfBounds &amp;&amp; ((rightTile &lt; 0) || (rightTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               top = 0;
            else
               top = solid.GetCurrentTileShape(m_Tileset[this[rightTile,y]]).GetTopSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Left + testArea.Width - 1) % m_Tileset.TileWidth));
            if ((top &lt; topMost) &amp;&amp; ((y &gt; topTile) || (top &gt;= minTileTop)))
               topMost = top;
            if (topMost != short.MaxValue)
            {
               int result = topMost + y * m_Tileset.TileHeight;
               if (result &lt; testArea.Top + testArea.Height)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }

   /// &lt;summary&gt;
   /// Determine the vertical offset of the bottom-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative vertical coordinate (y) of the bottom-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetBottomSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileWidth) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short maxTileBottom = (short)((testArea.Top+testArea.Height-1) % m_Tileset.TileHeight);
      int tileLeft = leftTile * m_Tileset.TileWidth;
      for (int y = bottomTile; y &gt;= topTile; y--)
      {
         if (rightTile == leftTile)
         {
            short bottomMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               bottomMost = (short)(m_Tileset.TileHeight - 1);
            else
               bottomMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetBottomSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft),
                  (short)(testArea.Left + testArea.Width - 1 - tileLeft));
            if ((bottomMost != short.MinValue) &amp;&amp; ((y &lt; bottomTile) || (bottomMost &lt;= maxTileBottom)))
            {
               int result = bottomMost + y * m_Tileset.TileHeight;
               if (result &gt;= testArea.Top)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short bottomMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               bottomMost = (short)(m_Tileset.TileHeight - 1);
            else
               bottomMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetBottomSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft), (short)(m_Tileset.TileWidth - 1));
            if ((y == bottomTile) &amp;&amp; (bottomMost &gt; maxTileBottom))
               bottomMost = short.MinValue;
            short bottom;
            for (int x = leftTile + 1; x &lt; rightTile; x++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  bottom = (short)(m_Tileset.TileHeight - 1);
               else
                  bottom = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetBottomSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileWidth - 1));
               if ((bottom &gt; bottomMost) &amp;&amp; ((y &lt; bottomTile) || (bottom &lt;= maxTileBottom)))
                  bottomMost = bottom;
            }
            if (outOfBounds &amp;&amp; ((rightTile &lt; 0) || (rightTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               bottom = (short)(m_Tileset.TileHeight - 1);
            else
               bottom = solid.GetCurrentTileShape(m_Tileset[this[rightTile,y]]).GetBottomSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Left + testArea.Width - 1) % m_Tileset.TileWidth));
            if ((bottom &gt; bottomMost) &amp;&amp; ((y &lt; bottomTile) || (bottom &lt;= maxTileBottom)))
               bottomMost = bottom;
            if (bottomMost != short.MinValue)
            {
               int result = bottomMost + y * m_Tileset.TileHeight;
               if (result &gt;= testArea.Top)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }

   /// &lt;summary&gt;
   /// Determine the horizontal offset of the left-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative horizontal coordinate (x) of the left-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetLeftSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileWidth) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short minTileLeft = (short)(testArea.Left % m_Tileset.TileWidth);
      int tileTop = topTile * m_Tileset.TileHeight;
      for (int x = leftTile; x &lt;= rightTile; x++)
      {
         if (bottomTile == topTile)
         {
            short leftMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               leftMost = 0;
            else
               leftMost = solid.GetCurrentTileShape(m_Tileset[this[x,topTile]]).GetLeftSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop),
                  (short)(testArea.Top + testArea.Height - 1 - tileTop));
            if ((leftMost != short.MaxValue) &amp;&amp; ((x &gt; leftTile) || (leftMost &gt;= minTileLeft)))
            {
               int result = leftMost + x * m_Tileset.TileWidth;
               if (result &lt; testArea.Left + testArea.Width)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short leftMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               leftMost = 0;
            else
               leftMost = solid.GetCurrentTileShape(m_Tileset[this[x, topTile]]).GetLeftSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop), (short)(m_Tileset.TileHeight - 1));
            if ((x == leftTile) &amp;&amp; (leftMost &lt; minTileLeft))
               leftMost = short.MaxValue;
            short left;
            for (int y = topTile + 1; y &lt; bottomTile; y++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  left = 0;
               else
                  left = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetLeftSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileHeight - 1));
               if ((left &lt; leftMost) &amp;&amp; ((x &gt; leftTile) || (left &gt;= minTileLeft)))
                  leftMost = left;
            }
            if (outOfBounds &amp;&amp; ((bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               left = 0;
            else
               left = solid.GetCurrentTileShape(m_Tileset[this[x, bottomTile]]).GetLeftSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Top + testArea.Height - 1) % m_Tileset.TileHeight));
            if ((left &lt; leftMost) &amp;&amp; ((x &gt; leftTile) || (left &gt;= minTileLeft)))
               leftMost = left;
            if (leftMost != short.MaxValue)
            {
               int result = leftMost + x * m_Tileset.TileWidth;
               if (result &lt; testArea.Left + testArea.Width)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }

   /// &lt;summary&gt;
   /// Determine the horizontal offset of the right-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative horizontal coordinate (x) of the right-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetRightSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileWidth) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short maxTileRight = (short)((testArea.Left+testArea.Width-1) % m_Tileset.TileWidth);
      int tileTop = topTile * m_Tileset.TileHeight;
      for (int x = rightTile; x &gt;= leftTile; x--)
      {
         if (bottomTile == topTile)
         {
            short rightMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               rightMost = (short)(m_Tileset.TileWidth - 1);
            else
               rightMost = solid.GetCurrentTileShape(m_Tileset[this[x,topTile]]).GetRightSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop),
                  (short)(testArea.Top + testArea.Height - 1 - tileTop));
            if ((rightMost != short.MinValue) &amp;&amp; ((x &lt; rightTile) || (rightMost &lt;= maxTileRight)))
            {
               int result = rightMost + x * m_Tileset.TileWidth;
               if (result &gt;= testArea.Left)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short rightMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               rightMost = (short)(m_Tileset.TileWidth - 1);
            else
               rightMost = solid.GetCurrentTileShape(m_Tileset[this[x, topTile]]).GetRightSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop), (short)(m_Tileset.TileHeight - 1));
            if ((x == rightTile) &amp;&amp; (rightMost &gt; maxTileRight))
               rightMost = short.MinValue;
            short right;
            for (int y = topTile + 1; y &lt; bottomTile; y++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  right = (short)(m_Tileset.TileWidth - 1);
               else
                  right = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetRightSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileHeight - 1));
               if ((right &gt; rightMost) &amp;&amp; ((x &lt; rightTile) || (right &lt;= maxTileRight)))
                  rightMost = right;
            }
            if (outOfBounds &amp;&amp; ((bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               right = (short)(m_Tileset.TileWidth - 1);
            else
               right = solid.GetCurrentTileShape(m_Tileset[this[x, bottomTile]]).GetRightSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Top + testArea.Height - 1) % m_Tileset.TileHeight));
            if ((right &gt; rightMost) &amp;&amp; ((x &lt; rightTile) || (right &lt;= maxTileRight)))
               rightMost = right;
            if (rightMost != short.MinValue)
            {
               int result = rightMost + x * m_Tileset.TileWidth;
               if (result &gt;= testArea.Left)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }
   #endregion
}

/// &lt;summary&gt;
/// Represents a layer where each tile is represented as a 32-bit integer.
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class IntLayer : LayerBase
{
   private int[,] m_Tiles;

   public IntLayer(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer,
      int nBottomBuffer, int nColumns, int nRows, int nVirtualColumns, int nVirtualRows,
      System.Drawing.Point Position, System.Drawing.SizeF ScrollRate,
      int nInjectStartIndex, int nAppendStartIndex, string Name) : 
      base(Tileset, Parent, nLeftBuffer, nTopBuffer, nRightBuffer,
      nBottomBuffer, nColumns, nRows, nVirtualColumns, nVirtualRows, Position,
      ScrollRate, nInjectStartIndex, nAppendStartIndex)
   {
      System.Resources.ResourceManager resources = new System.Resources.ResourceManager(Parent.GetType());
      if (Name != null)
         m_Tiles = (int[,])(resources.GetObject(Name));
      else
         m_Tiles = new int[nColumns, nRows];
   }

   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   public override int this[int x, int y]
   {
      get
      {
         return m_Tiles[x % m_nColumns, y % m_nRows];
      }
      set
      {
         m_Tiles[x % m_nColumns, y % m_nRows] = value;
      }
   }

   protected override int[] GetTileFrame(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]].CurrentFrame;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="LayerBase.GetTile"/&gt;.
   /// &lt;/summary&gt;
   public override TileBase GetTile(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns,y % m_nRows]];
   }
}

/// &lt;summary&gt;
/// Represents a layer where each tile is represented as a 16-bit integer.
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class ShortLayer : LayerBase
{
   private short[,] m_Tiles;

   public ShortLayer(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer,
      int nBottomBuffer, int nColumns, int nRows, int nVirtualColumns, int nVirtualRows, System.Drawing.Point Position,
      System.Drawing.SizeF ScrollRate, int nInjectStartIndex, int nAppendStartIndex, string Name) : 
      base(Tileset, Parent, nLeftBuffer, nTopBuffer, nRightBuffer,
      nBottomBuffer, nColumns, nRows, nVirtualColumns, nVirtualRows, Position,
      ScrollRate, nInjectStartIndex, nAppendStartIndex)
   {
      System.Resources.ResourceManager resources = new System.Resources.ResourceManager(Parent.GetType());
      if (Name != null)
         m_Tiles = (short[,])(resources.GetObject(Name));
      else
         m_Tiles = new short[nColumns, nRows];
   }

   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   /// &lt;value&gt;A number from 0 to 32767&lt;/value&gt;
   /// &lt;remarks&gt;Although this member accepts an integer as the value (because that
   /// is the type required by the base class), a layer of this type can only use
   /// 16-bit values.&lt;/remarks&gt;
   public override int this[int x, int y]
   {
      get
      {
         return (int)(m_Tiles[x % m_nColumns, y % m_nRows]);
      }
      set
      {
         m_Tiles[x % m_nColumns, y % m_nRows] = (short)value;
      }
   }

   protected override int[] GetTileFrame(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]].CurrentFrame;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="LayerBase.GetTile"/&gt;.
   /// &lt;/summary&gt;
   public override TileBase GetTile(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]];
   }
}

/// &lt;summary&gt;
/// Represents a layer where each tile is represented as a single byte.
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class ByteLayer : LayerBase
{
   private byte[,] m_Tiles;

   public ByteLayer(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer,
      int nBottomBuffer, int nColumns, int nRows, int nVirtualColumns, int nVirtualRows, System.Drawing.Point Position,
      System.Drawing.SizeF ScrollRate, int nInjectStartIndex, int nAppendStartIndex, string Name) : 
      base(Tileset, Parent, nLeftBuffer, nTopBuffer, nRightBuffer,
      nBottomBuffer, nColumns, nRows, nVirtualColumns, nVirtualRows, Position,
      ScrollRate, nInjectStartIndex, nAppendStartIndex)
   {
      System.Resources.ResourceManager resources = new System.Resources.ResourceManager(Parent.GetType());
      if (Name != null)
         m_Tiles = (byte[,])(resources.GetObject(Name));
      else
         m_Tiles = new byte[nColumns, nRows];
   }

   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   /// &lt;value&gt;A number from 0 to 255&lt;/value&gt;
   /// &lt;remarks&gt;Although this member accepts an integer as the value (because that
   /// is the type required by the base class), a layer of this type can only use
   /// 8-bit values.&lt;/remarks&gt;
   public override int this[int x, int y]
   {
      get
      {
         return (int)(m_Tiles[x % m_nColumns, y % m_nRows]);
      }
      set
      {
         m_Tiles[x % m_nColumns, y % m_nRows] = (byte)value;
      }
   }

   protected override int[] GetTileFrame(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]].CurrentFrame;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="LayerBase.GetTile"/&gt;.
   /// &lt;/summary&gt;
   public override TileBase GetTile(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]];
   }
}</Text>
  </SourceCode>
  <SourceCode Name="Project.cs" IsCustomObject="false">
    <Text>/*
 * Scrolling Game Development Kit 2.0
 * Generated Project Template Code
 * 
 * Copyright  2000 - 2007 Benjamin Marty &lt;bluemonkmn@users.sourceforge.net&gt;
 * 
 * Distributed under the GNU General Public License (GPL)
 *   - see included file COPYING.txt for details, or visit:
 *     http://www.fsf.org/copyleft/gpl.html
 */
using System;

/// &lt;summary&gt;
/// This class provides global, static data. No instances are created.
/// &lt;/summary&gt;
/// &lt;remarks&gt;This class was created to serve as an interface between
/// generated code and project custom code.  It exists so that the
/// Highest level code (including the entry point) can be customized
/// while still allowing the code generator to provide some high level
/// global properties in the Project.resx file.&lt;/remarks&gt;
public partial class Project
{
   private static System.Resources.ResourceManager m_res;
   private static GameForm game;

   /// &lt;summary&gt;
   /// Defines the maximum number of players that can be active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This determines primarily how many players the user can customize
   /// in the options dialog at runtime. If there is only 1 player, there will be
   /// no dowpdown list to select which player to customize. Note that the actual
   /// number of active players is determined by the rules defined in the project.
   /// &lt;seealso cref="PlanBase.MapPlayerToInputs"/&gt;&lt;/remarks&gt;
   public static readonly System.Byte MaxPlayers;
   /// &lt;summary&gt;
   /// Defines the maxmimum number of views that can be active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This determines which view layouts can be selected with
   /// &lt;see cref="MapBase.ViewLayout"/&gt; and related functions.&lt;/remarks&gt;
   public static readonly System.Byte MaxViews;
   /// &lt;summary&gt;
   /// Contains a string to display in the game's about dialog.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The IDE will automatically merge credits from imported objects
   /// into this string.&lt;/remarks&gt;
   public static readonly string GameCredits;

   /// &lt;summary&gt;
   /// Initializes the project's read-only properties from the resource file
   /// provided by the code generator.
   /// &lt;/summary&gt;
   static Project()
   {
      Project.m_res = new System.Resources.ResourceManager(typeof(Project));
      MaxPlayers = byte.Parse(m_res.GetString("_MaxPlayers"));
      MaxViews = byte.Parse(m_res.GetString("_MaxViews"));
      GameCredits = m_res.GetString("_GameCredits");
   }

   /// &lt;summary&gt;
   /// Returns the object that contains all the graphic sheet resources for the project
   /// (among other things)
   /// &lt;/summary&gt;
   /// &lt;example&gt;A graphic sheet's image can be retrieved from this object using code
   /// like this:
   /// &lt;code&gt;System.Drawing.Bitmap bmpGfx = (System.Drawing.Bitmap)Project.Resources.GetObject("My Sheet")&lt;/code&gt;
   /// &lt;/example&gt;
   public static System.Resources.ResourceManager Resources
   {
      get
      {
         return m_res;
      }
   }

   /// &lt;summary&gt;
   /// Returns the main window object.
   /// &lt;/summary&gt;
   public static GameForm GameWindow
   {
      get
      {
         return Project.game;
      }
   }

   /// &lt;summary&gt;
   /// Represents the main entry point of the program.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This creates the main window, initializing it with the game's startup
   /// map, overlay map, title, and default window mode (windowed or full screen), then
   /// calls &lt;see cref="GameForm.Run"/&gt; and lets it run until the game quits.&lt;/remarks&gt;
   public static void Main()
   {
      try
      {
         GameDisplayMode mode = (GameDisplayMode)System.Enum.Parse(typeof(GameDisplayMode), m_res.GetString("_DisplayMode"));
         bool windowed = bool.Parse(m_res.GetString("_Windowed"));
         string windowTitle = m_res.GetString("_WindowTitle");
         System.Type startupMapType = System.Reflection.Assembly.GetExecutingAssembly().GetType(m_res.GetString("_StartupMapType").Replace(" ","_") + "_Map", true);
         System.Type overlayMapType = null;
         if (m_res.GetString("_OverlayMapType") != null)
             overlayMapType = System.Reflection.Assembly.GetExecutingAssembly().GetType(m_res.GetString("_OverlayMapType").Replace(" ","_") + "_Map", true);

         Project.game = new GameForm(mode, windowed, windowTitle, startupMapType, overlayMapType);
         game.Show();
         game.Run();
      }
      catch (System.Exception ex)
      {
         GameForm.HandleException(ex);
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="PlanBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.ComponentModel;
using System.Drawing;

/// &lt;summary&gt;
/// Base class for "plans", which consist of map coordinates and rules
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class PlanBase : GeneralRules, System.Collections.IEnumerable
{
   /// &lt;summary&gt;
   /// This is provided as a temporary storage area for numbers while processing
   /// plan rules.
   /// &lt;/summary&gt;
   public static int SharedTemp1;

   /// &lt;summary&gt;
   /// This value is used by &lt;see cref="CheckNextCoordinate"/&gt; to determine how close a
   /// sprite must be to a coordinate before heading to the next coordinate.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The default value for this property is 5 pixels.&lt;/remarks&gt;
   [Description("How close must a sprite be to a coordinate in this plan before heading to the next (default=5)")]
   public int TargetDistance = 5;

   protected PointF[] corners = null;

   protected PlanBase()
   {
   }

   /// &lt;summary&gt;
   /// Stores information about a coordinate within a &lt;see cref="PlanBase"/&gt;.
   /// &lt;/summary&gt;
   [Serializable()]
   public struct Coordinate
   {
      /// &lt;summary&gt;
      /// The horizontal aspect of this coordinate
      /// &lt;/summary&gt;
      public int x;
      /// &lt;summary&gt;
      /// The vercial aspect of this coordinate 
      /// &lt;/summary&gt;
      public int y;
      /// &lt;summary&gt;
      /// Can be used to store any additional piece of information about this coordinate,
      /// but &lt;see cref="PlanBase.CheckNextCoordinate"/&gt; will use it to define a wait period
      /// for a sprite arriving at this coordinate before proceeding to the next.
      /// &lt;/summary&gt;
      public int weight;
      /// &lt;summary&gt;
      /// Creates a new coordinate given all its properties
      /// &lt;/summary&gt;
      /// &lt;param name="x"&gt;Provides the &lt;see cref="x"/&gt; value for this coordinate&lt;/param&gt;
      /// &lt;param name="y"&gt;Provides the &lt;see cref="y"/&gt; value for this coordinate&lt;/param&gt;
      /// &lt;param name="weight"&gt;Provides the &lt;see cref="weight"/&gt; calue for this coordinate&lt;/param&gt;
      public Coordinate(int x, int y, int weight)
      {
         this.x = x;
         this.y = y;
         this.weight = weight;
      }
      /// &lt;summary&gt;
      /// Allows a path coordinate to be automatically used as a Point
      /// &lt;/summary&gt;
      public static implicit operator Point(Coordinate value)
      {
         return new Point(value.x, value.y);
      }
   }

   /// &lt;summary&gt;
   /// Returns the rectangle defined by a plan
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Plans with 2 points define a rectanglular area that can be used
   /// for a variety of purposes. This property will return the plan defined by
   /// the plan's two points for such plans.  It will return an empty regtangle
   /// if the plan does not have exactly 2 points.&lt;/remarks&gt;
   public virtual Rectangle PlanRectangle
   {
      get
      {
         return Rectangle.Empty;
      }
   }


   #region Sprites
   /// &lt;summary&gt;
   /// Make the specified sprite active.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies which sprite instance to activate&lt;/param&gt;
   /// &lt;remarks&gt;If the specified sprite instance is already active, this has
   /// no effect.&lt;/remarks&gt;
   [Description("Make the specified sprite active.")]
   public virtual void ActivateSprite(SpriteBase Target)
   {
      Target.isActive = true;
   }

   /// &lt;summary&gt;
   /// Make the specified sprite inactive.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies which sprite instance to deactivate&lt;/param&gt;
   /// &lt;remarks&gt;If the specified sprite instance is already inactive, this
   /// has no effect.&lt;/remarks&gt;
   [Description("Make the specified sprite inactive.")]
   public virtual void DeactivateSprite(SpriteBase Target)
   {
      Target.isActive = false;
   }

   /// &lt;summary&gt;
   /// Set the position of the target sprite to match that of the source sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite whose position will change.&lt;/param&gt;
   /// &lt;param name="Source"&gt;Specifies the sprite whose position is copied.&lt;/param&gt;
   /// &lt;remarks&gt;This very simply copies the position from the source sprite to that
   /// of the target sprite. No tests are performed for solidity and no velocity is
   /// changed. The old position of the target sprite, however, is tracked, so it's
   /// still possible to determine if the sprite was touching a tile or plan before
   /// it moved with a function like &lt;see cref="WasSpriteTouching"/&gt;.
   /// &lt;seealso cref="TransportToPoint"/&gt;
   /// &lt;seealso cref="TransportToPlan"/&gt;&lt;/remarks&gt;
   [Description("Set the position of the target sprite to match that of the source sprite.")]
   public virtual void MatchSpritePosition(SpriteBase Target, SpriteBase Source)
   {
      Target.oldX = Target.x;
      Target.oldY = Target.y;
      Target.x = Source.x;
      Target.y = Source.y;
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite is touching this plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite's solidity rectangle is touching this plan's rectangle,
   /// otherwise false.&lt;/returns&gt;
   /// &lt;remarks&gt;"Touching" means one rectangle is overlapping the other, or the borders
   /// are immediately adjacent. The rectangles are not considered touching if the corners
   /// are only diagonally adjacent (kitty-corner). There must be some length of adjecent
   /// edge. This ensures that a plan that is blocked off by two diagonally-arranged
   /// solid blocks can't be touched (and thus potentially "activated") through the crack.
   /// &lt;/remarks&gt;
   [Description("Returns true if the specified sprite is touching this plan's rectangle")]
   public virtual bool IsSpriteTouching(SpriteBase sprite)
   {
      if (!sprite.isActive)
         return false;

      Rectangle spriteRect = new Rectangle(sprite.PixelX, sprite.PixelY, sprite.SolidWidth, sprite.SolidHeight);
      Rectangle targetRect = PlanRectangle;
      if (!spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,2)))
         return false;
      if (spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,0)) ||
         spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,0,2)))
         return true;
      else
         return false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified part of the specified sprite is within the plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite whose position will be tested&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies a point within the sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point within the specified sprite's solidity rectangle is
   /// within the plan's rectangle.&lt;/returns&gt;
   /// &lt;remarks&gt;Unlike &lt;see cref="IsSpriteTouching"/&gt;, this can only return true when the sprite
   /// and the plan's rectangle actually overlap because the point is inside the sprite's
   /// rectangle, and must also be inside the plan's rectangle to return true.
   /// &lt;seealso cref="GetSpriteWithin"/&gt;&lt;seealso cref="IsSpriteWithinPolygon"/&gt;&lt;/remarks&gt;
   [Description("Returns true if the specified part of the specified sprite is within the plan's rectangle")]
   public virtual bool IsSpriteWithin(SpriteBase sprite, RelativePosition RelativePosition)
   {
      System.Drawing.Point rp = sprite.GetRelativePosition(RelativePosition);
      Rectangle targetRect = PlanRectangle;
      return targetRect.Contains(rp);
   }

   /// &lt;summary&gt;
   /// Determines if the specified part of any active sprite in the specified category is within the plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprites"&gt;Sprite collection to be checked&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies a point within each sprite to test&lt;/param&gt;
   /// &lt;param name="Skip"&gt;Indicates the index to skip over. All sprite indexes up to and including
   /// Skip will be skipped in teh search. This allows the function to be called repeatedly,
   /// passing the previous return value as the Skip value to retrieve the next applicable sprite
   /// index. Specify -1 to search all sprites in the collection.&lt;/param&gt;
   /// &lt;returns&gt;-1 if no active sprite is found in the collection where the specified point of the sprite's
   /// solidity rectangle is within the plan's rectangle. Otherwise the 0-based index of the
   /// first matching sprite is returned.&lt;/returns&gt;
   /// &lt;remarks&gt;This is the same as performing &lt;see cref="IsSpriteWithin"/&gt; for each active sprite
   /// in a collection (beginning with the sprite whose index is after Skip).
   /// &lt;seealso cref="IsSpriteWithin"/&gt;&lt;/remarks&gt;
   [Description("Returns the index of the first active sprite whose specified coordinate is within the plan's rectangle, or -1 if none exist. Indexes up through Skip will be ignored.")]
   public virtual int GetSpriteWithin(SpriteCollection Sprites, RelativePosition RelativePosition, int Skip)
   {
      for (int i=Skip+1; i &lt; Sprites.Count; i++)
      {
         if (Sprites[i].isActive &amp;&amp; (IsSpriteWithin(Sprites[i], RelativePosition)))
            return i;
      }
      return -1;
   }

   [Description("Returns true if the specified part of the specified sprite is within a polygon formed by this plan's coordinates.")]
   /// &lt;summary&gt;
   /// Determines if the specified part of the specified sprite is within a polygon formed by this plan's coordinates.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite whose position will be tested&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies a point within the sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point within the specified sprite's solidity rectangle is
   /// within the polygon.&lt;/returns&gt;
   /// &lt;remarks&gt;
   /// &lt;seealso cref="IsSpriteWithin"/&gt;&lt;/remarks&gt;
   public virtual bool IsSpriteWithinPolygon(SpriteBase sprite, RelativePosition RelativePosition)
   {
      System.Drawing.Point rp = sprite.GetRelativePosition(RelativePosition);
      bool result = false;
      for (int i = 0, j = Count - 1; i &lt; Count; j = i++)
      {
         int x1 = Coordinates[i].x;
         int y1 = Coordinates[i].y;
         int x2 = Coordinates[j].x;
         int y2 = Coordinates[j].y;
         if ((((y1 &lt;= rp.Y) &amp;&amp; (rp.Y &lt; y2)) ||
              ((y2 &lt;= rp.Y) &amp;&amp; (rp.Y &lt; y1))) &amp;&amp;
             (rp.X &lt; (x2 - x1) * (rp.Y - y1) / (y2 - y1) + x1))
            result = !result;
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite was touching this plan's rectangle in the previous frame.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the specified sprite was touching this plan's rectangle previously, or false
   /// if it wasn't.&lt;/returns&gt;
   /// &lt;remarks&gt;This function is identical to &lt;see cref="IsSpriteTouching"/&gt; except that it operates
   /// on the sprite's previous position instead of its current position. This is useful for
   /// determining if the sprite just started touching a plan's rectangle or was already touching
   /// it. Often times it's desirable to perform an automated action like a message only
   /// when a sprite initially touches a plan's rectangle. It's not as desirable for plan rules
   /// that also require other conditions to activate.
   /// Consider, for example, a plan that displays
   /// a message when the sprite touches it. This plan can automatically display the message only
   /// when the sprite first touches the plan, and everything will be fine. But what happens if
   /// it's also required that a button be pressed to activate the rule?  The player may start
   /// touching the plan without touching the button.  Then when the player presses the button,
   /// the rule won't activate because this is no longer the frame when the sprite initially
   /// started touching the plan, so the plan may never get activated.
   /// &lt;/remarks&gt;
   [Description("Returns true if the specified sprite was touching this plan's rectangle in the previous frame")]
   public virtual bool WasSpriteTouching(SpriteBase sprite)
   {
      Rectangle spriteRect = new Rectangle(sprite.OldPixelX, sprite.OldPixelY, sprite.SolidWidth, sprite.SolidHeight);
      Rectangle targetRect = PlanRectangle;
      if (!spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,2)))
         return false;
      if (spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,0)) ||
         spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,0,2)))
         return true;
      else
         return false;
   }


   /// &lt;summary&gt;
   /// Scroll all layers on this plan's layer's map so that the specified sprite is within the visible area of the map.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Specified which sprite will be scrolled into view.&lt;/param&gt;
   /// &lt;param name="UseScrollMargins"&gt;If true, the layer will scroll the sprite into the scroll margins
   /// of the map, otherwise it will only be scrolled just far enough for the sprite to be fully visible
   /// on the display.&lt;/param&gt;
   /// &lt;remarks&gt;For multi-player games, it may be desirable to set UseScrollMargins to false
   /// to allow at least one player to get closer to the edge of the screen without trying to
   /// keep it scrolled so strictly within the scroll margin area.
   /// &lt;seealso cref="PushSpriteIntoView"/&gt;&lt;/remarks&gt;
   [Description("Scroll all layers on this plan's layer's map so that the specified sprite is within the visible area of the map.  If UseScrollMargins is true, the layer will scroll the sprite into the scroll margins of the map.")]
   public virtual void ScrollSpriteIntoView(SpriteBase Sprite, bool UseScrollMargins)
   {
      ParentLayer.ScrollSpriteIntoView(Sprite, UseScrollMargins);
   }

   /// &lt;summary&gt;
   /// Alter a sprite's velocity so that it remains within the map's visible area.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite that should be pushed&lt;/param&gt;
   /// &lt;param name="StayInScrollMargins"&gt;True to push the sprite until it is within the scroll
   /// margins of the map or false to push it only until it is fully visible.&lt;/param&gt;
   /// &lt;remarks&gt;This can be useful in multi-player games to not only ensure that the view
   /// remains focused on a particular sprite, but also to ensure that another sprite
   /// (another player) can't leave the view (in cases where both players are shown in
   /// the same view). &lt;seealso cref="ScrollSpriteIntoView"/&gt;&lt;/remarks&gt;
   [Description("Alter a sprite's velocity so that it remains within the map's visible area or within the scroll margins.")]
   public virtual void PushSpriteIntoView(SpriteBase Sprite, bool StayInScrollMargins)
   {
      ParentLayer.PushSpriteIntoView(Sprite, StayInScrollMargins);
   }

   /// &lt;summary&gt;
   /// Alter the velocity of the specified sprite to go toward a coordinate associated with the current plan.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose velocity will be affected&lt;/param&gt;
   /// &lt;param name="CoordinateIndex"&gt;Indicates the 0-based index of the coordinate in the current plan toward which the sprite will be pushed&lt;/param&gt;
   /// &lt;param name="Force"&gt;How hard to push the sprite in tenths of a pixel per frame per frame&lt;/param&gt;
   /// &lt;remarks&gt;Use this in combination with &lt;see cref="CheckNextCoordinate"/&gt; to make a
   /// sprite follow a series of coordinates in a path. This function is identical to
   /// &lt;see cref="PushSpriteTowardPoint"/&gt; except that it is designed only to operate on
   /// coordinates within the current plan (designated by coordinate index).&lt;/remarks&gt;
   /// &lt;example&gt;
   /// See &lt;see cref="StopSprite"/&gt; for an example.
   /// &lt;/example&gt;
   [Description("Alter the velocity of the specified sprite to go toward a coordinate associated with the current plan.  CoordinateIndex indicates which coordinate in the plan to head toward, and Force is how hard to push the sprite in tenths of a pixel per frame per frame")]
   public virtual void PushSpriteTowardCoordinate(SpriteBase Sprite, int CoordinateIndex, int Force)
   {
      PushSpriteTowardPoint(Sprite, this[CoordinateIndex], Force);
   }

   /// &lt;summary&gt;
   /// Alter the velocity of the specified sprite to go toward a specified location.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;The sprite whose velocity will be affected&lt;/param&gt;
   /// &lt;param name="Target"&gt;Specifies a point toward which the sprite will be pushed&lt;/param&gt;
   /// &lt;param name="Force"&gt;How hard to push the sprite in tenths of a pixel per frame per frame&lt;/param&gt;
   /// &lt;remarks&gt;This function is a more generalized form of &lt;see cref="PushSpriteTowardCoordinate"/&gt;.
   /// Rather than pushing a sprite toward a coordinate in the current plan, it can push it toward
   /// any location that can be represented as a point.&lt;/remarks&gt;
   /// &lt;example&gt;
   /// This example pushes the sprite toward the mouse location.
   /// &lt;code&gt;PushSpriteTowardPoint(m_ParentLayer.m_Plasma_1, ParentLayer.GetMousePosition(), 40);&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Alter the velocity of the specified sprite to go toward a specified location.  Force is how hard to push the sprite in tenths of a pixel per frame per frame")]
   public virtual void PushSpriteTowardPoint(SpriteBase Sprite, Point Target, int Force)
   {
      double dx = Target.X - Sprite.PixelX;
      double dy = Target.Y - Sprite.PixelY;

      // Normalize target vector to magnitude of Force parameter
      double dist = Math.Sqrt(dx * dx + dy * dy);
      if (dist &gt; 0)
      {
         dx = dx * Force / dist / 10;
         dy = dy * Force / dist / 10;

         // Push sprite
         Sprite.dx += dx;
         Sprite.dy += dy;
      }
   }

   /// &lt;summary&gt;
   /// Make a sprite move toward the next coordinate in the plan when appropriate.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite that is following coordinates in this plan&lt;/param&gt;
   /// &lt;param name="CoordinateIndex"&gt;Zero-based index of the coordinate within the plan toward which the sprite is currently heading.&lt;/param&gt;
   /// &lt;param name="WaitCounter"&gt;A variable that is used to count frames while this sprite is waiting at a coordinate for a time period specified by the coordinate's &lt;see cref="Coordinate.weight"/&gt; to elapse.&lt;/param&gt;
   /// &lt;returns&gt;The index of the coordinate toward which the sprite should be heading.&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function determines if the sprite should head toward the next coordinate by
   /// checking if the sprite is within this plan's &lt;see cref="TargetDistance"/&gt; of the specified
   /// coordinate. If it is, then it checks the coordinate's &lt;see cref="Coordinate.weight"/&gt;,
   /// to see if the sprite is supposed to wait at this coordinate.  If it's not supposed to wait,
   /// the function returns the next coordinate index right away. If it is supposed to wait,
   /// the function will only return the next coordinate index if the sprite has waited the
   /// specified number of frames at the current coordinate.&lt;/para&gt;
   /// &lt;para&gt;Normally two sprite parameters are used in conjunction with a sprite that follows
   /// a series of coordinates in a plan, and they are both passed into this function. One
   /// parameter tracks the index of the coordinate toward which the the sprite is currently
   /// heading. The other tracks how long the sprite has waited at the current coordinate.
   /// The coordinate parameter is passed in as the the input for &lt;paramref name="CoordinateIndex"/&gt;
   /// and also specified to receive the output of the function. The wait counter is passed for
   /// the last parameter and is automatically updated when needed because it is passed by reference.
   /// &lt;/para&gt;&lt;seealso cref="PushSpriteTowardCoordinate"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// This example demonstrates the common usage of this function on a sprite named "Plasma 1".
   /// &lt;code&gt;m_ParentLayer.m_Plasma_1.CoordIndex = CheckNextCoordinate(m_ParentLayer.m_Plasma_1, m_ParentLayer.m_Plasma_1.CoordIndex, ref m_ParentLayer.m_Plasma_1.WaitCounter);&lt;/code&gt;
   /// For a more complete example, see &lt;see cref="StopSprite"/&gt;.
   /// &lt;/example&gt;
   [Description("Determine whether the sprite is within the TargetDistance of the specified coordinate, and has waited for the number of frames determined by the coordinate's weight based on the specified WaitCounter after reaching it.  If so, return the next CoordinateIndex, otherwise return the current CoordinateIndex.")]
   public virtual int CheckNextCoordinate(SpriteBase Sprite, int CoordinateIndex, ref int WaitCounter)
   {
      if (WaitCounter &gt; 0)
      {
         if (++WaitCounter &gt; this[CoordinateIndex].weight)
         {
            WaitCounter = 0;
            return (CoordinateIndex + 1) % Count;
         }
         else
            return CoordinateIndex;
      }
      int dx = this[CoordinateIndex].x - Sprite.PixelX;
      int dy = this[CoordinateIndex].y - Sprite.PixelY;
      if (Math.Sqrt(dx * dx + dy * dy) &lt;= TargetDistance)
      {
         if (this[CoordinateIndex].weight &gt; 0)
            WaitCounter++;
         else
            return (CoordinateIndex + 1) % Count;
      }
      return CoordinateIndex;
   }

   /// &lt;summary&gt;
   /// Cause the specified sprite to follow the coordinates in this plan as a path.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite that will follow this plan's path.&lt;/param&gt;
   /// &lt;param name="CoordinateIndex"&gt;0-based index of the coordinate in this plan toward which the sprite is currently heading.  This is usually a parameter of the sprite.&lt;/param&gt;
   /// &lt;param name="WaitCounter"&gt;Counter that tracks how long a sprite has waited at a particular coordinage. This is usualyl a parameter of the sprite.&lt;/param&gt;
   /// &lt;remarks&gt;This function combines a number of other path-following rule functions into a single
   /// simple function that you can use to make a sprite follow a path with just a single rule.
   /// The following rule functions are combined within this function:
   /// &lt;see cref="IsSpriteActive"/&gt;,
   /// &lt;see cref="PushSpriteTowardCoordinate"/&gt;,
   /// &lt;see cref="StopSprite"/&gt;
   /// &lt;see cref="CheckNextCoordinate"/&gt;,
   /// &lt;note type="caution"&gt;When using this function to follow a path, the sprite definition
   /// itself is responsible for limiting the speed (see &lt;see cref="SpriteBase.LimitVelocity"/&gt;) and
   /// performing the actual movement (see &lt;see cref="SpriteBase.MoveByVelocity"/&gt;).&lt;/note&gt;
   /// &lt;/remarks&gt;
   [Description("Cause the specified sprite to follow the coordinates in this plan as a path, provided some parameters where the current point index and wait counter can be stored.")]
   public virtual void FollowPath(SpriteBase Sprite, ref int CoordinateIndex, ref int WaitCounter)
   {
      if (Sprite.isActive)
      {
         if (WaitCounter == 0)
            PushSpriteTowardCoordinate(Sprite, CoordinateIndex, 10);
         else
            StopSprite(Sprite);
         CoordinateIndex = CheckNextCoordinate(Sprite, CoordinateIndex, ref WaitCounter);
      }
   }

   /// &lt;summary&gt;
   /// Stops the sprite's current motion
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite to be stopped&lt;/param&gt;
   /// &lt;remarks&gt;This stops the current sprite from moving by setting its
   /// &lt;see cref="SpriteBase.dx"/&gt; and &lt;see cref="SpriteBase.dy"/&gt; values
   /// to zero. This may be desired when a sprite reaches a coordinate in
   /// a path where it's supposed to wait, otherwise the sprite may continue
   /// to drift while it waits. One easy way to determine when a sprite is
   /// waiting at a coordinate is to check if the sprite's wait counter parameter
   /// is zero. The wait counter will only be non-zero when the sprite is waiting.
   /// &lt;seealso cref="CheckNextCoordinate"/&gt;
   /// &lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example shows the code used for a sprite named "Plasma 1" that
   /// follows a path and stops and waits at coordinates that have a non-zero weight.
   /// &lt;code lang="C#"&gt;
   /// // If active
   /// if (&lt;see cref="IsSpriteActive"/&gt;(m_ParentLayer.m_Plasma_1))
   /// {
   ///    // If not waiting
   ///    if ((m_ParentLayer.m_Plasma_1.WaitCounter == 0))
   ///    {
   ///       // Move sprite towards coordinate
   ///       &lt;see cref="PushSpriteTowardCoordinate"/&gt;(m_ParentLayer.m_Plasma_1, m_ParentLayer.m_Plasma_1.CoordIndex, 40);
   ///    }
   ///    else
   ///    {
   ///       // Else stop sprite
   ///       &lt;see cref="StopSprite"/&gt;(m_ParentLayer.m_Plasma_1);
   ///    }
   ///    // Move to next coordinate
   ///   m_ParentLayer.m_Plasma_1.CoordIndex = &lt;see cref="CheckNextCoordinate"/&gt;(m_ParentLayer.m_Plasma_1, m_ParentLayer.m_Plasma_1.CoordIndex, ref m_ParentLayer.m_Plasma_1.WaitCounter);
   /// }
   /// &lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Set the velocity of the specified sprite to zero")]
   public virtual void StopSprite(SpriteBase Sprite)
   {
      Sprite.dx = Sprite.dy = 0;
   }

   /// &lt;summary&gt;
   /// Determines whether the specified sprite's collision mask is overlapping part of any
   /// sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="SourceSprite"&gt;A sprite that will be checked for collisions&lt;/param&gt;
   /// &lt;param name="Targets"&gt;A category of sprites against which collisions will be tested&lt;/param&gt;
   /// &lt;returns&gt;The 0-based index of the sprite within &lt;paramref name="Targets"/&gt; if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;The collision mask is derived from the sprite's Mask Alpha Level setting.
   /// If both sprites being tested have a collision mask, they are checked for overlapping solid bits.
   /// If one sprite has Mask Alpha Level set to 0, then a rectangular mask for that sprite
   /// is synthesized from the solid width and solid height using
   /// &lt;see cref="CollisionMask.GetRectangularMask"/&gt;.
   /// If both sprites have Mask Alpha Level set to 0, then a simple rectangular collision
   /// detection is performed (for improved performance).&lt;/remarks&gt;
   [Description("Determine whether the specified sprite's collision mask is overlapping part of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public virtual int TestCollisionMask(SpriteBase SourceSprite, SpriteCollection Targets)
   {
      return SourceSprite.TestCollisionMask(Targets);
   }

   /// &lt;summary&gt;
   /// Determines whether the solidity rectangle of the specified sprite overlaps that
   /// of any sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="SourceSprite"&gt;A sprite that will be checked for collisions&lt;/param&gt;
   /// &lt;param name="Targets"&gt;A category of sprites against which collisions will be tested&lt;/param&gt;
   /// &lt;returns&gt;The 0-based index of the sprite within &lt;paramref name="Targets"/&gt; if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;This can be used to force a simple rectangular collision test even if one or both
   /// sprites involved have a Mask Alpha level greater than 0.  This method is recommended
   /// for improved performance when pixel-perfect collision detection is not required.
   /// &lt;seealso cref="TestCollisionMask"/&gt;&lt;/remarks&gt;
   [Description("Determine whether the solidity rectangle of the specified sprite overlaps that of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public virtual int TestCollisionRect(SpriteBase SourceSprite, SpriteCollection Targets)
   {
      return SourceSprite.TestCollisionRect(Targets);
   }

   /// &lt;summary&gt;
   /// Deactivate a sprite within a category given the sprite's index within the category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Category containing the sprite to deactivate&lt;/param&gt;
   /// &lt;param name="Index"&gt;Zero-based index within the category of the sprite to be deactivated&lt;/param&gt;
   /// &lt;remarks&gt;This can be used in conjunction with the result of a function like
   /// &lt;see cref="TestCollisionRect"/&gt; or &lt;see cref="TestCollisionMask"/&gt; to deactivate the
   /// target sprite when a collision occurs.
   /// &lt;seealso cref="DeactivateSprite"/&gt;&lt;/remarks&gt;
   [Description("Deactivate a sprite within a category given the sprite's index within the category")]
   public virtual void DeactivateCategorySprite(SpriteCollection Category, int Index)
   {
      Category[Index].isActive = false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite instace is active.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite instance to test&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is active, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;The main differences between an active sprite and an inactive
   /// sprite are than only active sprites are drawn when they are in the visible
   /// part of the map, and only active sprites' rules are processed. Using
   /// IsSpriteActive is a good way to determine if a sprite is currently valid
   /// for use because inactive sprites should not have any functions running on
   /// them except to activate them. Most functions will trigger an error message
   /// in debug mode if they find that they are operating on an inactive sprite.
   /// &lt;/remarks&gt;
   /// &lt;example&gt;See &lt;see cref="StopSprite"/&gt; for an example of
   /// IsSpriteActive.&lt;/example&gt;
   [Description("Determines if the specified sprite instace is active.")]
   public virtual bool IsSpriteActive(SpriteBase Sprite)
   {
      return Sprite.isActive;
   }

   /// &lt;summary&gt;
   /// Moves the specified sprite to the specified coordinate.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite instance to be moved&lt;/param&gt;
   /// &lt;param name="target"&gt;Location to which the sprite will be moved&lt;/param&gt;
   /// &lt;remarks&gt;This very simply sets the position of the sprite to a specified
   /// coordinate. No tests are performed for solidity and no velocity is
   /// changed. The old position of the target sprite, however, is tracked, so it's
   /// still possible to determine if the sprite was touching a tile or plan before
   /// it moved with a function like &lt;see cref="WasSpriteTouching"/&gt;.
   /// &lt;seealso cref="MatchSpritePosition"/&gt;
   /// &lt;seealso cref="TransportToPlan"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example could be used to move a sprite to the mouse's location
   /// to make it behave like a mouse cursor.
   /// &lt;code&gt;TransportToPoint(m_ParentLayer.m_Plasma_1, ParentLayer.GetMousePosition());&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Moves the specified sprite to the specified coordinate.")]
   public virtual void TransportToPoint(SpriteBase sprite, Point target)
   {
      sprite.oldX = sprite.x;
      sprite.oldY = sprite.y;
      sprite.x = target.X;
      sprite.y = target.Y;
   }

   /// &lt;summary&gt;
   /// Moves the specified sprite to the specified plan's rectangle, aligned to the specified corner/edge.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite to be moved&lt;/param&gt;
   /// &lt;param name="Plan"&gt;Specifies a target location&lt;/param&gt;
   /// &lt;param name="Alignment"&gt;Specifies how the sprite's solidity rectangle will be aligned with the target plan's rectangle&lt;/param&gt;
   /// &lt;remarks&gt;The specified &lt;paramref name="Plan"/&gt; must be a 2-point plan (specifying a rectangle)
   /// or the function will ignore the request (and display an error in debug mode).
   /// The sprite will be aligned inside the rectangle according to &lt;paramref name="Alignment"/&gt;,
   /// so, for example, if RelativePosition.RightMiddle is specified, the midpoint of the
   /// right side of the sprite's solidity rectangle will be aligned to the midpoint of the
   /// right side of the plan's rectangle.&lt;/remarks&gt;
   [Description("Moves the specified sprite to the specified plan's rectangle, aligned to the specified corner/edge.")]
   public virtual void TransportToPlan(SpriteBase Sprite, PlanBase Plan, RelativePosition Alignment)
   {
      System.Diagnostics.Debug.Assert(!Plan.PlanRectangle.IsEmpty, "TransportToPlan was called on a plan that does not have a rectangle defined.");
      if (Plan.PlanRectangle.IsEmpty)
         return;
      switch(Alignment)
      {
         case RelativePosition.TopLeft:
         case RelativePosition.TopCenter:
         case RelativePosition.TopRight:
            Sprite.y = Plan.PlanRectangle.Y;
            break;
         case RelativePosition.LeftMiddle:
         case RelativePosition.CenterMiddle:
         case RelativePosition.RightMiddle:
            Sprite.y = Plan.PlanRectangle.Y + (int)((Plan.PlanRectangle.Height - Sprite.SolidHeight)/2);
            break;
         default:
            Sprite.y = Plan.PlanRectangle.Y + Plan.PlanRectangle.Height - Sprite.SolidHeight;
            break;
      }
      switch(Alignment)
      {
         case RelativePosition.TopLeft:
         case RelativePosition.LeftMiddle:
         case RelativePosition.BottomLeft:
            Sprite.x = Plan.PlanRectangle.X;
            break;
         case RelativePosition.TopCenter:
         case RelativePosition.CenterMiddle:
         case RelativePosition.BottomCenter:
            Sprite.x = Plan.PlanRectangle.X + (int)((Plan.PlanRectangle.Width - Sprite.SolidWidth)/2);
            break;
         default:
            Sprite.x = Plan.PlanRectangle.X + Plan.PlanRectangle.Width - Sprite.SolidWidth;
            break;
      }
   }
   
   /// &lt;summary&gt;
   /// Associate the state of the input device for the specified player with the inputs on the specified sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="PlayerNumber"&gt;A number from 1 to &lt;see cref="Project.MaxPlayers"/&gt; indicating which
   /// player's input settings to use.&lt;/param&gt;
   /// &lt;param name="Target"&gt;Specifies which sprite the player should control&lt;/param&gt;
   /// &lt;remarks&gt;This is the basic means by which the input device, as customized for a
   /// particular player, is associated with a sprite, so that the input will control
   /// the sprite for that player. In many cases, it may be easier to use the sprite
   /// definition's version of &lt;see cref="SpriteBase.MapPlayerToInputs"/&gt; so that this
   /// doesn't have to be repeated on every map, however in a multi-player game, it may be
   /// easier or necessary to distinguish the individual players on each map if each player
   /// uses the same sprite definition.&lt;/remarks&gt;
   [Description("Associate the state of the input device for the specified player (1-4) with the inputs on the specified sprite.")]
   public virtual void MapPlayerToInputs(int PlayerNumber, SpriteBase Target)
   {
      Target.MapPlayerToInputs(PlayerNumber);
   }

   #endregion

   /// &lt;summary&gt;
   /// Retrieves a list of coordinates contained in this plan
   /// &lt;/summary&gt;
   protected virtual Coordinate[] Coordinates
   {
      get
      {
         return null;
      }
   }

   /// &lt;summary&gt;
   /// Retrieves the coordinate specified by a 0-based index for this plan
   /// &lt;/summary&gt;
   /// &lt;example&gt;
   /// The following code shows how you might limit the value of a coordinate so that
   /// it doesn't exceed the value of the weight assigned to the first coordinate in
   /// a plan. This indexer property ("this[]") is used to access the coordinates.
   ///&lt;code&gt;if (Counter.AnimationCounter.CurrentValue &gt; this[0].weight)
   ///   Counter.AnimationCounter.CurrentValue = this[0].weight;&lt;/code&gt;
   ///&lt;/example&gt;
   public virtual Coordinate this[int index]
   {
      get
      {
         return Coordinates[index];
      }
   }

   /// &lt;summary&gt;
   /// Retrieves the number of coordinates that this plan contains
   /// &lt;/summary&gt;
   public virtual int Count
   {
      get
      {
         if (Coordinates == null)
            return 0;
         return Coordinates.Length;
      }
   }

   /// &lt;summary&gt;
   /// Executes this plan's rules if any exist.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;An error is raised if no rules exist on this plan.&lt;/remarks&gt;
   public virtual void ExecuteRulesInternal()
   {
      throw new NotImplementedException("Attempted to execute rules on plan " + this.GetType().Name + " without any rules");
   }

   /// &lt;summary&gt;
   /// Allows customization of the way &lt;see cref="ExecuteRulesInternal"/&gt; is called.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The default implementation simply calls ExecuteRulesInternal,
   /// but a partial class of the derived class may override this behavior,
   /// calling ExecuteRulesInternal conditionally.&lt;/remarks&gt;
   public virtual void ExecuteRules() { ExecuteRulesInternal(); }

   /// &lt;summary&gt;
   /// Specifies one of the 4 color channels: alpha, red, green or blue.
   /// &lt;/summary&gt;
   public enum ColorChannel
   {
      Blue,
      Green,
      Red,
      Alpha
   }

   /// &lt;summary&gt;
   /// Modulate/scale the specified color channel of the specified sprite to the specified level.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose appearance will be altered/restored&lt;/param&gt;
   /// &lt;param name="Channel"&gt;Which color channel will be affected&lt;/param&gt;
   /// &lt;param name="Level"&gt;Specifies the level to which the channel will be modulated&lt;/param&gt;
   /// &lt;remarks&gt;Modulating a color channel means that its output will be scaled down to the
   /// specified level&lt;/remarks&gt;
   /// &lt;example&gt;The following example scales the blue channel to 128 (half) which will cause the
   /// sprite to appear more yellow, green or red than normal:
   /// &lt;code&gt;ModulateColor(m_ParentLayer.m_Player_1, ColorChannel.Blue, 128);&lt;/code&gt;
   /// The following example scales the alpha channel to 128 (half) which will cause the
   /// sprite to appear semi-transparent:
   /// &lt;code&gt;ModulateColor(m_ParentLayer.m_Player_1, ColorChannel.Alpha, 128);&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Modulate/scale the specified color channel of the specified sprite to the specified level (0-255)")]
   public virtual void ModulateColor(SpriteBase Sprite, ColorChannel Channel, int Level)
   {
      switch(Channel)
      {
         case ColorChannel.Blue:
            Sprite.ModulateBlue = Level;
            break;
         case ColorChannel.Green:
            Sprite.ModulateGreen = Level;
            break;
         case ColorChannel.Red:
            Sprite.ModulateRed = Level;
            break;
         case ColorChannel.Alpha:
            Sprite.ModulateAlpha = Level;
            break;
      }
   }

   
   #region Inventory / Overlay
   /// &lt;summary&gt;
   /// Specifies a drawing style for inventory/status-type bars drawn with &lt;see cref="DrawCounterAsTile"/&gt;.
   /// &lt;/summary&gt;
   public enum DrawStyle
   {
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched to fill the width of plan, and the right side
      /// is cropped according to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches the maximum, the full tile is drawn, otherwise
      /// the clipping size is scaled according to the ratio of the counter's current value to
      /// its maximum value. The tile image is only stretched horizontally. The vertical size
      /// remains at the tile's original height.&lt;/remarks&gt;
      ClipRightToCounter,
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched rightward according to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will fill the plan rectangle's width.
      /// Otherwise the image is scaled down horizontally to fill the left portion of the plan
      /// rectangle as determined by the ratio of the counter's current value to its
      /// maximum value.&lt;/remarks&gt;
      StretchRightToCounter,
      /// &lt;summary&gt;
      /// The specified tile is draw unscaled from left to right, repeated according
      /// to the counter value and plan size.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will be repeated from the
      /// plan's left side to its right side, as many whole copies as can fit in the plan
      /// rectangle.  Otherwise, the number of copies of the tile that are drawn is based
      /// on the counter value and the maximum number than can be drawn in the plan rectangle.
      /// The result is rounded to a whole number (partial tiles are not drawn). Because of
      /// the way this style works, you will probably want to make sure the number of copies
      /// of the tile that can fit in the plan rectangle exactly matches the counter's maximum
      /// value.&lt;/remarks&gt;
      RepeatRightToCounter,
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched to fill the height of the plan, and the top is
      /// cropped according to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches the maximum, the full tile is drawn, otherwise
      /// the clipping size is scaled according to the ratio of the counter's current value to
      /// its maximum value. The tile image is only stretched vertically. The horizontal size
      /// remains at the tile's original width.&lt;/remarks&gt;
      ClipTopToCounter,
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched upward from the bottom of the plan according
      /// to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will fill the plan rectangle's height.
      /// Otherwise the image is scaled down vertically to fill the bottom portion of the plan
      /// rectangle as determined by the ratio of the counter's current value to its
      /// maximum value.&lt;/remarks&gt;
      StretchTopToCounter,
      /// &lt;summary&gt;
      /// The specified tile is draw unscaled from bottom to top, repeated according
      /// to the counter value and plan size.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will be repeated from the
      /// plan's bottom to its top, as many whole copies as can fit in the plan rectangle.
      /// Otherwise, the number of copies of the tile that are drawn is based on the counter
      /// value and the maximum number than can be drawn in the plan rectangle.
      /// The result is rounded to a whole number (partial tiles are not drawn). Because of
      /// the way this style works, you will probably want to make sure the number of copies
      /// of the tile that can fit in the plan rectangle exactly matches the counter's maximum
      /// value.&lt;/remarks&gt;
      RepeatUpToCounter
   }

   /// &lt;summary&gt;
   /// Draw the value of a counter as a bar filled with a tile's image.
   /// &lt;/summary&gt;
   /// &lt;param name="TileIndex"&gt;Specifies the index of a tile from this plan's layer&lt;/param&gt;
   /// &lt;param name="counter"&gt;Specifies which counter's value is being drawn&lt;/param&gt;
   /// &lt;param name="style"&gt;Specifies a style with which the tile will fill the bar&lt;/param&gt;
   /// &lt;remarks&gt;The size of the plan determines the maximum proportions of the bar.
   /// The counter value determines the drawn/current size of the bar.
   /// See &lt;see cref="DrawStyle"/&gt; for details about the different ways in which the bar
   /// can be filled.&lt;/remarks&gt;
   [Description("Draw the specified tile from the layer's tileset in this plan's rectangle according to the specified counter value")]
   public virtual void DrawCounterAsTile(int TileIndex, Counter counter, DrawStyle style)
   {
      System.Diagnostics.Debug.Assert(!PlanRectangle.IsEmpty, "DrawCounterAsTile was called on a plan that does not have a rectangle defined");
      if (PlanRectangle.IsEmpty)
         return;
      if (counter.CurrentValue == 0)
         return;
      MapBase map = ParentLayer.ParentMap;
      Display disp = map.Display;
      Tileset ts = ParentLayer.Tileset;
      Frameset fr = ts.GetFrameset(ParentLayer.ParentMap.Display);
      Rectangle CurrentView = ParentLayer.ParentMap.CurrentView;

      int lastColor = 0;

      switch(style)
      {
         case DrawStyle.ClipRightToCounter:
            disp.Scissor(new Rectangle(
               PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
               PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
               PlanRectangle.Width * counter.CurrentValue / counter.MaxValue,
               PlanRectangle.Height));
            if ((corners == null) &amp;&amp; (ts[TileIndex].CurrentFrame.Length &gt; 0))
               corners = new PointF[fr[0].Corners.Length];
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               for (int i = 0; i &lt; corners.Length; i++)
               {
                  corners[i].X = fr[frameIndex].Corners[i].X * PlanRectangle.Width / ts.TileWidth;
                  corners[i].Y = fr[frameIndex].Corners[i].Y;
               }

               if (fr[frameIndex].Color != lastColor)
               {
                  disp.SetColor(fr[frameIndex].Color);
                  lastColor = fr[frameIndex].Color;
               }
               disp.DrawFrame(fr[frameIndex].GraphicSheetTexture,
                  fr[frameIndex].SourceRect, corners,
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y);
            }
            break;
         case DrawStyle.StretchRightToCounter:
            disp.ScissorOff();
            if ((corners == null) &amp;&amp; (ts[TileIndex].CurrentFrame.Length &gt; 0))
               corners = new PointF[fr[0].Corners.Length];
            foreach (int frameIndex in ts[TileIndex].CurrentFrame)
            {
               for (int i = 0; i &lt; corners.Length; i++)
               {
                  corners[i].X = fr[frameIndex].Corners[i].X * PlanRectangle.Width * counter.CurrentValue / counter.MaxValue / ts.TileWidth;
                  corners[i].Y = fr[frameIndex].Corners[i].Y;
               }

               if (fr[frameIndex].Color != lastColor)
               {
                  disp.SetColor(fr[frameIndex].Color);
                  lastColor = fr[frameIndex].Color;
               }
               disp.DrawFrame(fr[frameIndex].GraphicSheetTexture,
                  fr[frameIndex].SourceRect, corners,
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y);
            }
            break;
         case DrawStyle.RepeatRightToCounter:
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               int FillWidth = PlanRectangle.Width * counter.CurrentValue / counter.MaxValue;
               if (fr[frameIndex].Color != lastColor)
               {
                  disp.SetColor(fr[frameIndex].Color);
                  lastColor = fr[frameIndex].Color;
               }
               for (int repeat = 0; repeat &lt; (int)Math.Ceiling(FillWidth / (float)ts.TileWidth); repeat++)
               {
                  disp.DrawFrame(fr[frameIndex].GraphicSheetTexture,
                     fr[frameIndex].SourceRect, fr[frameIndex].Corners,
                     PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X + repeat * ts.TileWidth,
                     PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y);
               }
            }
            break;
         case DrawStyle.ClipTopToCounter:
         {
            int FillHeight = PlanRectangle.Height * counter.CurrentValue / counter.MaxValue;
            if ((corners == null) &amp;&amp; (ts[TileIndex].CurrentFrame.Length &gt; 0))
               corners = new PointF[fr[0].Corners.Length];
            disp.Scissor(new Rectangle(
               PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
               PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y +
               PlanRectangle.Height - FillHeight, PlanRectangle.Width, FillHeight));
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               for (int i = 0; i &lt; corners.Length; i++)
               {
                  corners[i].X = fr[frameIndex].Corners[i].X;
                  corners[i].Y = fr[frameIndex].Corners[i].Y * PlanRectangle.Height / ts.TileHeight;
               }
               if (fr[frameIndex].Color != lastColor)
               {
                  disp.SetColor(fr[frameIndex].Color);
                  lastColor = fr[frameIndex].Color;
               }
               disp.DrawFrame(fr[frameIndex].GraphicSheetTexture,
                  fr[frameIndex].SourceRect, corners,
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y);
            }
         }
            break;
         case DrawStyle.StretchTopToCounter:
         {
            disp.ScissorOff();
            int FillHeight = PlanRectangle.Height * counter.CurrentValue / counter.MaxValue;
            if ((corners == null) &amp;&amp; (ts[TileIndex].CurrentFrame.Length &gt; 0))
               corners = new PointF[fr[0].Corners.Length];
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               for (int i = 0; i &lt; corners.Length; i++)
               {
                  corners[i].X = fr[frameIndex].Corners[i].X;
                  corners[i].Y = fr[frameIndex].Corners[i].Y * FillHeight / ts.TileHeight;
               }

               if (fr[frameIndex].Color != lastColor)
               {
                  disp.SetColor(fr[frameIndex].Color);
                  lastColor = fr[frameIndex].Color;
               }
               disp.DrawFrame(fr[frameIndex].GraphicSheetTexture,
                  fr[frameIndex].SourceRect, corners,
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y + PlanRectangle.Height - FillHeight);
            }
         }
            break;
         case DrawStyle.RepeatUpToCounter:
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               int FillHeight = PlanRectangle.Height * counter.CurrentValue / counter.MaxValue;
               disp.ScissorOff();
               if (fr[frameIndex].Color != lastColor)
               {
                  disp.SetColor(fr[frameIndex].Color);
                  lastColor = fr[frameIndex].Color;
               }
               for (int repeat = 0; repeat &lt; (int)Math.Ceiling(FillHeight / (float)ts.TileHeight); repeat++)
               {
                  disp.DrawFrame(fr[frameIndex].GraphicSheetTexture, fr[frameIndex].SourceRect, fr[frameIndex].Corners,
                     PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                     PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y + PlanRectangle.Height - repeat * ts.TileHeight - ts.TileHeight);
               }
            }
            break;
      }
      disp.Flush();
   }

   /// &lt;summary&gt;
   /// Display a counter value as a number with a label in the current plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Label"&gt;String containing the text of the label&lt;/param&gt;
   /// &lt;param name="counter"&gt;Counter whose value will be displayed&lt;/param&gt;
   /// &lt;param name="color"&gt;Color of the label and quantity text&lt;/param&gt;
   /// &lt;remarks&gt;The label and quantity are merged into a single string of
   /// text and drawn at the top left corner of the plan's rectangle.&lt;/remarks&gt;
   [Description("Display a counter value as a number with a label in the current plan's rectangle")]
   public virtual void DrawCounterWithLabel(string Label, Counter counter, System.Drawing.KnownColor color)
   {
      System.Diagnostics.Debug.Assert(!PlanRectangle.IsEmpty, "DrawCounterAsTile was called on a plan that does not have a rectangle defined");
      if (PlanRectangle.IsEmpty)
         return;
      
      Display disp = ParentLayer.ParentMap.Display;
      disp.ScissorOff();
      disp.SetColor(Color.FromKnownColor(color));
      disp.DrawText(Label.ToString() + counter.CurrentValue.ToString(), PlanRectangle.Left, PlanRectangle.Top);
      disp.Flush();
   }
   #endregion

   protected virtual void CopyTiles(PlanBase Source, PlanBase Target, RelativePosition RelativePosition)
   {
      int src_left = (int)(Source.PlanRectangle.X / Source.ParentLayer.Tileset.TileWidth);
      int src_top = (int)(Source.PlanRectangle.Y / Source.ParentLayer.Tileset.TileHeight);
      int src_right = (int)((Source.PlanRectangle.X + Source.PlanRectangle.Width - 1) / Source.ParentLayer.Tileset.TileWidth);
      int src_bottom = (int)((Source.PlanRectangle.Y + Source.PlanRectangle.Height - 1) / Source.ParentLayer.Tileset.TileHeight);

      int dst_left = (int)(Target.PlanRectangle.X / Target.ParentLayer.Tileset.TileWidth);
      int dst_top = (int)(Target.PlanRectangle.Y / Target.ParentLayer.Tileset.TileHeight);
      int dst_right = (int)((Target.PlanRectangle.X + Target.PlanRectangle.Width - 1) / Target.ParentLayer.Tileset.TileWidth);
      int dst_bottom = (int)((Target.PlanRectangle.Y + Target.PlanRectangle.Height - 1) / Target.ParentLayer.Tileset.TileHeight);

      for (int y = src_top; y &lt;= src_bottom; y++)
      {
         int targety;
         switch(RelativePosition)
         {
            case RelativePosition.TopLeft:
            case RelativePosition.TopCenter:
            case RelativePosition.TopRight:
               targety = dst_top + y - src_top;
               break;
            case RelativePosition.LeftMiddle:
            case RelativePosition.CenterMiddle:
            case RelativePosition.RightMiddle:
               targety = y + (int)(dst_top + dst_bottom - src_top - src_bottom) / 2;
               break;
            default:
               targety = dst_bottom + y - src_bottom;
               break;
         }
         if (targety &lt; 0)
            continue;
         if (targety &gt;= Target.ParentLayer.VirtualRows)
            break;
         for (int x = src_left; x &lt;= src_right; x++)
         {
            int targetx;
            switch(RelativePosition)
            {
               case RelativePosition.TopLeft:
               case RelativePosition.LeftMiddle:
               case RelativePosition.BottomLeft:
                  targetx = dst_left + x - src_left;
                  break;
               case RelativePosition.TopCenter:
               case RelativePosition.CenterMiddle:
               case RelativePosition.BottomCenter:
                  targetx = x + (int)(dst_left + dst_right - src_left - src_right) / 2;
                  break;
               default:
                  targetx = dst_right + x - src_right;
                  break;
            }
            if (targetx &lt; 0)
               continue;
            if (targetx &gt;= Target.ParentLayer.VirtualColumns)
               break;
            
            Target.ParentLayer[targetx,targety] = Source.ParentLayer[x,y];
         }
      }
   }

   /// &lt;summary&gt;
   /// Copy tiles from this plan's rectangle to another plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies another plan specifying a location to which tiles will be copied&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies the alignment of the tiles in the target rectangle if
   /// this plan's rectangle is a different size&lt;/param&gt;
   /// &lt;remarks&gt;If the source rectangle is larger than the target rectangle, the copy
   /// locations will be aligned according to RelativePosition, and the copied tiles
   /// will be allowed to overflow the target rectangle.  For example, if the alignment
   /// is &lt;see cref="RelativePosition.RightMiddle"/&gt;, the right middle tile of the source
   /// rectangle will be copied into the right middle tile of the target rectangle, and
   /// build around there regardless of the target rectangle's size.&lt;/remarks&gt;
   [Description("Copy tiles from this plan's rectangle to another plan's rectangle.")]
   public virtual void CopyTo(PlanBase Target, RelativePosition RelativePosition)
   {
      CopyTiles(this, Target, RelativePosition);
   }

   /// &lt;summary&gt;
   /// Copy tiles from the specified plan's rectangle to this plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Source"&gt;Specifies another plan specifying a location from which tiles will be copied&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies the alignment of the tiles in this plan's rectangle if
   /// the source plan's rectangle is a different size&lt;/param&gt;
   /// &lt;remarks&gt;If the source rectangle is larger than the target rectangle, the copy
   /// locations will be aligned according to RelativePosition, and the copied tiles
   /// will be allowed to overflow the target rectangle.  For example, if the alignment
   /// is &lt;see cref="RelativePosition.RightMiddle"/&gt;, the right middle tile of the source
   /// rectangle will be copied into the right middle tile of the target rectangle, and
   /// build around there regardless of the target rectangle's size.&lt;/remarks&gt;
   [Description("Copy tiles from the specified plan's rectangle to this plan's rectangle.")]
   public virtual void CopyFrom(PlanBase Source, RelativePosition RelativePosition)
   {
      CopyTiles(Source, this, RelativePosition);
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite's specified input is pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose inputs will be examined&lt;/param&gt;
   /// &lt;param name="Input"&gt;Specifies which input will be examined&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;When true only return true if the input has just been pressed and was not pressed before&lt;/param&gt;
   /// &lt;returns&gt;True if the input is pressed, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;The &lt;see cref="SpriteBase.IsInputPressed"/&gt; function for sprite definitions is
   /// more commonly used, but this allows you to test a specific sprite's inputs on a specific
   /// layer.&lt;/remarks&gt;
   [Description("Determine if the specified sprite's specified input is pressed.  InitialOnly causes this to return true only if the input has just been pressed and was not pressed before.")]
   public virtual bool IsInputPressed(SpriteBase Sprite, SpriteBase.InputBits Input, bool InitialOnly)
   {
      return Sprite.IsInputPressed(Input, InitialOnly);
   }

   /// &lt;summary&gt;
   /// Ensure that all the inputs currently being pressed on the specified sprite are henceforth processed as already pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose inputs will be shifted.&lt;/param&gt;
   /// &lt;remarks&gt;This is usually handled by &lt;see cref="MapPlayerToInputs"/&gt;, but if you
   /// have customized the factors that affect the inputs, you may need to manually
   /// shift the current inputs into the old inputs to allow correct handling for
   /// "InitialOnly" parameters.&lt;/remarks&gt;
   [Description("Ensure that all the inputs currently being pressed on the specified sprite are henceforth processed as already pressed.")]
   public virtual void CopyInputsToOld(SpriteBase Sprite)
   {
      Sprite.oldinputs = Sprite.inputs;
   }

   /// &lt;summary&gt;
   /// Create a new (dynamic) instance of the specified sprite type at the first coordinate
   /// in this plan.
   /// &lt;/summary&gt;
   /// &lt;param name="SpriteDefinition"&gt;Specifies the type of sprite that will be created.&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specified a coordinate within the sprite that should be
   /// matched up with the first coordinate of the plan.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;As opposed to &lt;see cref="ActivateSprite"/&gt;, which activates a pre-defined
   /// instance of a sprite, this function will actually create a new sprite instance on the
   /// fly (referred to as a "dynamic" sprite instance). Dynamic sprites cannot be referred
   /// to directly by other rules because they don't have names associated with them, therefore
   /// it's recommended that &lt;see cref="ActivateSprite"/&gt; be used when more control is
   /// desired. However, &lt;see cref="AddSpriteAtPlan"/&gt; doesn't require you to pre-define each
   /// possible instance.&lt;/para&gt;
   /// &lt;para&gt;Dynamic sprites are added to the end of each category that they belong to
   /// (categories are defined in terms of sprite definitions, so a dynamic sprite knows
   /// the categories in which it should participate). This happens as the sprite is created.
   /// When the sprite is deactivated, it will automatically be removed from all categories
   /// as part of &lt;see cref="LayerBase.ProcessSprites"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;The maximum number of sprites that can be active on a layer at once is
   /// defined by &lt;see cref="SpriteCollection.maxCollectionSize"/&gt;. This includes static
   /// sprites as well as dynamic sprites. The purpose of this maximum is not a technical
   /// limitation (feel free to change the code in SpriteCollection.cs to increase the maximum
   /// all you like). It only exists to help developers realize when sprite instances are
   /// "leaking" (not being cleaned up or deactivated properly) or when more sprites than
   /// necessary are being created. In many cases, the engine can actually handle quite a
   /// bit more than 100 sprites without significant performance impact.&lt;/para&gt;
   /// &lt;para&gt;All parameters of a newly created sprite instance are always initialized
   /// to zero. Furthermore, new sprite instances will not refer to any solidity,
   /// and will begin in the first
   /// frame of the first state, but you can use rules to affect &lt;see cref="GeneralRules.lastCreatedSprite"/&gt;
   /// to set values of the new sprite, or define rules on the created sprite type to make it
   /// initialize itself appropriately.&lt;/para&gt;
   /// &lt;para&gt;If this plan has no coordinates, the sprite is created at the top left corner of
   /// the layer, and not adjusted according to &lt;paramref name="RelativePosition"/&gt;.
   /// &lt;/para&gt;&lt;seealso cref="SpriteBase.AddSpriteHere"/&gt;&lt;seealso cref="SpriteBase.TileAddSprite"/&gt;&lt;/remarks&gt;
   [Description("Add a new instance of the specified sprite type to this plan's layer such that the specified position within the sprite corresponds to the first coordinate in this plan")]
   public virtual void AddSpriteAtPlan([Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition, RelativePosition RelativePosition)
   {
      System.Reflection.ConstructorInfo constructor = SpriteDefinition.GetConstructor(new System.Type[]
      {
         typeof(LayerBase), typeof(double), typeof(double), typeof(double), typeof(double), typeof(int), typeof(int), typeof(bool), typeof(Display), typeof(Solidity), typeof(int), typeof(bool)
      });
      lastCreatedSprite = (SpriteBase)constructor.Invoke(new object[]
      {
         ParentLayer, 0, 0, 0, 0, 0, 0, true, ParentLayer.ParentMap.Display, null, -1, true
      });
      if (Count &gt; 0)
      {
         System.Drawing.Point offset = lastCreatedSprite.GetRelativePosition(RelativePosition);
         lastCreatedSprite.x = Coordinates[0].x - offset.X;
         lastCreatedSprite.y = Coordinates[0].y - offset.Y ;
      }
   }

   /// &lt;summary&gt;
   /// Push the specified Source sprite toward the specified Target sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Source"&gt;Sprite to push.&lt;/param&gt;
   /// &lt;param name="Target"&gt;Sprite toward which to push.&lt;/param&gt;
   /// &lt;param name="Force"&gt;Acceleration in tenths of a pixel per frame per frame.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is pushed, false if the sprites are already a the same location.&lt;/returns&gt;
   [Description("Push the specified Source sprite toward the specified Target sprite. Force is in tenths of a pixel per frame per frame.")]
   public virtual bool PushSpriteTowardSprite(SpriteBase Source, SpriteBase Target, int Force)
   {
      return Source.PushTowardSprite(Target, Force);
   }

   /// &lt;summary&gt;
   /// Move the specified sprite to the position of the mouse cursor and set the sprite's button inputs based on mouse button states.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite to be moved.&lt;/param&gt;
   /// &lt;param name="InstantMove"&gt;If true, the sprite will be moved immediately without regard to
   /// the existing position or solidity or anything else.  If false, the sprite's position will
   /// not be immediately changed, but its velocity will be set so that the sprite will end up at
   /// the mouse cursor's location after &lt;see cref="SpriteBase.MoveByVelocity"/&gt; executes. Note that moving
   /// the sprite instantly will ignore solidity and will not work well with sprites riding on
   /// this sprite, while allowing just the velocity to be set will allow this, but limit the
   /// sprite's movement based on solidity.&lt;/param&gt;
   /// &lt;param name="hotSpot"&gt;Which part of the sprite will move to the mouse point.&lt;/param&gt;
   /// &lt;remarks&gt;Before the button inputs are mapped from the mouse to the sprite,
   /// the existing inputs are copied from &lt;see cref="SpriteBase.inputs"/&gt; to &lt;see cref="SpriteBase.oldinputs"/&gt;
   /// so other rules will be able to determine which buttons were pressed before.
   /// &lt;/remarks&gt;
   [Description("Move the specified sprite to the position of the mouse cursor and set the sprite's button inputs based on mouse button states. If InstantMove is true, the sprite will be moved immediately, otherwise it the velocity will be set to move when MoveByVelocity runs.")]
   public virtual void MapMouseToSprite(SpriteBase Target, bool InstantMove, RelativePosition hotSpot)
   {
      Target.MapMouseToSprite(InstantMove, hotSpot);
   }

   /// &lt;summary&gt;
   /// If any sprite in the specified category is within the bounds of this plan or
   /// the Target plan, and is pressing the specified Trigger, transport it to the
   /// other plan.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the plan representing the other end of this doorway&lt;/param&gt;
   /// &lt;param name="Sprites"&gt;Specifies a category of sprites that can activate this doorway&lt;/param&gt;
   /// &lt;param name="Trigger"&gt;Specifies which input bit on the sprite will cause the
   /// sprite to activate the doorway and be transported to the other end.&lt;/param&gt;
   /// &lt;returns&gt;If any sprites were transported, the index within the collection of the first
   /// sprite that was transported, otherwise -1&lt;/returns&gt;
   /// &lt;remarks&gt;This function handles both ends of a doorway and will allow a sprite to travel
   /// from this end to the Target plan or vice versa when the conditions are met. In order for
   /// the conditions to be met, the center of the sprite must be within the bounds of this
   /// plan rectangle or the Target plan rectangle, and (all) the specified Trigger input(s) must
   /// be on/pressed, and must not have been in the same state before (this prevents the sprite from
   /// flipping repeatedly between both ends of the doorway). If the conditions are met,
   /// the sprite will be transported such that the bottom center of the sprite will match up
   /// with the opposite plan rectangle's bottom center.&lt;/remarks&gt;
   [Description("If any sprite in the specified category is within the bounds of this plan or the Target plan, and is pressing the specified Trigger, transport it to the other plan.")]
   public virtual int Door(PlanBase Target, SpriteCollection Sprites, SpriteBase.InputBits Trigger)
   {
      int result = -1;
      for (int i=0; i&lt;Sprites.Count; i++)
      {
         if (Sprites[i].isActive)
         {
            PlanBase outDoor;
            if (IsSpriteWithin(Sprites[i], RelativePosition.CenterMiddle))
               outDoor = Target;
            else if (Target.IsSpriteWithin(Sprites[i], RelativePosition.CenterMiddle))
               outDoor = this;
            else
               continue;
            if (((Trigger &amp; Sprites[i].inputs) == Trigger) &amp;&amp;
               ((Sprites[i].inputs &amp; Trigger) != (Sprites[i].oldinputs &amp; Trigger)))
            {
               result = i;
               TransportToPlan(Sprites[i], outDoor, RelativePosition.BottomCenter);
            }
         }
      }
      return result;
   }

   #region IEnumerable Members

   /// &lt;summary&gt;
   /// Allows a the coordinates of a plan to be enumerated with a foreach loop.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;An object that enumerates this plan's coordinates.&lt;/returns&gt;
   public virtual System.Collections.IEnumerator GetEnumerator()
   {
      if (Coordinates == null)
         new System.Collections.ArrayList().GetEnumerator();
      return Coordinates.GetEnumerator();
   }

   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="SpriteBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.ComponentModel;
using System.Diagnostics;

/// &lt;summary&gt;
/// Base class for all sprite definitions.
/// &lt;/summary&gt;
[Serializable()]
public abstract partial class SpriteBase : GeneralRules
{
   /// &lt;summary&gt;
   /// Horizontal coordinate of the sprite within its layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Because a sprite can move at non-integer rates, the position is tracked
   /// as a floating point number. &lt;seealso cref="PixelX"/&gt;&lt;/remarks&gt;
   public double x;
   /// &lt;summary&gt;
   /// Vertical coordinage of the sprite within its layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Because a sprite can move at non-integer rates, the position is tracked
   /// as a floating point number. &lt;seealso cref="PixelY"/&gt;&lt;/remarks&gt;
   public double y;
   /// &lt;summary&gt;
   /// Horizontal velocity of the sprite in pixels per frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Negative numbers represent leftward movement while positive numbers
   /// represent rightward movement. This value only represents the final velocity
   /// of the sprite relative to the layer. If the sprite is riding a platform,
   /// see &lt;see cref="LocalDX"/&gt;.&lt;seealso cref="dy"/&gt;&lt;/remarks&gt;
   public double dx;
   /// &lt;summary&gt;
   /// Vertical velocity of the sprite in pixels per frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Negative numbers represent upward movement while positive numbers
   /// represent downward movement. This value only represents the final velocity
   /// of the sprite relative to the layer. If the sprite is riding a platform,
   /// see &lt;see cref="LocalDY"/&gt;.&lt;seealso cref="dx"/&gt;&lt;/remarks&gt;
   public double dy;
   /// &lt;summary&gt;
   /// The value of this sprite's &lt;see cref="x"/&gt; coordinate on the previous frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is set during &lt;see cref="MoveByVelocity"/&gt;.
   /// &lt;seealso cref="OldPixelX"/&gt;&lt;seealso cref="oldY"/&gt;&lt;/remarks&gt;
   public double oldX;
   /// &lt;summary&gt;
   /// The value of this sprite's &lt;see cref="y"/&gt; coordinate on the previous frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is set during &lt;see cref="MoveByVelocity"/&gt;.
   /// &lt;seealso cref="OldPixelY"/&gt;&lt;seealso cref="oldX"/&gt;&lt;/remarks&gt;
   public double oldY;
   /// &lt;summary&gt;
   /// Numeric value corresponding to the sprite's current state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A value of 0 represents the first state listed in this sprite's
   /// list of states. Each subsequent state is the value of the previous plus 1.
   /// You can refer to the sprites State enumeration to refer to states by name, but
   /// the result must be explicitly converted to an integer.
   /// &lt;seealso cref="SwitchToState"/&gt;
   /// &lt;/remarks&gt;
   /// &lt;example&gt;&lt;c&gt;state = (int)State.Left&lt;/c&gt;&lt;/example&gt;
   public int state;
   /// &lt;summary&gt;
   /// Numeric value corresponding to the sprite's current frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The number of valid frames depend on the current state. Each state
   /// has its own sequence of frames. The frame that is displayed depends both on
   /// the number of frames and the repeat count of each frame. &lt;seealso cref="Animate"/&gt;&lt;/remarks&gt;
   public int frame;
   /// &lt;summary&gt;
   /// Stores the inputs that are currently being "pressed" on this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Normally the inputs of a sprite are set by a player, but could
   /// also by explicitly set by rules and other input sources such as saved
   /// input (replaying a previous input sequence). You can cause the sprite
   /// to accelerate in the directions dictated by the input bits with
   /// &lt;see cref="AccelerateByInputs"/&gt;.&lt;seealso cref="AccelerateByInputs"/&gt;
   /// &lt;seealso cref="IsInputPressed"/&gt;&lt;seealso cref="SetInputState"/&gt;
   /// &lt;seealso cref="ClearInputs"/&gt;&lt;seealso cref="MapKeyToInput"/&gt;
   /// &lt;seealso cref="MapPlayerToInputs"/&gt;&lt;seealso cref="oldinputs"/&gt;&lt;/remarks&gt;
   public InputBits inputs;
   /// &lt;summary&gt;
   /// Remembers the inputs that were active on this sprite in the previous frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is used to determine when a player (or other input source)
   /// has just started pressing an input versus continued pressing an input that was
   /// already pressed. It is copied from &lt;see cref="inputs"/&gt; when
   /// &lt;see cref="MapPlayerToInputs"/&gt; is called.&lt;seealso cref="inputs"/&gt;
   /// &lt;seealso cref="MapPlayerToInputs"/&gt;&lt;seealso cref="IsInputPressed"/&gt;&lt;/remarks&gt;
   public InputBits oldinputs;
   /// &lt;summary&gt;
   /// Determines if this sprite is currently active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Only active sprites will be drawn and process rules. Attempting to
   /// refer to an inactive sprite from an active rule (on an active sprite or plan)
   /// will result in an error message in debug mode. &lt;seealso cref="Deactivate"/&gt;
   /// &lt;seealso cref="TileActivateSprite"/&gt;&lt;/remarks&gt;
   public bool isActive;
   protected LayerBase layer;
   protected Solidity m_solidity;
   /// &lt;summary&gt;
   /// A combination of &lt;see cref="ModulateRed"/&gt;, &lt;see cref="ModulateGreen"/&gt;,
   /// &lt;see cref="ModulateBlue"/&gt; and &lt;see cref="ModulateAlpha"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;para&gt;This member stores the actual data for all 4 of the Modulate properties
   /// that affect the sprite's color. Using the Modulate properties is easier to
   /// read and understand, but setting this property directly is simple and faster
   /// in terms of the amount of code.&lt;/para&gt;
   /// &lt;para&gt;This number consists of 4 bytes, which are, in order from least significant
   /// to most significant: Blue, Greed, Red, Alpha.  To to retrieve the alpha component of
   /// this value, you would divide it by 16777216 or shift the bits rightward 24 places.
   /// &lt;/para&gt;&lt;/remarks&gt;
   public int color;

   /// &lt;summary&gt;
   /// Horizontal velocity relative to the sprite's environment (like a platform)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If the sprite is riding a platform, changes to the sprite's velocity
   /// should affect this instead of &lt;see cref="dx"/&gt;. When the sprite is not riding
   /// a platform, this value will be set to double.NaN.&lt;/remarks&gt;
   public double LocalDX;
   /// &lt;summary&gt;
   /// Vertical velocity relative to the sprite's environment
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If the sprite is riding an object within which it can move vertically
   /// (platforms only allow the sprite to move within the platform horizontally), changes
   /// to the sprite's velocity should affect this instead of &lt;see cref="dy"/&gt;.
   /// When the sprite is not riding such an object, this value will be set to double.NaN.&lt;/remarks&gt;
   public double LocalDY;

   /// &lt;summary&gt;
   /// Contains all the possible bits that can be set in a sprite's &lt;see cref="inputs"/&gt; and
   /// &lt;see cref="oldinputs"/&gt; properties.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Multiple bits may be set at once if multiple inputs are being pressed on this
   /// sprite at the same time.&lt;/remarks&gt;
   [FlagsAttribute()]
   public enum InputBits
   {
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move up or accelerate
      /// &lt;/summary&gt;
      Up = 1,
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move or turn right
      /// &lt;/summary&gt;
      Right = 2,
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move down or decelerate
      /// &lt;/summary&gt;
      Down = 4,
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move or turn left
      /// &lt;/summary&gt;
      Left = 8,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button1 = 16,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button2 = 32,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button3 = 64,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button4 = 128
   }

   /// &lt;summary&gt;
   /// Used to refer to 4 primary directions.
   /// &lt;/summary&gt;
   public enum Direction
   {
      Up,
      Right,
      Down,
      Left
   }

   /// &lt;summary&gt;
   /// Defines the basis for a sprite's animation
   /// &lt;/summary&gt;
   public enum SpriteAnimationType
   {
      /// &lt;summary&gt;
      /// Each frame that passes in the game will cause the sprite to advance its animation by one frame.
      /// &lt;/summary&gt;
      ByFrame,
      /// &lt;summary&gt;
      /// The sprite's animation will advance according to how many pixels it will move horizontally each frame.
      /// &lt;/summary&gt;
      ByHorizontalVelocity,
      /// &lt;summary&gt;
      /// The sprite's animation will advance according to how many pixels it will move vertically each frame.
      /// &lt;/summary&gt;
      ByVerticalVelocity,
      /// &lt;summary&gt;
      /// The sprite's animation will advance according to how many pixels it moves each frame in any direction (using the distance formula).
      /// &lt;/summary&gt;
      ByVectorVelocity
   }

   /// &lt;summary&gt;
   /// Constructs a new sprite instance given all its base properties.
   /// &lt;/summary&gt;
   /// &lt;param name="layer"&gt;Layer that contains the sprite.&lt;/param&gt;
   /// &lt;param name="x"&gt;Initial horizontal coordinate within the layer&lt;/param&gt;
   /// &lt;param name="y"&gt;Initial vertical coordinate within the layer&lt;/param&gt;
   /// &lt;param name="dx"&gt;Initial horizontal velocity&lt;/param&gt;
   /// &lt;param name="dy"&gt;Initial vertical velocity&lt;/param&gt;
   /// &lt;param name="state"&gt;Initial state&lt;/param&gt;
   /// &lt;param name="frame"&gt;Initial frame within the initial state&lt;/param&gt;
   /// &lt;param name="active"&gt;Determines if the sprite is initially active&lt;/param&gt;
   /// &lt;param name="solidity"&gt;Which solidity definition does the sprite initially react to&lt;/param&gt;
   /// &lt;param name="color"&gt;Initial color modulation settings&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;This cannot be called directly because SpriteBase is an abstract class,
   /// but it is called by the derived constructors on each individual sprite definition.&lt;/para&gt;
   /// &lt;para&gt;The sprite assumes that this is the layer to which it is added and will use it when
   /// looking for other objects or properties in the layer.&lt;/para&gt;&lt;/remarks&gt;
   public SpriteBase(LayerBase layer, double x, double y, double dx, double dy, int state, int frame, bool active, Solidity solidity, int color)
   {
      this.layer = layer;
      this.x = this.oldX = x;
      this.y = this.oldY = y;
      this.dx = dx;
      this.dy = dy;
      this.state = state;
      this.frame = frame;
      this.isActive = active;
      this.m_solidity = solidity;
      this.color = color;
      this.LocalDX = double.NaN;
      this.LocalDY = double.NaN;
   }

   #region Properties
   /// &lt;summary&gt;
   /// Horizontal position of the sprite within the layer rounded toward zero to yield an integer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This can only be changed by changing the sprite's &lt;see cref="dx"/&gt; property.&lt;/remarks&gt;
   public int PixelX
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access PixelX on an inactive sprite");
         // If you don't have the left edge of your map protected by a solid boundary,
         // and the different behavior of the left edge is bugging you, you can use this
         // return statement to work around the rounding difference of negative numbers,
         // but it involves just a bit of unnecessary overhead, and looks rather clumsy:
         // return (int)(x+16)-16;
         return (int)x;
      }
   }

   /// &lt;summary&gt;
   /// Vertical position of the sprite within the layer rounded toward zero to yield an integer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This can only be changed by changing the sprite's &lt;see cref="dy"/&gt; property.&lt;/remarks&gt;
   public int PixelY
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access PixelY on an inactive sprite");
         return (int)y;
      }
   }

   /// &lt;summary&gt;
   /// The horizontal coordinate that the sprite is expected to be at on the next frame based on its
   /// current position and velocity, rounded toward zero to yield an integer pixel coordinate.
   /// &lt;seealso cref="x"/&gt;&lt;seealso cref="dx"/&gt;
   /// &lt;/summary&gt;
   public int ProposedPixelX
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access ProposedPixelX on an inactive sprite");
         // If you don't have the left edge of your map protected by a solid boundary,
         // and the different behavior of the left edge is bugging you, you can use this
         // return statement to work around the rounding difference of negative numbers,
         // but it involves just a bit of unnecessary overhead, and looks rather clumsy:
         // return (int)(x+dx+16)-16
         return (int)(x + dx);
      }
   }

   /// &lt;summary&gt;
   /// The vertical coordinate that the sprite is expected to be at on the next frame based on its
   /// current position and velocity, rounded toward zero to yield an integer pixel coordinate.
   /// &lt;seealso cref="y"/&gt;&lt;seealso cref="dy"/&gt;
   /// &lt;/summary&gt;
   public int ProposedPixelY
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access ProposedPixelY on an inactive sprite");
         return (int)(y + dy);
      }
   }

   /// &lt;summary&gt;
   /// The horizontal pixel coordinate that the sprite was at on the previous frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A pixel coordinate is the actual coordinate (&lt;see cref="oldX"/&gt; in this case)
   /// rounded toward zero to yield an integer.&lt;/remarks&gt;
   public int OldPixelX
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access OldPixelX on an inactive sprite");
         return (int)oldX;
      }
   }

   /// &lt;summary&gt;
   /// The vertical pixel coordinate that the sprite was at on the previous frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A pixel coordinate is the actual coordinate (&lt;see cref="oldY"/&gt; in this case)
   /// rounded toward zero to yield an integer.&lt;/remarks&gt;
   public int OldPixelY
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access OldPixelY on an inactive sprite");
         return (int)oldY;
      }
   }

   /// &lt;summary&gt;
   /// Retrieves information about the state that the sprite is currently in.
   /// &lt;/summary&gt;
   public SpriteState CurrentState
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access CurrentState on an inactive sprite");
         return this[state];
      }
   }

   /// &lt;summary&gt;
   /// Retrieves information about the layer in which the sprite resides.
   /// &lt;/summary&gt;
   public override LayerBase ParentLayer
   {
      get
      {
         return layer;
      }
   }
   #endregion

   #region Abstract members
   /// &lt;summary&gt;
   /// How many pixels wide is the solid area of this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The solid area of the sprite is the area that avoids overlapping
   /// solid areas of the map. The width is measured from the origin and
   /// extends rightward. &lt;seealso cref="SolidHeight"/&gt;&lt;/remarks&gt;
   public abstract int SolidWidth
   {
      [Description("Returns the width of the sprite's solid area")]
      get;
   }

   /// &lt;summary&gt;
   /// How many pixels high is the solid area of this sprite. 
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The solid area of the sprite is the area that avoids overlapping
   /// solid areas of the map. The height is measured from the origin and
   /// extends downward. &lt;seealso cref="SolidWidth"/&gt;&lt;/remarks&gt;
   public abstract int SolidHeight
   {
      [Description("Returns the height of the sprite's solid area")]
      get;
   }

   /// &lt;summary&gt;
   /// Returns information about a specified state of this sprite
   /// &lt;/summary&gt;
   /// &lt;example&gt;The following code shows how you might retrieve the height
   /// of a sprite's crouching state assuming it has one:
   /// &lt;code&gt;crouchHeight = this[State.Crouch].LocalBounds.Height;&lt;/code&gt;&lt;/example&gt;
   public abstract SpriteState this[int state]
   {
      get;
   }

   /// &lt;summary&gt;
   /// Executes all the rules associated with this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;see cref="ProcessRules"/&gt; is the recommended alternative to execute the sprite's
   /// rules only once per frame by only calling ExecuteRules when the sprites rules haven't
   /// already been executed this frame. &lt;seealso cref="Processed"/&gt;&lt;/remarks&gt;
   protected abstract void ExecuteRules();

   /// &lt;summary&gt;
   /// Resets all parameter values defined on the specific sprite definition to 0.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is helpful in resetting a sprite's state without knowing specifically
   /// what its parameters are.  Then the sprite can internally re-initialize itself when
   /// it sees that it's parameters have been reset to 0.&lt;/remarks&gt;
   public abstract void ClearParameters();

   /// &lt;summary&gt;
   /// Remove the sprite from its designated categories.
   /// USE ONLY on dynamically added sprites.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is used by functions involved with the creation and deactivation of
   /// dynamically created sprites to ensure that a deactivated sprite no longer exists
   /// in any categories/collections. It's called by &lt;see cref="SpriteCollection.Clean"/&gt;,
   /// which is called by &lt;see cref="LayerBase.ProcessSprites"/&gt;.&lt;/remarks&gt;
   public abstract void RemoveFromCategories();

   #endregion

   #region Public Methods
   /// &lt;summary&gt;
   /// Returns information about the visual boundaries of the sprite's currently displayed frame(s).
   /// &lt;/summary&gt;
   /// &lt;returns&gt;Rectangle object containing layer-relative coordinates that encompass the
   /// sprite's current image.&lt;/returns&gt;
   public virtual System.Drawing.Rectangle GetBounds()
   {
      Debug.Assert(this.isActive, "Attempted to execute GetBounds on an inactive sprite");
      System.Drawing.Rectangle result = CurrentState.LocalBounds;
      result.Offset(PixelX, PixelY);
      return result;
   }

   /// &lt;summary&gt;
   /// Get a list of frameset frames that the sprite is currently displaying
   /// &lt;/summary&gt;
   /// &lt;returns&gt;
   /// Array of Frame objects representing the currently displayed frames.
   /// &lt;/returns&gt;
   /// &lt;remarks&gt;The array will only have more than one element if the sprite
   /// is currently displaying a composite frame.  The frames are ordered from
   /// background to foreground.&lt;/remarks&gt;
   public virtual Frame[] GetCurrentFramesetFrames()
   {
      Debug.Assert(this.isActive, "Attempted to execute GetCurrentFramesetFrames on an inactive sprite");
      SpriteState curstate = CurrentState;
      Frameset stateframes = curstate.Frameset;
      int[] subframes = curstate.GetFrame(frame);
      Frame[] result = new Frame[subframes.Length];
      for (int idx = 0; idx &lt; result.Length; idx++)
         result[idx] = stateframes[subframes[idx]];
      return result;
   }

   /// &lt;summary&gt;
   /// Execute the rules for this sprite if they have not already been executed this frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This checks &lt;see cref="Processed"/&gt; and calls &lt;see cref="ExecuteRules"/&gt;
   /// if it's not set, setting &lt;see cref="Processed"/&gt; to true first.  This function
   /// can be overridden in a partial class of the derived sprite to call ExecuteRules
   /// based on other conditions.&lt;/remarks&gt;
   public virtual void ProcessRules()
   {
      if ((!Processed) &amp;&amp; (this.isActive))
      {
         // Help prevent infinite recursion
         Processed = true;
         ExecuteRules();
      }
   }

   #endregion

   #region Sprite Interaction
   #region Rider Feature
   /// &lt;summary&gt;
   /// Stores the platform sprite (the sprite that this sprite rides on).
   /// If not set, then the sprite is not riding anything.
   /// &lt;/summary&gt;
   public SpriteBase RidingOn;
   /// &lt;summary&gt;
   /// Determines if this sprite's definition's rules have been processed yet this frame
   /// &lt;/summary&gt;
   [NonSerialized()]
   public bool Processed;

   /// &lt;summary&gt;
   /// Adjust this sprite's velocity according to the motion of the platform it is riding
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Apply this rule before &lt;see cref="ReactToSolid"/&gt; in order to prevent
   /// the platform from allowing the sprite to move through solids.&lt;/remarks&gt;
   [Description("Moves this sprite according to the motion of the platform it is riding.")]
   public virtual void ReactToPlatform()
   {
      Debug.Assert(this.isActive, "Attempted to execute ReactToPlatform on an inactive sprite");
      if (RidingOn == null)
         return;

      // Don't try to process the platform's rules if it's already moved.
      // Even though this is already being checked in ProcessRules, circular
      // references (which shouldn't exist) would lead to deadlock.
      if (!RidingOn.Processed)
         // Ensure that the sprite that this sprite is riding moves first
         RidingOn.ProcessRules();

      if ((RidingOn.isActive == false) || (x + SolidWidth &lt; RidingOn.oldX) || (x &gt; RidingOn.oldX + RidingOn.SolidWidth) ||
         (y + SolidHeight &lt; RidingOn.oldY - 1) || (y + SolidHeight &gt;= RidingOn.oldY + RidingOn.SolidHeight))
      {
         StopRiding();
         return;
      }

      if (double.IsNaN(LocalDX))
         Debug.Fail("LocalDX is not a number");
      else
         dx = LocalDX + RidingOn.dx;
      dy = RidingOn.y - SolidHeight - y;
   }

   /// &lt;summary&gt;
   /// Determine if the sprite is riding another sprite
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if this sprite is currently riding on another sprite&lt;/returns&gt;
   [Description("Determine if the sprite is riding another sprite")]
   public bool IsRidingPlatform()
   {
      Debug.Assert(this.isActive, "Attempted to execute IsRidingPlatform on an inactive sprite");
      return RidingOn != null;
   }

   /// &lt;summary&gt;
   /// Stop riding the sprite that this sprite is currently riding, if any.
   /// &lt;/summary&gt;
   [Description("Stop riding the sprite that this sprite is currently riding, if any.")]
   public virtual void StopRiding()
   {
      Debug.Assert(this.isActive, "Attempted to execute StopRiding on an inactive sprite");
      LocalDX = double.NaN;
      RidingOn = null;
   }

   /// &lt;summary&gt;
   /// Tests to see if this sprite is landing on a platform (from above), and if so,
   /// make the sprite ride the platform.
   /// &lt;/summary&gt;
   /// &lt;param name="PlatformList"&gt;List of platform sprites to check&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite landed on a platform, False if it is already riding a platform or doesn't need to&lt;/returns&gt;
   /// &lt;remarks&gt;
   /// This should be called after sprites are moved, but before
   /// they are drawn.&lt;/remarks&gt;
   [Description("Tests to see if this sprite is landing on a platform (from above). If it is, the sprite will begin riding the platform.")]
   public virtual bool LandDownOnPlatform(SpriteCollection PlatformList)
   {
      Debug.Assert(this.isActive, "Attempted to execute LandDownOnPlatform on an inactive sprite");
      if (RidingOn != null)
         return false;
      foreach (SpriteBase spr in PlatformList)
      {
         if (!spr.isActive)
            continue;
         if ((oldY + SolidHeight &lt;= spr.oldY) &amp;&amp;
            (y + SolidHeight &gt; spr.y) &amp;&amp;
            (x + SolidWidth &gt; spr.x) &amp;&amp;
            (x &lt; spr.x + spr.SolidWidth))
         {
            RidingOn = spr;
            spr.ProcessRules();
            LocalDX = dx - spr.dx;
            dy = spr.y - SolidHeight - y;
            return true;
         }
      }
      return false;
   }
   #endregion

   /// &lt;summary&gt;
   /// Determine whether the sprite's collision mask is overlapping part of any sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Targets"&gt;A sprite category containing sprites that will be checked for collision
   /// with this sprite.&lt;/param&gt;
   /// &lt;returns&gt;The index of the sprite within the category if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;The collision mask is derived from the sprite's Mask Alpha Level setting.
   /// If both sprites have a collision mask, they are checked for overlapping solid bits.
   /// If one sprite has Mask Alpha Level set to 0, then a rectangular mask for that sprite
   /// is synthesized from the solid width and solid height using
   /// &lt;see cref="CollisionMask.GetRectangularMask"/&gt;.
   /// If both sprites have Mask Alpha Level set to 0, then a simple rectangular collision
   /// detection is performed (for improved performance).&lt;/remarks&gt;
   [Description("Determine whether the sprite's collision mask is overlapping part of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public virtual int TestCollisionMask(SpriteCollection Targets)
   {
      if (!isActive)
         return -1;
      CollisionMask sourceMask = CurrentState.GetMask(frame);
      bool bSourceIsRectangle = false;
      System.Drawing.Rectangle sourceRect = new System.Drawing.Rectangle(PixelX, PixelY, SolidWidth, SolidHeight);
      if (sourceMask == null)
      {
         sourceMask = CollisionMask.GetRectangularMask(new System.Drawing.Size(SolidWidth, SolidHeight));
         bSourceIsRectangle = true;
      }
      for (int idx = 0; idx &lt; Targets.Count; idx++)
      {
         SpriteBase TargetSprite = Targets[idx];
         if (TargetSprite == this)
            continue;
         if (TargetSprite.isActive)
         {
            CollisionMask targetMask = TargetSprite.CurrentState.GetMask(TargetSprite.frame);
            if (targetMask == null)
            {
               if (bSourceIsRectangle)
               {
                  if (sourceRect.IntersectsWith(new System.Drawing.Rectangle(
                     TargetSprite.PixelX, TargetSprite.PixelY, TargetSprite.SolidWidth, TargetSprite.SolidHeight)))
                     return idx;
                  continue;
               }
               else
                  targetMask = CollisionMask.GetRectangularMask(new System.Drawing.Size(TargetSprite.SolidWidth, TargetSprite.SolidHeight));
            }
            if (sourceMask.TestCollisionWith(targetMask, TargetSprite.PixelX - PixelX, TargetSprite.PixelY - PixelY))
               return idx;
         }
      }
      return -1;
   }

   /// &lt;summary&gt;
   /// Determine whether the solidity rectangle of the sprite overlaps that of any sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Targets"&gt;A sprite category containing sprites that will be checked for collision
   /// with this sprite.&lt;/param&gt;
   /// &lt;returns&gt;The index of the sprite within the category if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;This can be used to force a simple rectangular collision test even if one or both
   /// sprites involved have a Mask Alpha level greater than 0.  This method is recommended
   /// for improved performance when pixel-perfect collision detection is not required.
   /// &lt;seealso cref="TestCollisionMask"/&gt;&lt;/remarks&gt;
   [Description("Determine whether the solidity rectangle of the sprite overlaps that of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public virtual int TestCollisionRect(SpriteCollection Targets)
   {
      if (!isActive)
         return -1;
      for (int idx = 0; idx &lt; Targets.Count; idx++)
      {
         SpriteBase TargetSprite = Targets[idx];
         if ((TargetSprite == this) || (!TargetSprite.isActive))
            continue;
         int x1 = PixelX;
         int w1 = SolidWidth;
         int x2 = TargetSprite.PixelX;
         int w2 = TargetSprite.SolidWidth;
         int y1 = PixelY;
         int h1 = SolidHeight;
         int y2 = TargetSprite.PixelY;
         int h2 = TargetSprite.SolidHeight;

         if ((x1 + w1 &gt; x2) &amp;&amp; (x2 + w2 &gt; x1) &amp;&amp; (y1 + h1 &gt; y2) &amp;&amp; (y2 + h2 &gt; y1))
            return idx;
      }
      return -1;
   }
   #endregion

   #region Movement
   /// &lt;summary&gt;
   /// Increment or decrement horizontal velocity 
   /// &lt;/summary&gt;
   /// &lt;param name="delta"&gt;Amount by which to change velocity in pixels per frame per frame&lt;/param&gt;
   [Description("Increment or decrement horizontal velocity")]
   public virtual void AlterXVelocity(double delta)
   {
      Debug.Assert(this.isActive, "Attempted to execute AlterXVelocity on an inactive sprite");
      dx += delta;
   }

   /// &lt;summary&gt;
   /// Increment or decrement vertical velocity 
   /// &lt;/summary&gt;
   /// &lt;param name="delta"&gt;Amount by which to change velocity in pixels per frame per frame&lt;/param&gt;
   [Description("Increment or decrement vertical velocity")]
   public virtual void AlterYVelocity(double delta)
   {
      Debug.Assert(this.isActive, "Attempted to execute AlterYVelocity on an inactive sprite");
      dy += delta;
   }

   /// &lt;summary&gt;
   /// Move this sprite according to its current velocity
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The &lt;see cref="oldX"/&gt; and &lt;see cref="oldY"/&gt; properties are
   /// set from the current position and a new position is calculated into
   /// &lt;see cref="x"/&gt; and &lt;see cref="y"/&gt; by adding &lt;see cref="dx"/&gt; and
   /// &lt;see cref="dy"/&gt; to them respectively.&lt;/remarks&gt;
   [Description("Move this sprite according to its current velocity")]
   public virtual void MoveByVelocity()
   {
      Debug.Assert(this.isActive, "Attempted to execute MoveByVelocity on an inactive sprite");
      oldX = x;
      oldY = y;
      x += dx;
      y += dy;
   }

   /// &lt;summary&gt;
   /// If the velocity of the sprite is more than the specified maximum, normalize it so that
   /// it's going the same direction, but at no more that the specified maximum speed.
   /// &lt;/summary&gt;
   /// &lt;param name="Maximum"&gt;Specifies the maximum speed in pixels per frame&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;The speed of the sprite is calculated with the distance formula, so a sprite
   /// moving 3 pixels horizontally and 4 pixels vertically, for example, is considered to be
   /// moving 5 pixels.&lt;/para&gt;
   /// &lt;para&gt;If the sprite is riding a platform, the maximum velocity is applied relative to
   /// the platform. For example, if the platform is moving rightward at 3 pixels per frame,
   /// and the sprite is moving rightward at 5 pixels per frame relative to the platform (8
   /// pixels per frame in absolute terms), and the maximum is set to 4 pixels per frame,
   /// the sprite's &lt;see cref="LocalDX"/&gt; will be reduced to 4 rather than to 1&lt;/para&gt;.&lt;/remarks&gt;
   [Description("Limit the velocity of the sprite to the specified maximum pixels per frame (affects only local velocity when applicable)")]
   public virtual void LimitVelocity(int Maximum)
   {
      Debug.Assert(this.isActive, "Attempted to execute LimitVelocity on an inactive sprite");
      double useDX, useDY;
      if (double.IsNaN(LocalDX))
         useDX = dx;
      else
         useDX = LocalDX;
      if (double.IsNaN(LocalDY))
         useDY = dy;
      else
         useDY = LocalDY;
      double dist = useDX * useDX + useDY * useDY;
      if (dist &gt; Maximum * Maximum)
      {
         dist = Math.Sqrt(dist);
         useDX = useDX * Maximum / dist;
         useDY = useDY * Maximum / dist;
         if (double.IsNaN(LocalDX))
            dx = useDX;
         else
            LocalDX = useDX;
         if (double.IsNaN(LocalDY))
            dy = useDY;
         else
            LocalDY = useDY;
      }
   }

   /// &lt;summary&gt;
   /// Reduces the sprite's velocity to simulate friction.
   /// &lt;/summary&gt;
   /// &lt;param name="RetainPercentVertical"&gt;What percent (0 to 100) of the sprite's horizontal velocity
   /// (&lt;see cref="dx"/&gt;) is retained.&lt;/param&gt;
   /// &lt;param name="RetainPercentHorizontal"&gt;What percent (0 to 100) of the sprite's vertical
   /// velocity (&lt;see cref="dy"/&gt;) is retained.&lt;/param&gt;
   /// &lt;remarks&gt;Note that inertia may have unexpected side-effects on gravity.  For example,
   /// if RetainPercentVertical is set to zero, this will cause the sprite to start from a
   /// vertical velocity of 0 on every frame, which will result in gravity being unable to
   /// accumulate any effect.  It's best to set RetainPercentVertical to a high number or 100
   /// when gravity is in effect. A gravity effect is simply an automatic adjustment to the
   /// Y velocity with &lt;see cref="AlterYVelocity"/&gt;.&lt;/remarks&gt;
   [Description("Reduces the sprite's velocity to simulate friction.  RetainPercent is a number 0 to 100 indicating how much inertia is retained.")]
   public virtual void ReactToInertia(int RetainPercentVertical, int RetainPercentHorizontal)
   {
      Debug.Assert(this.isActive, "Attempted to execute ReactToInertia on an inactive sprite");
      if (double.IsNaN(LocalDX))
      {
         if (Math.Abs(dx) &lt; .01)
            dx = 0;
         else
            dx *= RetainPercentHorizontal / 100.0f;
      }
      else
      {
         if (Math.Abs(LocalDX) &lt; .01)
            LocalDX = 0;
         else
            LocalDX *= RetainPercentHorizontal / 100.0f;
      }
      if (double.IsNaN(LocalDY))
      {
         if (Math.Abs(dy) &lt; .01)
            dy = 0;
         else
            dy *= RetainPercentVertical / 100.0f;
      }
      else
      {
         if (Math.Abs(LocalDY) &lt; .01)
            LocalDY = 0;
         else
            LocalDY *= RetainPercentVertical / 100.0f;
      }
   }

   /// &lt;summary&gt;
   /// Determines if the sprite is moving in the specified direction at all.
   /// &lt;/summary&gt;
   /// &lt;param name="Direction"&gt;Determines which direction to check&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite has any movement in the specified direction, otherwise false.&lt;/returns&gt;
   [Description("Returns true if the sprite is moving in the specified direction")]
   public virtual bool IsMoving(Direction Direction)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsMoving on an inactive sprite");
      double useDX, useDY;
      if (double.IsNaN(LocalDX))
         useDX = dx;
      else
         useDX = LocalDX;
      if (double.IsNaN(LocalDY))
         useDY = dy;
      else
         useDY = LocalDY;

      switch (Direction)
      {
         case Direction.Left:
            return useDX &lt; 0;
         case Direction.Right:
            return useDX &gt; 0;
         case Direction.Up:
            return useDY &lt; 0;
         case Direction.Down:
            return useDY &gt; 0;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Accelerate a rotating sprite in the direction that it is aiming.
   /// &lt;/summary&gt;
   /// &lt;param name="Acceleration"&gt;Specifies acceleration amount in tenths of a pixel per frame per frame.&lt;/param&gt;
   /// &lt;param name="FirstState"&gt;Provide the first state of this sprite's group of states (representing the sprite pointing rightward).&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Provide the number of states this sprite takes to represent one full rotation.&lt;/param&gt;
   /// &lt;remarks&gt;The current angle of this sprite is calculated by assuming that the provided first state
   /// points rightward, and that each subsequent state rotates the sprite counter-clockwise in equal
   /// increments until StateCount states have resulted in one full rotation. The sprite's current state
   /// is somewhere in that progression, and determines the current angle. The actual formula is
   /// (state - FirstState) * pi * 2 / StateCount, which calculates the angle in radians.
   /// &lt;seealso cref="RotateVelocity"/&gt;&lt;/remarks&gt;
   [Description("Accelerate the sprite in a direction determined by its state, assuming the first state points rightward and the number of states rotate counterclockwise 360 degrees. Acceleration is in tenths of a pixel per frame per frame.")]
   public virtual void PolarAccelerate(int Acceleration, [Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount)
   {
      Debug.Assert(this.isActive, "Attempted to execute PolarAccelerate on an inactive sprite");
      double angle = (state - FirstState) * Math.PI * 2 / (double)StateCount;
      double ddx = Math.Cos(angle) * Acceleration / 10.0d;
      double ddy = -Math.Sin(angle) * Acceleration / 10.0d;
      if (double.IsNaN(LocalDY))
         dy += ddy;
      else
         LocalDY += ddy;

      if (double.IsNaN(LocalDX))
         dx += ddx;
      else
         LocalDX += ddx;
   }

   /// &lt;summary&gt;
   /// Redirect this sprite's velocity to be 100% in the direction that it is facing.
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Provide the first state of this sprite's group of states (representing the sprite pointing rightward).&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Provide the number of states this sprite takes to represent one full rotation.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;paramref name="FirstState" /&gt; must represent the sprite in a rightward-aiming state, and each subsequent
   /// state must represent an equal counter-clockwise rotation until &lt;paramref name="StateCount" /&gt; states result in
   /// the sprite pointing almost rightward again. The sprite's current state must be one of the
   /// states in that range. This function is useful for car-type sprites where turning the sprite should automatically
   /// cause the sprite to be moving in that direction only (no drifting in the previous direction
   /// like a space ship would). &lt;seealso cref="PolarAccelerate"/&gt;&lt;/remarks&gt;
   [Description("Redirect this sprite's velocity to be 100% in the direction that it is facing, based on its state, where FirstState points rightward and the number of states rotate counterclockwise.")]
   public virtual void RotateVelocity([Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount)
   {
      Debug.Assert(this.isActive, "Attepmted to execute RotateVelocity on an inactive sprite");
      float oldDx, oldDy;
      if (double.IsNaN(LocalDX))
         oldDx = (float)dx;
      else
         oldDx = (float)LocalDX;
      if (double.IsNaN(LocalDY))
         oldDy = (float)dy;
      else
         oldDy = (float)LocalDY;

      float angle = (float)((state - FirstState) * Math.PI * 2 / (float)StateCount);

      float facingX, facingY;
      facingX = (float)Math.Cos(angle);
      facingY = -(float)Math.Sin(angle);
      float dotProduct = oldDx * facingX + oldDy * facingY;
      facingX *= dotProduct;
      facingY *= dotProduct;

      if (double.IsNaN(LocalDX))
         dx = facingX;
      else
         LocalDX = facingX;

      if (double.IsNaN(LocalDY))
         dy = facingY;
      else
         LocalDY = facingY;
   }

   /// &lt;summary&gt;
   /// Scroll all layers on this sprite's layer's map so that the sprite is within visible area of the map.
   /// &lt;/summary&gt;
   /// &lt;param name="UseScrollMargins"&gt;If true, scroll the sprite into the scroll margins of the map. Otherwise just scroll the layers var enough so the sprite is within the edges of the display.&lt;/param&gt;
   /// &lt;remarks&gt;For a multi-player game where both players are in the same view, you may want to
   /// set UseScrollMargins to false in order to allow the players to get closer to the edge of the
   /// display when moving apart from one another. This function will not affect layers with a scroll
   /// rate of zero. &lt;seealso cref="PushSpriteIntoView"/&gt;
   /// &lt;/remarks&gt;
   [Description("Scroll all layers on this sprite's layer's map so that the sprite is within visible area of the map.  If UseScrollMargins is true, scroll the sprite into the scroll margins of the map.")]
   public virtual void ScrollSpriteIntoView(bool UseScrollMargins)
   {
      ParentLayer.ScrollSpriteIntoView(this, UseScrollMargins);
   }

   /// &lt;summary&gt;
   /// Alter this sprite's velocity so that it remains within the map's visible area or
   /// within the scroll margins, according to this sprite's layer's position within the map.
   /// &lt;/summary&gt;
   /// &lt;param name="StayInScrollMargins"&gt;If true, the sprite will be pushed toward the center as
   /// soon as it comes within a minimum distance of the edge of the display, determined by the
   /// map's scroll margins (&lt;see cref="MapBase.ScrollMarginLeft"/&gt;, &lt;see cref="MapBase.ScrollMarginTop"/&gt;,
   /// &lt;see cref="MapBase.ScrollMarginRight"/&gt;, &lt;see cref="MapBase.ScrollMarginBottom"/&gt;). Otherwise
   /// the sprite will only be pushed when it reaches the edge of the display.&lt;/param&gt;
   /// &lt;remarks&gt;This takes into account the sprites &lt;see cref="LocalDX"/&gt; and &lt;see cref="LocalDY"/&gt;
   /// properties in case it is riding another sprite. If the sprite has somehow gone far off the
   /// edge of the map, it's velocity may be set to unreasonable values because it will attempt
   /// to enter the display in a single frame. This function will only set the velocity, not
   /// actually move the sprite (&lt;see cref="MoveByVelocity"/&gt; is used to move sprites). This
   /// allows you to make the sprite react to many forces before moving it. In a multi-player
   /// game with two players in the same view this is useful for ensuring that both players
   /// remain on screen.
   /// &lt;seealso cref="ScrollSpriteIntoView"/&gt;&lt;/remarks&gt;
   [Description("Alter this sprite's velocity so that it remains within the map's visible area or within the scroll margins, according to this sprite's layer's position within the map.")]
   public virtual void PushSpriteIntoView(bool StayInScrollMargins)
   {
      ParentLayer.PushSpriteIntoView(this, StayInScrollMargins);
   }

   /// &lt;summary&gt;
   /// Compute the index of the nearest active sprite from the specified category and return it.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Sprite category whose sprites will be searched for sprites near this sprite.&lt;/param&gt;
   /// &lt;returns&gt;An integer representing the 0-based index of the nearest active sprite, or -1 if
   /// there are no active sprites in the specified category.&lt;/returns&gt;
   /// &lt;remarks&gt;The output of this function would commonly be stored in a sprite parameter for
   /// passing to &lt;see cref="PushTowardCategory "/&gt;.&lt;/remarks&gt;
   [Description("Compute the index of the nearest active sprite from the specified category and return it.")]
   public virtual int GetNearestSpriteIndex(SpriteCollection Target)
   {
      int minDist = int.MaxValue;
      int result = -1;
      for (int i = 0; i &lt; Target.Count; i++)
      {
         if ((!Target[i].isActive) || (Target[i] == this))
            continue;
         int xOff = Target[i].PixelX - PixelX;
         int yOff = Target[i].PixelY - PixelY;
         int dist = xOff * xOff + yOff * yOff;
         if (dist &lt; minDist)
         {
            minDist = dist;
            result = i;
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Push this sprite toward a sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies a category containint the target
   /// sprite toward which this sprite will be pushed.&lt;/param&gt;
   /// &lt;param name="Index"&gt;Specifies the 0-based index of a sprite in the specified category.
   /// Use &lt;see cref="GetNearestSpriteIndex"/&gt; to compute the index of the nearest sprite, which
   /// can then be passed to this parameter.  Pass -1 in this parameter to push the sprite toward
   /// the current nearest sprite rather than a pre-computed index.&lt;/param&gt;
   /// &lt;param name="Force"&gt;Force in tenths of a pixel per frame per frame that will be applied.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was pushed, or false if there are no active sprites in the
   /// target category or the sprite is already overlapping the target.&lt;/returns&gt;
   /// &lt;remarks&gt;If there is no active sprite in the target category, or if the sprite is overlapping
   /// the target exactly, this function will have no effect.
   /// &lt;seealso cref="SetInputsTowardCategory"/&gt;
   /// &lt;seealso cref="PushTowardSprite"/&gt;
   /// &lt;seealso cref="SetInputsTowardSprite"/&gt;&lt;/remarks&gt;
   [Description("Push this sprite toward a sprite in the specified category. Use GetNearestSpriteIndex to compute the index of the nearest sprite and pass that to Index, or pass -1 to push toward the current nearest sprite. Force is in tenths of a pixel per frame per frame.")]
   public virtual bool PushTowardCategory(SpriteCollection Target, int Index, int Force)
   {
      Debug.Assert(this.isActive, "Attepmted to execute PushTowardCategory on an inactive sprite");
      Debug.Assert(Index &lt; Target.Count, "Attempted to PushTowardCategory on an index beyond the bounds of a collection");

      if (Index &lt; 0)
         Index = GetNearestSpriteIndex(Target);
      if (Index &lt; 0)
         return false;

      return PushTowardSprite(Target[Index], Force);
   }

   /// &lt;summary&gt;
   /// Push this sprite toward a specified sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Sprite toward which this sprite is pushed.&lt;/param&gt;
   /// &lt;param name="Force"&gt;Acceleration force in tenths of a pixel per frame per frame.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is pushed or false if the sprite is already overlapping
   /// the target.
   /// &lt;seealso cref="PushTowardCategory"/&gt;
   /// &lt;seealso cref="SetInputsTowardSprite"/&gt;
   /// &lt;seealso cref="SetInputsTowardCategory"/&gt;&lt;/returns&gt;
   public virtual bool PushTowardSprite(SpriteBase Target, int Force)
   {
      double vx = Target.PixelX - PixelX + (Target.SolidWidth - SolidWidth) / 2;
      double vy = Target.PixelY - PixelY + (Target.SolidHeight - SolidHeight) / 2;
      double dist = Math.Sqrt(vx * vx + vy * vy);
      if (dist &gt;= 1)
      {
         dx += vx * Force / dist / 10.0;
         dy += vy * Force / dist / 10.0;
         return true;
      }
      return false;
   }
   #endregion

   #region States and animation

   /// &lt;summary&gt;
   /// Advance the animation frame of this sprite according to its velocity or a constant rate.
   /// &lt;/summary&gt;
   /// &lt;param name="Correlation"&gt;Determines how and if the sprite's animation speed should be
   /// based on its movement.&lt;/param&gt;
   [Description("Advance the animation frame of this sprite according to its velocity or a constant rate")]
   public virtual void Animate(SpriteAnimationType Correlation)
   {
      Debug.Assert(this.isActive, "Attempted to execute Animate on an inactive sprite");
      switch (Correlation)
      {
         case SpriteAnimationType.ByFrame:
            frame++;
            break;
         case SpriteAnimationType.ByHorizontalVelocity:
            if (double.IsNaN(LocalDX))
               frame += System.Math.Abs(ProposedPixelX - PixelX);
            else
               frame += System.Math.Abs((int)LocalDX);
            break;
         case SpriteAnimationType.ByVerticalVelocity:
            if (double.IsNaN(LocalDY))
               frame += System.Math.Abs(ProposedPixelY - PixelY);
            else
               frame += System.Math.Abs((int)LocalDY);
            break;
         case SpriteAnimationType.ByVectorVelocity:
            {
               int tmpDx = ProposedPixelX - PixelX;
               int tmpDy = ProposedPixelY - PixelY;
               frame += (int)(System.Math.Sqrt(tmpDx * tmpDx + tmpDy * tmpDy));
            }
            break;
      }
   }

   /// &lt;summary&gt;
   /// Calculate the state that a rotating sprite should use in order to point in the direction it is currently traveling
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Provide the first state of this sprite's group of states (representing the sprite pointing rightward).&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Provide the number of states this sprite takes to represent one full rotation.&lt;/param&gt;
   /// &lt;returns&gt;&lt;paramref name="FirstState" /&gt; must represent the sprite in a rightward-aiming state, and each subsequent
   /// state must represent an equal counter-clockwise rotation until &lt;paramref name="StateCount" /&gt; states result in
   /// the sprite pointing almost rightward again. The returned state number will be in that range.
   /// The result of this can be stored directly into &lt;see cref="state"/&gt; if you want the sprite
   /// to switch to that state.&lt;/returns&gt;
   [Description("Return the state that a rotating sprite should use in order to point in the direction it is currently traveling, assuming that FirstState points rightward and each subsequent state is one step counter-clockwise")]
   public virtual int GetPolarStateByVector([Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount)
   {
      double useDX, useDY;
      Debug.Assert(this.isActive, "Attempted to execute GetPolarStateByVector on an inactive sprite");
      if (double.IsNaN(LocalDX))
         useDX = dx;
      else
         useDX = LocalDX;
      if (double.IsNaN(LocalDY))
         useDY = dy;
      else
         useDY = LocalDY;
      return FirstState + ((StateCount + (int)Math.Round(System.Math.Atan2(-useDY, useDX) * StateCount / Math.PI / 2f)) % StateCount);
   }

   /// &lt;summary&gt;
   /// Return a state that is in the same group of states as the sprite's current state,
   /// but possibly pointing a different direction.
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Represents the beginning of this sprite's rotating states.
   /// This will usually be the sprite's first state, but can be something else if the sprite
   /// has other states before the first rotating state.&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Number of states in each rotation&lt;/param&gt;
   /// &lt;param name="NewState"&gt;Specifies the new state. The state group which this value specifies
   /// is ignored; only the offset into the group is used.&lt;/param&gt;
   /// &lt;returns&gt;New state value  that represents the state in the same group as the sprite's
   /// current state, but rotated according to NewState.&lt;/returns&gt;
   /// &lt;remarks&gt;This is commonly used in calculating a new state when left or right is
   /// pressed on a rotating sprite, to ensure that pressing left and right don't
   /// cause the sprite to change to a different group of states.&lt;/remarks&gt;
   [Description("Return a state that is in the same group of states as the sprite's current state, but possibly pointing a different direction.")]
   public virtual int CalculateRotatedState([Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount, int NewState)
   {
      Debug.Assert(this.isActive, "Attempted to execute CalculateRotatedState on an inactive sprite");
      return (NewState + StateCount - FirstState) % StateCount + FirstState + (int)((state - FirstState) / StateCount) * StateCount;
   }

   /// &lt;summary&gt;
   /// Switch the sprite to the the specified state, ensuring that the sprite doesn't hit a solid.
   /// &lt;/summary&gt;
   /// &lt;param name="State"&gt;State to which the sprite will be switched&lt;/param&gt;
   /// &lt;param name="Alignment"&gt;Specifies a point within the sprite which will remain constant.  For example, RelativePosition.BottomCenter will ensure that the bottom center point of the new state aligns with the bottom center point of this state.&lt;/param&gt;
   /// &lt;returns&gt;True if the state could be switched, false if the new state's differing size would
   /// have caused the sprite the sprite to pass through a solid tile.&lt;/returns&gt;
   /// &lt;remarks&gt;This function is handy for performing action like switching from a crouching
   /// state to a standing state because it will prevent you from standing up if there is a low
   /// ceiling in the way. It also helps you align the two states properly. For example, if you
   /// switched from the crouching state to the standing state without moving the sprite at
   /// all, the origin (usually the top left corner of the sprite) would remain in the same place,
   /// which would cause the head to remain in the same place and the feet to stick through the
   /// floor. But by using the Alignment paremeter, you can make sure that the botton of the
   /// new state aligns with the bottom of the current state.&lt;/remarks&gt;
   [Description("Switch the sprite to the the specified state, ensuring that the specified alignment point in the new state lines up with the same point in the current state.  Returns false if the state could not switch due to solidity.")]
   public virtual bool SwitchToState([Editor("SpriteState", "UITypeEditor")] int State, RelativePosition Alignment)
   {
      Debug.Assert(this.isActive, "Attempted to execute SwitchToState on an inactive sprite");
      System.Drawing.Rectangle oldRect = new System.Drawing.Rectangle(PixelX, PixelY, SolidWidth, SolidHeight);
      int newWidth = this[State].SolidWidth;
      int newHeight = this[State].SolidHeight;
      double newX, newY;
      switch (Alignment)
      {
         case RelativePosition.TopCenter:
         case RelativePosition.CenterMiddle:
         case RelativePosition.BottomCenter:
            newX = x + (oldRect.Width - newWidth) / 2f;
            break;
         case RelativePosition.TopRight:
         case RelativePosition.RightMiddle:
         case RelativePosition.BottomRight:
            newX = x + oldRect.Width - newWidth;
            break;
         default:
            newX = x;
            break;
      }
      switch (Alignment)
      {
         case RelativePosition.LeftMiddle:
         case RelativePosition.CenterMiddle:
         case RelativePosition.RightMiddle:
            newY = y + (oldRect.Height - newHeight) / 2f;
            break;
         case RelativePosition.BottomLeft:
         case RelativePosition.BottomCenter:
         case RelativePosition.BottomRight:
            newY = y + oldRect.Height - newHeight;
            break;
         default:
            newY = y;
            break;
      }

      if (((int)Math.Ceiling(newY + newHeight) &gt; oldRect.Bottom) &amp;&amp; (layer.GetTopSolidPixel(new System.Drawing.Rectangle(
         (int)newX, oldRect.Bottom, newWidth, (int)Math.Ceiling(newY) + newHeight - oldRect.Bottom), m_solidity) != int.MinValue))
         return false;

      if (((int)newY &lt; oldRect.Top) &amp;&amp; (layer.GetBottomSolidPixel(new System.Drawing.Rectangle(
         (int)newX, (int)newY, newWidth, oldRect.Top - (int)newY), m_solidity) != int.MinValue))
         return false;

      if (((int)newX &lt; oldRect.Left) &amp;&amp; (layer.GetRightSolidPixel(new System.Drawing.Rectangle(
         (int)newX, (int)newY, oldRect.Left - (int)newX, newHeight), m_solidity) != int.MinValue))
         return false;

      if (((int)Math.Ceiling(newX + newWidth) &gt; oldRect.Right) &amp;&amp; (layer.GetLeftSolidPixel(new System.Drawing.Rectangle(
         oldRect.Right, (int)newY, (int)Math.Ceiling(newX) + newWidth - oldRect.Right, newHeight), m_solidity) != int.MinValue))
         return false;

      x = newX;
      y = newY;
      state = State;
      return true;
   }

   /// &lt;summary&gt;
   /// Determines if the sprite is in the specified range of states.
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Minimum state number&lt;/param&gt;
   /// &lt;param name="LastState"&gt;Maximum state number&lt;/param&gt;
   /// &lt;returns&gt;Returns true if the sprite's current state is equal to &lt;paramref name="FirstState" /&gt; or
   /// &lt;paramref name="LastState" /&gt; or any state in between. False otherwise.&lt;/returns&gt;
   [Description("Determines if the sprite is in the specified range of states")]
   public virtual bool IsInState([Editor("SpriteState", "UITypeEditor")] int FirstState, [Editor("SpriteState", "UITypeEditor")] int LastState)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsInState on an inactive sprite");
      return (state &gt;= FirstState) &amp;&amp; (state &lt;= LastState);
   }

   /// &lt;summary&gt;
   /// Affects the sprite's visibility.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, the sprite will be drawn half-transparent.
   /// By setting it to 255, it draws in the usual way (as defined). This value is
   /// merged with the ModulateAlpha value in the frames that make up the sprite.
   /// So if the frame is set to ModulateAlpha=128 and the sprite ModulateAlpha=128,
   /// then the final visibility of the frame will only be 25% (64).
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public virtual int ModulateAlpha
   {
      get
      {
         return 0xFF &amp; color &gt;&gt; 24;
      }
      set
      {
         color = color &amp; 0x00FFFFFF | (byte)(value % 256) &lt;&lt; 24;
      }
   }

   /// &lt;summary&gt;
   /// Affects the output of red when this sprite is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, only half the red will be output, causing the
   /// sprite to appear more cyan (blue/green) than normal. This value is merged with
   /// the ModulateRed value in the frames that make up the sprite. So if the frame is
   /// set to ModulateRed=128 and the sprite ModulateRed=128, then the final image will
   /// only contain 25% of the original red.
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public virtual int ModulateRed
   {
      get
      {
         return (color &amp; 0x00FF0000) &gt;&gt; 16;
      }
      set
      {
         color = (int)(color &amp; 0xFF00FFFF) | (byte)(value % 256) &lt;&lt; 16;
      }
   }

   /// &lt;summary&gt;
   /// Affects the output of green when this sprite is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, only half the green will be output, causing the
   /// sprite to appear more magenta (red+blue) than normal. This value is merged with
   /// the ModulateGreen value in the frames that make up the sprite. So if the frame is
   /// set to ModulateGreen=128 and the sprite ModulateGreen=128, then the final image will
   /// only contain 25% of the original red.
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public virtual int ModulateGreen
   {
      get
      {
         return (color &amp; 0x0000FF00) &gt;&gt; 8;
      }
      set
      {
         color = (int)(color &amp; 0xFFFF00FF) | (byte)(value % 256) &lt;&lt; 8;
      }
   }

   /// &lt;summary&gt;
   /// Affects the output of blue when this sprite is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, only half the blue will be output, causing the
   /// sprite to appear more yellow (red+green) than normal. This value is merged with
   /// the ModulateBlue value in the frames that make up the sprite. So if the frame is
   /// set to ModulateBlue=128 and the sprite ModulateBlue=128, then the final image will
   /// only contain 25% of the original blue.
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public virtual int ModulateBlue
   {
      get
      {
         return color &amp; 0xFF;
      }
      set
      {
         color = (int)(color &amp; 0xFFFFFF00) | (byte)(value % 256);
      }
   }
   #endregion

   #region Input Processing
   /// &lt;summary&gt;
   /// Determine if the specified input is being pressed for this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Input"&gt;Which of thes sprite's inputs should be checked&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If this is true, the result will only be true if the input has just been pressed and was not pressed before.&lt;/param&gt;
   /// &lt;returns&gt;If &lt;paramref name="InitialOnly" /&gt; is set, true only when the specified input on this
   /// sprite has just been turned on or pressed, otherwise true if the input is currently on or
   /// "pressed" regardless of the previous state of the input.&lt;/returns&gt;
   /// &lt;remarks&gt;This function uses &lt;see cref="oldinputs"/&gt; to determine whether an input
   /// was pressed before or not (when InitialOnly is true). &lt;see cref="oldinputs"/&gt;
   /// is automatically managed by the &lt;see cref="MapPlayerToInputs"/&gt; function.
   /// &lt;seealso cref="oldinputs"/&gt;&lt;/remarks&gt;
   [Description("Determine if the specified input is being pressed for this sprite.  InitialOnly causes this to return true only if the input has just been pressed and was not pressed before.")]
   public virtual bool IsInputPressed(InputBits Input, bool InitialOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsInputPressed on an inactive sprite");
      return (0 != (inputs &amp; Input)) &amp;&amp;
         (!InitialOnly || (0 == (oldinputs &amp; Input)));
   }

   /// &lt;summary&gt;
   /// Turns on or off the specified input on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Input"&gt;Indicates a particular input to be affected.&lt;/param&gt;
   /// &lt;param name="Press"&gt;True if the input should be turned on or "pressed", False if the
   /// input should be turned off or "released".&lt;/param&gt;
   /// &lt;remarks&gt;Although this function can be used to set a sprite's inputs based on rules,
   /// &lt;see cref="MapPlayerToInputs"/&gt; is the recommended means for setting inputs on a
   /// sprite. &lt;see cref="SetInputState"/&gt; does not affect &lt;see cref="oldinputs"/&gt;, so if
   /// you want to use this function with the InitialOnly feature of
   /// &lt;see cref="IsInputPressed"/&gt;, you will have to manage &lt;see cref="oldinputs"/&gt;
   /// manually.&lt;/remarks&gt;
   [Description("Turns on or off the specified input on this sprite.")]
   public virtual void SetInputState(InputBits Input, bool Press)
   {
      Debug.Assert(this.isActive, "Attempted to execute SetInputState on an inactive sprite");
      if (Press)
         inputs |= Input;
      else
         inputs &amp;= ~Input;
   }

   /// &lt;summary&gt;
   /// Turns off all current inputs on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="SetOldInputs"&gt;True if you want to remember the current set of inputs
   /// as the inputs for the previous frame (&lt;see cref="oldinputs"/&gt;).
   /// False if you just want to clear the inputs.&lt;/param&gt;
   [Description("Turns off all current inputs on this sprite.")]
   public virtual void ClearInputs(bool SetOldInputs)
   {
      Debug.Assert(this.isActive, "Attempted to execute ClearInputs on an inactive sprite");
      if (SetOldInputs)
         oldinputs = inputs;
      inputs = 0;
   }

   /// &lt;summary&gt;
   /// Associates the state of the specified keyboard key with the specified input on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="key"&gt;Which key should be tested&lt;/param&gt;
   /// &lt;param name="Input"&gt;Which sprite input should be affected&lt;/param&gt;
   /// &lt;remarks&gt;This function does not affect &lt;see cref="oldinputs"/&gt;.&lt;/remarks&gt;
   [Description("Associates the state of the specified keyboard key with the specified input on this sprite.")]
   public virtual void MapKeyToInput(Key key, InputBits Input)
   {
      Debug.Assert(this.isActive, "Attempted to execute MapKeyToInput on an inactive sprite");
      SetInputState(Input, Project.GameWindow.KeyboardState[key]);
   }

   /// &lt;summary&gt;
   /// Associate the state of the input device for the specified player with the inputs on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="PlayerNumber"&gt;Player number 1 through 4. The number must not exceed
   /// the maximum number of players specified in the project properties and stored in
   /// &lt;see cref="Project.MaxPlayers"/&gt;.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;Before the inputs are mapped from the player's input device to the sprite,
   /// the existing inputs are copied from &lt;see cref="inputs"/&gt; to &lt;see cref="oldinputs"/&gt;
   /// so other rules will be able to determine which inputs were pressed before.&lt;/para&gt;
   /// &lt;para&gt;The input device is defined by the player at runtime, and may come from a
   /// joystick, gamepad or keyboard.&lt;/para&gt;&lt;/remarks&gt;
   [Description("Associate the state of the input device for the specified player (1-4) with the inputs on this sprite.")]
   public virtual void MapPlayerToInputs(int PlayerNumber)
   {
      Debug.Assert(this.isActive, "Attempted to execute MapPlayerToInput on an inactive sprite");
      if (PlayerNumber &gt; Project.MaxPlayers)
      {
         Debug.Fail("Attempted to map inactive player input");
         return;
      }
      oldinputs = inputs;
      IPlayer player = Project.GameWindow.Players[PlayerNumber - 1];
      inputs = 0;
      if (PlayerPressButton(PlayerNumber, player))
      {
         if (player.Up) inputs |= InputBits.Up;
         if (player.Left) inputs |= InputBits.Left;
         if (player.Right) inputs |= InputBits.Right;
         if (player.Down) inputs |= InputBits.Down;
         if (player.Button1) inputs |= InputBits.Button1;
         if (player.Button2) inputs |= InputBits.Button2;
         if (player.Button3) inputs |= InputBits.Button3;
         if (player.Button4) inputs |= InputBits.Button4;
      }
   }

   /// &lt;summary&gt;
   /// Accelerate this sprite according to which directional inputs are on/pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Acceleration"&gt;Specifies how much effect any input can have on acceleration in tenths of a pixel per frame per frame&lt;/param&gt;
   /// &lt;param name="Max"&gt;Specifies the maximum speed to which the sprite can accelerate along any particular axis in pixels per frame&lt;/param&gt;
   /// &lt;param name="HorizontalOnly"&gt;If this is true, only horizontal acceleration will be applied. (Often times in platform games,
   /// a sprite can move horizontally, but in order to move vertically, must jump.)&lt;/param&gt;
   /// &lt;remarks&gt;If the sprite's &lt;see cref="LocalDX"/&gt; or &lt;see cref="LocalDY"/&gt; properties are
   /// set (if the sprite is riding another sprite) this will affect the local velocity and
   /// affect &lt;see cref="dx"/&gt; and/or &lt;see cref="dy"/&gt; only indirectly.&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example would accelerate a sprite horizontally at 1 pixel per frame per frame
   /// up to a maximum of 5 pixels per frame.
   /// &lt;code&gt;AccelerateByInputs(10, 5, true)&lt;/code&gt;&lt;/example&gt;
   [Description("Accelerate this sprite according to which directional inputs are on.  Acceleration is in tenths of a pixel per frame squared.  Max is in pixels per frame.")]
   public virtual void AccelerateByInputs(int Acceleration, int Max, bool HorizontalOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute AccelerateByInputs on an inactive sprite");
      if (!HorizontalOnly)
      {
         if (double.IsNaN(LocalDY))
         {
            if (0 != (inputs &amp; InputBits.Up))
               dy -= ((double)Acceleration) / 10.0d;
            if (dy &lt; -(double)Max)
               dy = -(double)Max;
            if (0 != (inputs &amp; InputBits.Down))
               dy += ((double)Acceleration) / 10.0d;
            if (dy &gt; (double)Max)
               dy = (double)Max;
         }
         else
         {
            if (0 != (inputs &amp; InputBits.Up))
               LocalDY -= ((double)Acceleration) / 10.0d;
            if (LocalDY &lt; -(double)Max)
               LocalDY = -(double)Max;
            if (0 != (inputs &amp; InputBits.Down))
               LocalDY += ((double)Acceleration) / 10.0d;
            if (LocalDY &gt; (double)Max)
               LocalDY = (double)Max;
         }
      }
      if (double.IsNaN(LocalDX))
      {
         if (0 != (inputs &amp; InputBits.Left))
            dx -= ((double)Acceleration) / 10.0d;
         if (dx &lt; -(double)Max)
            dx = -(double)Max;
         if (0 != (inputs &amp; InputBits.Right))
            dx += ((double)Acceleration) / 10.0d;
         if (dx &gt; (double)Max)
            dx = (double)Max;
      }
      else
      {
         if (0 != (inputs &amp; InputBits.Left))
            LocalDX -= ((double)Acceleration) / 10.0d;
         if (LocalDX &lt; -(double)Max)
            LocalDX = -(double)Max;
         if (0 != (inputs &amp; InputBits.Right))
            LocalDX += ((double)Acceleration) / 10.0d;
         if (LocalDX &gt; (double)Max)
            LocalDX = (double)Max;
      }
   }

   /// &lt;summary&gt;
   /// Set the state of the directional inputs on this sprite to move toward the specified sprite in a category.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite collection containing the sprite toward which this sprite will try to move.&lt;/param&gt;
   /// &lt;param name="Index"&gt;Use &lt;see cref="GetNearestSpriteIndex"/&gt; to compute this value or pass -1 to compute the current nearest sprite each time this is called.&lt;/param&gt;
   /// &lt;remarks&gt;This function assumes that the directional inputs on the sprite
   /// cause the sprite to move directly in the direction associated with the input.  It will
   /// not work if, for example, left arrow causes the sprite to turn left instead of move left.
   /// &lt;seealso cref="SetInputsTowardSprite"/&gt;
   /// &lt;seealso cref="PushTowardCategory"/&gt;
   /// &lt;seealso cref="GetNearestSpriteIndex"/&gt;&lt;/remarks&gt;
   [Description("Set the state of the directional inputs on this sprite to move toward the specified sprite in a category, assuming the input causes the sprite to move directly in its direction. Use GetNearestSpriteIndex to compute an Index or pass -1 to use the current nearest sprite.")]
   public virtual void SetInputsTowardCategory(SpriteCollection Target, int Index)
   {
      Debug.Assert(this.isActive, "Attepmted to execute SetInputsTowardCategory on an inactive sprite");
      Debug.Assert(Index &lt; Target.Count, "Attempted to SetInputsTowardCategory on an index beyond the bounds of a collection");

      if (Index &lt; 0)
         Index = GetNearestSpriteIndex(Target);
      if (Index &lt; 0)
      {
         inputs &amp;= ~(InputBits.Left | InputBits.Right | InputBits.Up | InputBits.Down);
         return;
      }

      SetInputsTowardSprite(Target[Index]);
   }

   /// &lt;summary&gt;
   /// Set the state of the directional inputs on this sprite to move toward the specified sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite collection containing the sprite toward which
   /// this sprite will try to move.&lt;/param&gt;
   /// &lt;remarks&gt;This function is not exposed as a rule function because it is intended to be
   /// called by a plan or other code that can provide a target sprite based on specific
   /// context whereas a sprite definition rule function is supposed to be generic.
   /// This is called by &lt;see cref="SetInputsTowardCategory"/&gt;.&lt;/remarks&gt;
   public virtual void SetInputsTowardSprite(SpriteBase Target)
   {
      int targetCenter = Target.PixelX + Target.SolidWidth / 2;
      int myCenter = PixelX + SolidWidth / 2;

      if (targetCenter &lt; myCenter)
         inputs |= InputBits.Left;
      else if (targetCenter &gt; myCenter)
         inputs |= InputBits.Right;
      else
         inputs &amp;= ~(InputBits.Left | InputBits.Right);

      targetCenter = Target.PixelY + Target.SolidHeight / 2;
      myCenter = PixelY + SolidHeight / 2;
      if (targetCenter &lt; myCenter)
         inputs |= InputBits.Up;
      else if (targetCenter &gt; myCenter)
         inputs |= InputBits.Down;
      else
         inputs &amp;= ~(InputBits.Up | InputBits.Down);
   }

   /// &lt;summary&gt;
   /// Move the sprite to the position of the mouse cursor and set the sprite's button inputs based on mouse button states.
   /// &lt;/summary&gt;
   /// &lt;param name="InstantMove"&gt;If true, the sprite will be moved immediately without regard to
   /// the existing position or solidity or anything else.  If false, the sprite's position will
   /// not be immediately changed, but its velocity will be set so that the sprite will end up at
   /// the mouse cursor's location after &lt;see cref="MoveByVelocity"/&gt; executes. Note that moving
   /// the sprite instantly will ignore solidity and will not work well with sprites riding on
   /// this sprite, while allowing just the velocity to be set will allow this, but limit the
   /// sprite's movement based on solidity.&lt;/param&gt;
   /// &lt;param name="hotSpot"&gt;Which part of the sprite will move to the mouse point.&lt;/param&gt;
   /// &lt;remarks&gt;Before the button inputs are mapped from the mouse to the sprite,
   /// the existing inputs are copied from &lt;see cref="inputs"/&gt; to &lt;see cref="oldinputs"/&gt;
   /// so other rules will be able to determine which buttons were pressed before.
   /// &lt;/remarks&gt;
   [Description("Move the sprite to the position of the mouse cursor and set the sprite's button inputs based on mouse button states. If InstantMove is true, the sprite will be moved immediately, otherwise it the velocity will be set to move when MoveByVelocity runs.")]
   public virtual void MapMouseToSprite(bool InstantMove, RelativePosition hotSpot)
   {
      System.Drawing.Point pos = ParentLayer.GetMousePosition();
      System.Drawing.Point hotPoint = GetRelativePosition(hotSpot);
      if (InstantMove)
      {
         oldX = x;
         oldY = y;
         x = pos.X + x - hotPoint.X;
         y = pos.Y + y - hotPoint.Y;
      }
      else
      {
         dx = pos.X - hotPoint.X;
         dy = pos.Y - hotPoint.Y;
      }
      oldinputs = inputs;
      inputs = 0;
      if (0 != (System.Windows.Forms.Control.MouseButtons &amp; System.Windows.Forms.MouseButtons.Left))
         inputs |= InputBits.Button1;
      if (0 != (System.Windows.Forms.Control.MouseButtons &amp; System.Windows.Forms.MouseButtons.Right))
         inputs |= InputBits.Button2;
      if (0 != (System.Windows.Forms.Control.MouseButtons &amp; System.Windows.Forms.MouseButtons.Middle))
         inputs |= InputBits.Button3;
   }
   #endregion

   #region Solidity
   /// &lt;summary&gt;
   /// Set the solidity rules to which the sprite is currently reacting.
   /// &lt;/summary&gt;
   /// &lt;param name="Solidity"&gt;Specified which solidity rules should adopt.&lt;/param&gt;
   /// &lt;remarks&gt;Since solidity is based on tile categories which in turn can contain
   /// tiles from multiple tilesets, the same solidity definition can apply to any
   /// number of maps with different tilesets. So this doesn't need to be called
   /// just to handle tiles from a different tileset, but could be called to make
   /// the sprite act differently to all tiles (for example, to suddenly be able to
   /// traverse any water).&lt;/remarks&gt;
   [Description("Set the solidity rules to which the sprite is currently reacting.")]
   public virtual void SetSolidity(Solidity Solidity)
   {
      m_solidity = Solidity;
   }

   /// &lt;summary&gt;
   /// Alter the sprite's velocity to react to solid areas on the map.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if the sprite's velocity was altered; in other words, if it pushed
   /// against something solid. That doesn't necessarily mean the sprite was stopped by
   /// something solid because it may just be pushed uphill.&lt;/returns&gt;
   /// &lt;remarks&gt;It is recommended that this be the last rule applied to the sprite's velocity
   /// before &lt;see cref="MoveByVelocity"/&gt; is applied. This will help ensure that the sprite
   /// never goes through solids even if scrolling and platforms try to make it.&lt;/remarks&gt;
   [Description("Alter the sprite's velocity to react to solid areas on the map.  Returns true if velocity is affected by solid.")]
   public virtual bool ReactToSolid()
   {
      Debug.Assert(this.isActive, "Attempted to execute ReactToSolid on an inactive sprite");
      if (m_solidity == null)
         throw new System.ApplicationException("Attempted to execute ReactToSolid on sprite without solidity defined");
      bool hit = false;
      double dyOrig = dy;
      double dxOrig = dx;

      int ProposedPixelY2 = (int)Math.Ceiling(y + dy);
      int SolidPixelWidth = SolidWidth + (int)Math.Ceiling(x) - PixelX;
      if (dy &gt; 0)
      {
         int ground = layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX, PixelY + SolidHeight, SolidPixelWidth, ProposedPixelY2 - PixelY), m_solidity);
         if (ground != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ground - SolidHeight - y;
            hit = true;
         }
      }
      else if (dy &lt; 0)
      {
         int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX, ProposedPixelY, SolidPixelWidth, PixelY - ProposedPixelY), m_solidity);
         if (ceiling != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ceiling + 1 - y;
            hit = true;
         }
      }

      if (dx &gt; 0)
      {
         int ProposedPixelX2 = (int)Math.Ceiling(x + dx);
         int PixelX2 = (int)Math.Ceiling(x);
         int rightwall = layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, ProposedPixelY, ProposedPixelX2 - PixelX2, SolidHeight), m_solidity);
         bool hitWall = false;
         if (rightwall != int.MinValue)
         {
            int maxSlopeProposedY = (int)(y + dy - dx);
            int slopedFloor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, maxSlopeProposedY + SolidHeight, ProposedPixelX2 - PixelX2, ProposedPixelY - maxSlopeProposedY), m_solidity);
            if (slopedFloor != int.MinValue)
            {
               int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX2, slopedFloor - SolidHeight, SolidWidth, ProposedPixelY + SolidHeight - slopedFloor), m_solidity);
               if ((ceiling == int.MinValue) &amp;&amp; (RidingOn == null))
               {
                  int rightwall2 = layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, slopedFloor - SolidHeight, ProposedPixelX2 - PixelX2, SolidHeight), m_solidity);
                  if (rightwall2 == int.MinValue)
                     // Do integer arithmetic before double otherwise strange rounding seems to happen
                     dy = dyOrig = slopedFloor - SolidHeight - 1 - y;
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            else
            {
               maxSlopeProposedY = (int)(y + dy + dx);
               int slopedCeiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, ProposedPixelY, ProposedPixelX2 - PixelX2, maxSlopeProposedY - ProposedPixelY), m_solidity);
               if (slopedCeiling != int.MinValue)
               {
                  slopedCeiling++;
                  int floor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX2, ProposedPixelY + SolidHeight, SolidWidth, slopedCeiling - ProposedPixelY), m_solidity);
                  if ((floor == int.MinValue) &amp;&amp; (RidingOn == null))
                  {
                     int rightwall2 = layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, slopedCeiling, ProposedPixelX2 - PixelX2, SolidHeight), m_solidity);
                     if (rightwall2 == int.MinValue)
                        dy = dyOrig = slopedCeiling - y;
                     else
                        hitWall = true;
                  }
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            if (hitWall)
            {
               // Do integer arithmetic before double otherwise strange rounding seems to happen
               dx = rightwall - SolidWidth - x;
            }
            hit = true;
         }
      }
      else if (dx &lt; 0)
      {
         int leftwall = layer.GetRightSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY, PixelX - ProposedPixelX, SolidHeight), m_solidity);
         bool hitWall = false;
         if (leftwall != int.MinValue)
         {
            int maxSlopeProposedY = (int)(y + dy + dx);
            int slopedFloor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, maxSlopeProposedY + SolidHeight, PixelX - ProposedPixelX, ProposedPixelY - maxSlopeProposedY), m_solidity);
            if (slopedFloor != int.MinValue)
            {
               int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX, slopedFloor - SolidHeight, SolidWidth, ProposedPixelY + SolidHeight - slopedFloor), m_solidity);
               if ((ceiling == int.MinValue) &amp;&amp; (RidingOn == null))
               {
                  int leftwall2 = layer.GetRightSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, slopedFloor - SolidHeight, PixelX - ProposedPixelX, SolidHeight), m_solidity);
                  if (leftwall2 == int.MinValue)
                     // Do integer arithmetic before double otherwise strange rounding seems to happen
                     dy = dyOrig = slopedFloor - SolidHeight - 1 - y;
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            else
            {
               maxSlopeProposedY = (int)(y + dy - dx);
               int slopedCeiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY, PixelX - ProposedPixelX, maxSlopeProposedY - ProposedPixelY), m_solidity);
               if (slopedCeiling != int.MinValue)
               {
                  slopedCeiling++;
                  int floor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX, ProposedPixelY + SolidHeight, SolidWidth, slopedCeiling - ProposedPixelY), m_solidity);
                  if ((floor == int.MinValue) &amp;&amp; (RidingOn == null))
                  {
                     int leftwall2 = layer.GetRightSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, slopedCeiling, PixelX - ProposedPixelX, SolidHeight), m_solidity);
                     if (leftwall2 == int.MinValue)
                        dy = dyOrig = slopedCeiling - y;
                     else
                        hitWall = true;
                  }
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            if (hitWall)
            {
               // Do integer arithmetic before double otherwise strange rounding seems to happen
               dx = leftwall + 1 - x;
            }
            hit = true;
         }
      }

      dy = dyOrig;

      int ProposedSolidPixelWidth = SolidWidth + (int)Math.Ceiling(x + dx) - ProposedPixelX;
      if (dy &gt; 0)
      {
         ProposedPixelY2 = (int)Math.Ceiling(y + dy);
         int ground = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, PixelY + SolidHeight, ProposedSolidPixelWidth, ProposedPixelY2 - PixelY), m_solidity);
         if (ground != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ground - SolidHeight - y;
            hit = true;
         }
      }
      else if (dy &lt; 0)
      {
         int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY, ProposedSolidPixelWidth, PixelY - ProposedPixelY), m_solidity);
         if (ceiling != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ceiling + 1 - y;
            hit = true;
         }
      }

      if (hit &amp;&amp; !double.IsNaN(LocalDX))
         LocalDX += dx - dxOrig;

      return hit;
   }

   /// &lt;summary&gt;
   /// Ensure the sprite stays in contact with the ground by altering its velocity
   /// to snap down onto the ground when it is close to the ground.
   /// &lt;/summary&gt;
   /// &lt;param name="Threshhold"&gt;The number of pixels that mey separate the sprite from the ground.
   /// If the sprite is within this threshhold distance, it will be "snapped".&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was snapped to the ground.&lt;/returns&gt;
   /// &lt;remarks&gt;Note that this does not actually move the sprite, but rather just alters its
   /// velocity so that when &lt;see cref="MoveByVelocity"/&gt; is applied, it will be touching the
   /// ground, if the appropriate conditions are met. The purpose of this rule is to help sprites
   /// behave as desired when going downhill in case the force of gravity isn't enough to keep
   /// them "grounded" (which it often isn't with the simple physics model used for sprites).
   /// &lt;/remarks&gt;
   [Description("If the sprite's proposed position is within &lt;Threshhold&gt; pixels of the ground, alter its velocity so it will touch the ground.  Returns true if snap occurred.")]
   public virtual bool SnapToGround(int Threshhold)
   {
      Debug.Assert(this.isActive, "Attempted to execute SnapToGround on an inactive sprite");

      int ProposedSolidPixelWidth = SolidWidth + (int)Math.Ceiling(x + dx) - ProposedPixelX;
      int ground = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY + SolidHeight, ProposedSolidPixelWidth, Threshhold), m_solidity);
      if (ground != int.MinValue)
      {
         // Do integer arithmetic before double otherwise strange rounding seems to happen
         double newDy = ground - SolidHeight - y;
         if (newDy &gt; dy)
            dy = newDy;
         return true;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Determines if the sprite is blocked from moving freely in a particular direction by solidity on the layer.
   /// &lt;/summary&gt;
   /// &lt;param name="Direction"&gt;Which direction should be tested&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite's velocity will be affected or stopped when attempting
   /// to move in the specified direction.  False if the sprite can move freely in that
   /// direction.&lt;/returns&gt;
   /// &lt;remarks&gt;Note that this function only tests if there is any solidity in the specified
   /// direction, but does not indicate whether the sprite will be blocked by it or simply
   /// deflected (up or down a hill) by it.&lt;/remarks&gt;
   [Description("Determines if the sprite is blocked from moving freely in a particular direction by solidity on the layer.")]
   public virtual bool Blocked(Direction Direction)
   {
      Debug.Assert(this.isActive, "Attempted to execute Blocked on an inactive sprite");

      int SolidPixelWidth;
      int SolidPixelHeight;
      switch (Direction)
      {
         case Direction.Up:
            SolidPixelWidth = SolidWidth + (int)Math.Ceiling(x) - PixelX;
            return layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX, PixelY - 1, SolidPixelWidth, 1), m_solidity) != int.MinValue;
         case Direction.Right:
            SolidPixelHeight = SolidHeight + (int)Math.Ceiling(y) - PixelY;
            return layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX + SolidWidth, PixelY, 1, SolidPixelHeight), m_solidity) != int.MinValue;
         case Direction.Down:
            SolidPixelWidth = SolidWidth + (int)Math.Ceiling(x) - PixelX;
            return layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX, PixelY + SolidHeight, SolidPixelWidth, 1), m_solidity) != int.MinValue;
         case Direction.Left:
            SolidPixelHeight = SolidHeight + (int)Math.Ceiling(y) - PixelY;
            return layer.GetRightSolidPixel(new System.Drawing.Rectangle(PixelX - 1, PixelY, 1, SolidPixelHeight), m_solidity) != int.MinValue;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified point within a sprite is blocked from moving in a particular direction by the specified number of pixels.
   /// &lt;/summary&gt;
   /// &lt;param name="TestPoint"&gt;Point within the sprite from which the test is performed&lt;/param&gt;
   /// &lt;param name="Direction"&gt;Direction relative to TestPoint which will be tested for solidity&lt;/param&gt;
   /// &lt;param name="Distance"&gt;How many pixels to check for solidity from the test point&lt;/param&gt;
   /// &lt;returns&gt;True if there is solidity within Distance pixels of TestPoint, false otherwise.&lt;/returns&gt;
   [Description("Determines if the specified point within a sprite is blocked from moving in a particular direction by the specified number of pixels.")]
   public virtual bool IsPointBlocked(RelativePosition TestPoint, Direction Direction, int Distance)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsPointBlocked on an inactive sprite");
      System.Drawing.Point ptRelative = GetRelativePosition(TestPoint);
      switch (Direction)
      {
         case Direction.Up:
            return layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ptRelative.X, ptRelative.Y - Distance, 1, Distance), m_solidity) != int.MinValue;
         case Direction.Right:
            return layer.GetLeftSolidPixel(new System.Drawing.Rectangle(ptRelative.X + 1, ptRelative.Y, Distance, 1), m_solidity) != int.MinValue;
         case Direction.Down:
            return layer.GetTopSolidPixel(new System.Drawing.Rectangle(ptRelative.X, ptRelative.Y + 1, 1, Distance), m_solidity) != int.MinValue;
         case Direction.Left:
            return layer.GetRightSolidPixel(new System.Drawing.Rectangle(ptRelative.X - Distance, ptRelative.Y, Distance, 1), m_solidity) != int.MinValue;
      }
      return false;
   }

   #endregion

   #region Tile Interaction
   /// &lt;summary&gt;
   /// Tracks information about a tile for the purposes of processing interactions
   /// between a sprite and a tile that it is touching.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Instances of this class are created by &lt;see cref="TouchTiles"/&gt;.
   /// and added to &lt;see cref="TouchedTiles"/&gt;.&lt;/remarks&gt;
   public class TouchedTile
   {
      public int x;
      public int y;
      public int tileValue;
      public bool initial;
      public bool processed;

      public TouchedTile(int x, int y, int tileValue, bool initial)
      {
         this.x = x;
         this.y = y;
         this.tileValue = tileValue;
         this.initial = initial;
         processed = false;
      }
   }

   // Do not allocate appreciable memory unless this sprite
   // participates in tile interaction.
   /// &lt;summary&gt;
   /// A collection of tiles being processed by &lt;see cref="TouchTiles"/&gt; and other rules
   /// related to tile interactions.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;see cref="TouchTiles"/&gt; populates this object, and other touch-functions
   /// then process the data about tiles that the sprite is touching stored in this
   /// object. It's not usually necessary to refer to this object directly.&lt;/remarks&gt;
   [NonSerialized()]
   public System.Collections.Generic.List&lt;TouchedTile&gt; TouchedTiles = null;

   /// &lt;summary&gt;
   /// Collects information about tiles the sprite is currently touching.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;This should supply a tile category that includes all tiles that the sprite interacts with.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is touching any tiles in the supplied category.&lt;/returns&gt;
   /// &lt;remarks&gt;This must be called before performing most forms of tile interaction.
   /// By supplying a single category containing all tiles with which the sprite may need
   /// to interact, performance is optimized so that each tile touching the sprite only
   /// needs to be inspected once to check if it's relevant.  This also helps simplify the
   /// process of processing each tile exactly once by queuing a list of tiles to be
   /// processed and tracking which of those tiles have been processed.
   /// &lt;seealso cref="TileTake"/&gt;&lt;seealso cref="TileUseUp"/&gt;&lt;seealso cref="TileTouchingIndex"/&gt;
   /// &lt;seealso cref="TileActivateSprite"/&gt;&lt;seealso cref="TileAddSprite"/&gt;
   /// &lt;seealso cref="TileChange"/&gt;&lt;seealso cref="TileChangeTouched"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;This example will check to see if the current sprite is touching
   /// any tiles in a category named "Touchable" and then (assuming tile numbers 10
   /// and 11 are members of this category) take any tiles whose number is 10 as an
   /// inventory item represented by a counter named "Coins", and take any tiles whose
   /// number is 11 as an inventory item represented by a counter named "Keys".
   /// &lt;code lang="C#"&gt;
   /// if (TouchTiles(TileCategoryName.Touchable))
   /// {
   ///    TileTake(10,Counter.Coins))
   ///    TileTake(11,Counter.Keys))
   /// }&lt;/code&gt;&lt;/example&gt;
   [Description("Collects information about tiles the sprite is currently touching.  Category should include all tiles that the sprite interacts with.  Must be called before performing any tile interaction.")]
   public virtual bool TouchTiles(TileCategoryName Category)
   {
      Debug.Assert(this.isActive, "Attempted to execute TouchTiles on an inactive sprite");

      if (TouchedTiles != null)
         TouchedTiles.Clear();

      int tw = layer.Tileset.TileWidth;
      int th = layer.Tileset.TileHeight;
      int minYEdge = (PixelY / th);
      int maxY = (PixelY + SolidHeight) / th;
      if (maxY &gt;= layer.VirtualRows)
         maxY = layer.VirtualRows - 1;
      int maxYEdge = (PixelY + SolidHeight - 1) / th;
      int minX = (PixelX - 1) / tw;
      int minXEdge = PixelX / tw;
      int maxX = (PixelX + SolidWidth) / tw;
      if (maxX &gt;= layer.VirtualColumns)
         maxX = layer.VirtualColumns - 1;
      int maxXEdge = (PixelX + SolidWidth - 1) / tw;
      for (int yidx = (PixelY - 1) / th; yidx &lt;= maxY; yidx++)
      {
         bool isYEdge = !((yidx &gt;= minYEdge) &amp;&amp; (yidx &lt;= maxYEdge));
         for (int xidx = (isYEdge ? minXEdge : minX);
            xidx &lt;= (isYEdge ? maxXEdge : maxX);
            xidx++)
         {
            if (layer.GetTile(xidx, yidx).IsMember(Category))
            {
               bool wasTouching;

               if ((OldPixelX &lt;= xidx * tw + tw) &amp;&amp;
                  (OldPixelX + SolidWidth &gt;= xidx * tw) &amp;&amp;
                  (OldPixelY &lt;= yidx * th + th) &amp;&amp;
                  (OldPixelY + SolidHeight &gt;= yidx * th))
               {
                  bool edgeX = (OldPixelX + SolidWidth == xidx * tw) ||
                     (OldPixelX == xidx * tw + tw);
                  bool edgeY = (OldPixelY + SolidHeight == yidx * th) ||
                     (OldPixelY == yidx * th + th);
                  if (edgeX &amp;&amp; edgeY)
                     wasTouching = false;
                  else
                     wasTouching = true;
               }
               else
                  wasTouching = false;

               if (TouchedTiles == null)
                  TouchedTiles = new System.Collections.Generic.List&lt;TouchedTile&gt;(10);
               TouchedTiles.Add(new TouchedTile(xidx, yidx, layer[xidx, yidx], !wasTouching));
            }
         }
      }
      if (TouchedTiles == null)
         return false;
      return TouchedTiles.Count &gt; 0;
   }

   /// &lt;summary&gt;
   /// Determine if the sprite is touching the specified tile, and if so,
   /// "take" it and increment a counter (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Index of the tile to look for.&lt;/param&gt;
   /// &lt;param name="Counter"&gt;Counter to be checked and incremented when the specified tile is found.
   /// If the counter's maximum value has been reached, the tile will not be taken.&lt;/param&gt;
   /// &lt;param name="NewValue"&gt;Specified the tile value with which the touched tile will
   /// be replaced if the counter has not hit its maximum.&lt;/param&gt;
   /// &lt;returns&gt;The number of tiles affected.&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function will search through all tiles that have been touched (collected
   /// by &lt;see cref="TouchTiles"/&gt;, and for each tile that it finds that matches the specified
   /// &lt;paramref name="TileValue" /&gt;, it will check &lt;paramref name="Counter" /&gt;, and, if it
   /// has not yet reached the maximum value, increment the counter and replace the tile with
   /// the tile number specified by NewValue.&lt;/para&gt;&lt;para&gt;
   /// Only unprocessed tiles are considered. Once this function (or similar functions)
   /// affects the tile, it is marked as processed. It is only marked as processed if
   /// it is affected (if the counter changes).&lt;/para&gt;&lt;/remarks&gt;
   [Description("When the sprite is touching the specified tile, and the specified counter is not maxed, change/clear the tile value to NewValue and increment the specified counter/parameter. Returns the number of tiles affected. (Must run TouchTiles first.)")]
   public virtual int TileTake(int TileValue, Counter Counter, int NewValue)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileTake on an inactive sprite");

      if (TouchedTiles == null)
         return 0;

      int result = 0;

      for (int i = 0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = TouchedTiles[i];
         if ((tt.tileValue == TileValue) &amp;&amp; (!tt.processed))
         {
            if (Counter.CurrentValue &lt; Counter.MaxValue)
            {
               Counter.CurrentValue++;
               layer[tt.x, tt.y] = tt.tileValue = NewValue;
               tt.processed = true;
               result++;
            }
            else
               break;
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Make the specified tile behave like it is "using up" one of the items tracked by the specified counter (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Index of the tile to look for&lt;/param&gt;
   /// &lt;param name="Counter"&gt;Specifies a counter that will be affected. If this counter's value is
   /// greater than 0, it will be decremented and the tile removed.&lt;/param&gt;
   /// &lt;param name="NewValue"&gt;Specifies a new tile value that will replace the touched tile when
   /// it is removed. This value is commonly 0, which usually represents a tileset's empty tile.&lt;/param&gt;
   /// &lt;returns&gt;The number of tiles affected&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function will search through all tiles that have been touched (collected
   /// by &lt;see cref="TouchTiles"/&gt;, and for each tile that it finds that matches the specified
   /// &lt;paramref name="TileValue" /&gt;, it will check &lt;paramref name="Counter" /&gt;, and, if it
   /// is greater than 0, decrement the counter and replace the tile with tile number
   /// &lt;paramref name="NewValue"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;Only unprocessed tiles are considered. Once this function (or similar functions)
   /// affects the tile, it is marked as processed. It is only marked as processed if
   /// it is affected (if the counter changes).&lt;/para&gt;&lt;/remarks&gt;
   [Description("When the sprite is touching the specified tile, and the specified counter is greater than 0, decrement the counter and clear the tile value to NewValue. Returns the number of tiles affected. (Must run TouchTiles first.)")]
   public virtual int TileUseUp(int TileValue, Counter Counter, int NewValue)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileUseUp on an inactive sprite");

      if (TouchedTiles == null)
         return 0;

      int result = 0;

      for (int i = 0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = TouchedTiles[i];
         if ((tt.tileValue == TileValue) &amp;&amp; (!tt.processed))
         {
            if (Counter.CurrentValue &gt; 0)
            {
               Counter.CurrentValue--;
               layer[tt.x, tt.y] = tt.tileValue = NewValue;
               tt.processed = true;
               result++;
            }
            else
               break;
         }
      }
      return result;
   }


   /// &lt;summary&gt;
   /// Determine if the sprite is touching a tile in the specified category (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Category of tiles to be tested&lt;/param&gt;
   /// &lt;param name="TouchingIndex"&gt;Receives the index of the first qualifying tile
   /// if the sprite is touching a tile in the specified category.  This is an index
   /// into the &lt;see cref="TouchedTiles"/&gt; array returned by &lt;see cref="TouchTiles"/&gt;.&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If true, a tile can only qualify if the sprite was not
   /// already touching the tile in the previous frame.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is touching a tile in the specified category, false otherwise.&lt;/returns&gt;
   [Description("Determine if the sprite is touching the specified tile. TouchingIndex is updated to refer to the index of the first qualifying tile if true. Returns true if the sprite is touching a tile in the specified category. (Must run TouchTiles first.)")]
   public virtual bool TileCategoryTouched(TileCategoryName Category/*, ref int TouchingIndex*/, bool InitialOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileCategoryTouched on an inactive sprite");

      if (TouchedTiles == null)
         return false;

      for (int i = 0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = TouchedTiles[i];
         if (!tt.processed &amp;&amp; layer.GetTile(tt.x, tt.y).IsMember(Category)
            &amp;&amp; (!InitialOnly || tt.initial))
         {
            this.GetType().GetField("TouchIndex").SetValue(this, i);
            tt.processed = true;
            return true;
         }
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Find the next unprocessed tile of the specified type (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Tile index to search for&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If this is true, the tile will only be considered if the sprite
   /// just started touching it (was not touching it before).&lt;/param&gt;
   /// &lt;param name="MarkAsProcessed"&gt;If this is true, the tile that is returned is immediately
   /// marked as processed, otherwise it is left as unprocessed and may still be affected by
   /// other tile interaction functions.&lt;/param&gt;
   /// &lt;returns&gt;The index of the next unprocessed tile in &lt;see cref="TouchedTiles"/&gt; if one
   /// exists with the specified &lt;paramref name="TileValue" /&gt;, or -1 if no such tile exists.
   /// &lt;/returns&gt;
   /// &lt;remarks&gt;While &lt;see cref="TileUseUp"/&gt; and &lt;see cref="TileTake"/&gt; provide simple
   /// access to common behaviors related to tile interactions, they aren't expected to cover
   /// all behaviors you might want to implement related to tile interactions.  This function
   /// provides a piece of functionality that will be useful in more detailed control over
   /// tile interactions.&lt;seealso cref="TouchTiles"/&gt;&lt;seealso cref="TileActivateSprite"/&gt;
   /// &lt;seealso cref="TileAddSprite"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example demonstrates how you could activate the next inactive instance of
   /// a sprite in the "Points" category at the location of any tile whose tile number is 10
   /// when the sprite touches the tile, only when the sprite first touches the tile. Performing
   /// this in a while loop ensures that all such tiles that the sprite is initially touching get
   /// processed at once, which is important because it won't be initially touching them any more
   /// in the next frame. TempNum is any temporary numeric variable, such as a sprite parameter.
   /// &lt;code&gt;
   /// if (TouchTiles(TileCategoryName.Touchable))
   /// {
   ///    TempNum = TileTouchingIndex(10, true, true);
   ///    while(TempNum &gt; 0)
   ///    {
   ///       TileActivateSprite(TempNum, ParentLayer.m_SpriteCategories.Points, true);
   ///       TempNum = TileTouchingIndex(10, true, true);
   ///    }
   /// }
   /// &lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Return the index of the next unprocessed tile with the specified value from the list of tiles the sprite is touching. If InitialOnly is set, only return tiles that the sprite wasn't already touching. Return -1 if no tiles are being touched. (Must run TouchTiles first.)")]
   public virtual int TileTouchingIndex(int TileValue, bool InitialOnly, bool MarkAsProcessed)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileTouchingIndex on an inactive sprite");

      if (TouchedTiles == null)
         return -1;

      for (int i = 0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = TouchedTiles[i];
         if ((tt.tileValue == TileValue) &amp;&amp; (!tt.processed) &amp;&amp; (!InitialOnly || tt.initial))
         {
            tt.processed = MarkAsProcessed;
            return i;
         }
      }

      return -1;
   }

   /// &lt;summary&gt;
   /// Activate the next inactive sprite from a category at the coordinates of a tile being touched by the sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="TouchingIndex"&gt;Index of the tile in the array of tiles to process (&lt;see cref="TouchedTiles"/&gt;).
   /// This can be acquired using &lt;see cref="TileTouchingIndex"/&gt;.&lt;/param&gt;
   /// &lt;param name="Category"&gt;Category containing sprites that can be activated.&lt;/param&gt;
   /// &lt;param name="ClearParameters"&gt;True if the newly activated sprite's parameters should
   /// all be set to zero.&lt;/param&gt;
   /// &lt;returns&gt;The index of the newly activated sprite, if a sprite was activated (this
   /// value will be greater than or equal to zero) or -1 if all sprites in the specified
   /// category are already activate.&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function allows you to treat a number of sprites within a category
   /// as kind of a dynamic collection of sprites which can be activated one after the other.
   /// Each time this is called, it will find and activate the next inactive sprite within
   /// the category. This limits the number of sprites that can be activated by this function
   /// to the number of actual sprite instances in the specified category on the layer where
   /// the function is executed. For a truly dynamic collection of sprites, see
   /// &lt;see cref="TileAddSprite"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;Clearing the parameters of a newly activated sprite can be very useful in initializing
   /// the sprite as soon as it is activated because the activated sprite can check to see
   /// when a particular parameter is zero. If it sees that it's zero, it can immediately set
   /// it to some other value and perform whatever initialization it needs to (such as offsetting
   /// its position from the tile by some pre-set distance).&lt;/para&gt;&lt;/remarks&gt;
   [Description("Activate the next inactive sprite from a category at the coordinates of a tile being touched by the sprite.  Use TileTouchingIndex to acquire TouchingIndex.  Returns the index into the category of the sprite that was activated, or -1 if all sprites in the category were already active.")]
   public virtual int TileActivateSprite(int TouchingIndex, SpriteCollection Category, bool ClearParameters)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileActivateSprite on an inactive sprite");

      for (int i = 0; i &lt; Category.Count; i++)
      {
         if (!Category[i].isActive)
         {
            Category[i].isActive = true;
            TouchedTile tt = TouchedTiles[TouchingIndex];
            Category[i].x = tt.x * layer.Tileset.TileWidth;
            Category[i].y = tt.y * layer.Tileset.TileHeight;
            if (ClearParameters)
            {
               Category[i].frame = 0;
               Category[i].state = 0;
               Category[i].ClearParameters();
            }
            Category[i].ProcessRules();
            return i;
         }
      }
      return -1;
   }

   /// &lt;summary&gt;
   /// Create a new (dynamic) instance of the specified sprite type at the coordinates
   /// of a tile being touched by the player.
   /// &lt;/summary&gt;
   /// &lt;param name="TouchingIndex"&gt;Refers to a tile in &lt;see cref="TouchedTiles"/&gt; by index.
   /// &lt;see cref="TileTouchingIndex"/&gt; can be used to acquire this value.&lt;/param&gt;
   /// &lt;param name="SpriteDefinition"&gt;Specifies the type of sprite that will be created.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;As opposed to &lt;see cref="TileActivateSprite"/&gt;, which activates a pre-defined
   /// instance of a sprite, this function will actually create a new sprite instance on the
   /// fly (referred to as a "dynamic" sprite instance). Dynamic sprites cannot be referred
   /// to directly by other rules because they don't have names associated with them, therefore
   /// it's recommended that &lt;see cref="TileActivateSprite"/&gt; be used when more control is
   /// desired. However, for common sprites that may be created on any map, this is ideal
   /// because it doesn't require you to pre-define each possible instance.&lt;/para&gt;
   /// &lt;para&gt;Dynamic sprites are added to the end of each category that they belong to
   /// (categories are defined in terms of sprite definitions, so a dynamic sprite knows
   /// the categories in which it should participate). This happens as the sprite is created.
   /// When the sprite is deactivated, it will automatically be removed from all categories
   /// as part of &lt;see cref="LayerBase.ProcessSprites"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;The maximum number of sprites that can be active on a layer at once is
   /// defined by &lt;see cref="SpriteCollection.maxCollectionSize"/&gt;. This includes static
   /// sprites as well as dynamic sprites. The purpose of this maximum is not a technical
   /// limitation (feel free to change the code in SpriteCollection.cs to increase the maximum
   /// all you like). It only exists to help developers realize when sprite instances are
   /// "leaking" (not being cleaned up or deactivated properly) or when more sprites than
   /// necessary are being created. In many cases, the engine can actually handle quite a
   /// bit more than 100 sprites without significant performance impact.&lt;/para&gt;
   /// &lt;para&gt;Because the sprite instances being created are not activations of already
   /// existing instances (as is the case with &lt;see cref="TileActivateSprite"/&gt;), there
   /// is no need for a parameter to reset all the sprite's parameters. All parameters of
   /// a newly created sprite instance are always initialized to zero. The solidity is copied
   /// from the sprite definition that created the sprite.&lt;/para&gt;
   /// &lt;para&gt;New sprite instances will not refer to any solidity, and will begin in the first
   /// frame of the first state, but you can use rules to affect &lt;see cref="GeneralRules.lastCreatedSprite"/&gt;
   /// to set values of the new sprite, or define rules on the created sprite type to make it
   /// initialize itself appropriately.&lt;/para&gt;
   /// &lt;seealso cref="PlanBase.AddSpriteAtPlan"/&gt;
   /// &lt;seealso cref="AddSpriteHere"/&gt;&lt;/remarks&gt;
   [Description("Create a new (dynamic) instance of the specified sprite type at the coordinates of a tile being touched by the player.  Use TileTouchingIndex to acquire TouchingIndex.")]
   public virtual void TileAddSprite(int TouchingIndex, [Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileAddSprite on an inactive sprite");

      System.Reflection.ConstructorInfo constructor = SpriteDefinition.GetConstructor(new System.Type[]
      {
         typeof(LayerBase), typeof(double), typeof(double), typeof(double), typeof(double), typeof(int), typeof(int), typeof(bool), typeof(Display), typeof(Solidity), typeof(int), typeof(bool)
      });
      TouchedTile tt = TouchedTiles[TouchingIndex];
      lastCreatedSprite = (SpriteBase)constructor.Invoke(new object[]
      {
         layer, tt.x * layer.Tileset.TileWidth, tt.y * layer.Tileset.TileHeight, 0, 0, 0, 0, true, layer.ParentMap.Display, m_solidity, -1, true
      });
   }

   /// &lt;summary&gt;
   /// Create a new (dynamic) instance of the specified sprite positioned such that HotSpot on the created sprite overlaps Location on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="SpriteDefinition"&gt;Specifies the type of sprite to create&lt;/param&gt;
   /// &lt;param name="Location"&gt;Specifies a point in the current sprite, relative to which the new
   /// sprite will be created.&lt;/param&gt;
   /// &lt;param name="HotSpot"&gt;Specifies a point within the created sprite that will be used to
   /// position the sprite (the location of the "handle" by which it is positioned).&lt;/param&gt;
   /// &lt;remarks&gt;See &lt;see cref="TileAddSprite"/&gt; for more information about dynamically added sprites.
   /// &lt;seealso cref="TileAddSprite"/&gt;&lt;seealso cref="PlanBase.AddSpriteAtPlan"/&gt;
   /// &lt;seealso cref="GeneralRules.lastCreatedSprite"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following code will create an instance of a sprite named "Bullet" such that the left side
   /// of the bullet matches up with the right side of the current sprite. (The bullet will be
   /// immediately to the right of this sprite, overlapping by 1 pixel.)
   /// &lt;code&gt;AddSpriteHere(typeof(Sprites.Bullet), RelativePosition.RightMiddle, RelativePosition.LeftMiddle);&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Create a new (dynamic) instance of the specified sprite positioned such that HotSpot on the created sprite overlaps Location on this sprite.")]
   public virtual void AddSpriteHere([Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition, RelativePosition Location, RelativePosition HotSpot)
   {
      Debug.Assert(this.isActive, "Attempted to execute AddSpriteHere on an inactive sprite");

      System.Reflection.ConstructorInfo constructor = SpriteDefinition.GetConstructor(new System.Type[]
      {
         typeof(LayerBase), typeof(double), typeof(double), typeof(double), typeof(double), typeof(int), typeof(int), typeof(bool), typeof(Display), typeof(Solidity), typeof(int), typeof(bool)
      });

      lastCreatedSprite = (SpriteBase)constructor.Invoke(new object[]
      {
         layer, 0, 0, 0, 0, 0, 0, true, layer.ParentMap.Display, m_solidity, -1, true
      });

      System.Drawing.Point ptLocation = GetRelativePosition(Location);
      System.Drawing.Point ptHotSpot = lastCreatedSprite.GetRelativePosition(HotSpot);
      lastCreatedSprite.x = lastCreatedSprite.oldX = ptLocation.X - ptHotSpot.X;
      lastCreatedSprite.y = lastCreatedSprite.oldY = ptLocation.Y - ptHotSpot.Y;
   }

   /// &lt;summary&gt;
   /// Change tiles of the specified type that the sprite is touching to another tile (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="OldTileValue"&gt;Index of the tile type to search for&lt;/param&gt;
   /// &lt;param name="NewTileValue"&gt;Which tile should these tiles be changed to&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If true, only affect tiles that the player just started touching.&lt;/param&gt;
   /// &lt;returns&gt;The number of tiles affected.&lt;/returns&gt;
   /// &lt;remarks&gt;This function changes all specified tiles at once.
   /// Use &lt;see cref="TileChangeTouched"/&gt; to change only one tile.
   /// &lt;seealso cref="TileChangeTouched"/&gt;&lt;/remarks&gt;
   [Description("Change the specified tile that the sprite is touching to another tile. Return the number of tiles affected. (Must run TouchTiles first.)")]
   public virtual int TileChange(int OldTileValue, int NewTileValue, bool InitialOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileChange on an inactive sprite");

      if (TouchedTiles == null)
         return 0;

      int result = 0;

      for (int i = 0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = TouchedTiles[i];
         if ((tt.tileValue == OldTileValue) &amp;&amp; (!tt.processed) &amp;&amp; (!InitialOnly || tt.initial))
         {
            tt.processed = true;
            layer[tt.x, tt.y] = tt.tileValue = NewTileValue;
            result++;
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Change the tile specified by TouchingIndex that is being touched by the sprite to another tile (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TouchingIndex"&gt;Refers to a tile in &lt;see cref="TouchedTiles"/&gt; by index.
   /// &lt;see cref="TileTouchingIndex"/&gt; can be used to acquire this value.&lt;/param&gt;
   /// &lt;param name="NewTileValue"&gt;Specifies the tileset tile index of the new tile that will appear in place of the specified tile.&lt;/param&gt;
   [Description("Change the tile specified by TouchingIndex that is being touched by the sprite to another tile. (Must run TouchTiles first.)")]
   public virtual void TileChangeTouched(int TouchingIndex, int NewTileValue)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileChangeTouched on an inactive sprite");
      Debug.Assert((TouchedTiles != null) &amp;&amp; (TouchedTiles.Count &gt; TouchingIndex),
         "Attempted to execute TileChangeTouched with invalid touched tiles");

      if ((TouchedTiles == null) || (TouchedTiles.Count &lt;= TouchingIndex))
         return;

      TouchedTile tt = TouchedTiles[TouchingIndex];
      layer[tt.x, tt.y] = tt.tileValue = NewTileValue;
   }

   /// &lt;summary&gt;
   /// Calculate the absolute position of a specified &lt;see cref="RelativePosition"/&gt; value with respect to this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="RelativePosition"&gt;Which position within this sprite should be retrieved.&lt;/param&gt;
   /// &lt;returns&gt;A point relative to the sprite's layer that represents the requested position in the sprite.&lt;/returns&gt;
   /// &lt;remarks&gt;This cannot be applied as a rule function because it returns a point object,
   /// which is not supported by the SGDK2 IDE as an output type.&lt;/remarks&gt;
   public virtual System.Drawing.Point GetRelativePosition(RelativePosition RelativePosition)
   {
      System.Drawing.Point rp = new System.Drawing.Point(PixelX, PixelY);

      switch (RelativePosition)
      {
         case RelativePosition.TopCenter:
            rp.X = (int)(PixelX + SolidWidth / 2);
            break;
         case RelativePosition.TopRight:
            rp.X = PixelX + SolidWidth - 1;
            break;
         case RelativePosition.LeftMiddle:
            rp.Y = PixelY + (int)(SolidHeight / 2);
            break;
         case RelativePosition.CenterMiddle:
            rp.X = PixelX + (int)(SolidWidth / 2);
            rp.Y = PixelY + (int)(SolidHeight / 2);
            break;
         case RelativePosition.RightMiddle:
            rp.X = PixelX + SolidWidth - 1;
            rp.Y = PixelY + (int)(SolidHeight / 2);
            break;
         case RelativePosition.BottomLeft:
            rp.Y = PixelY + SolidHeight - 1;
            break;
         case RelativePosition.BottomCenter:
            rp.X = PixelX + (int)(SolidWidth / 2);
            rp.Y = PixelY + SolidHeight - 1;
            break;
         case RelativePosition.BottomRight:
            rp.X = PixelX + SolidWidth - 1;
            rp.Y = PixelY + SolidHeight - 1;
            break;
      }
      return rp;
   }

   /// &lt;summary&gt;
   /// Determines if a tile at the sprite's current position is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Tile category against which the tile will be checked.&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;The sprite may be on multiple tiles at once. This parameter
   /// indicates which part of the sprite to look at, and gets the tile from the layer at
   /// the specified position.&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point in the sprite is on a tile in the specified category, false otherwise.&lt;/returns&gt;
   [Description("Examines the tile on the layer at the sprite's current position and determines if it is a member of the specified category. The RelativePosition parameter determines which part of the sprite to use when identifying a location on the layer. (TouchTiles is not necessary for this function.)")]
   public virtual bool IsOnTile(TileCategoryName Category, RelativePosition RelativePosition)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsOnTile on an inactive sprite");

      System.Drawing.Point rp = GetRelativePosition(RelativePosition);
      return layer.GetTile((int)(rp.X / layer.Tileset.TileWidth), (int)(rp.Y / layer.Tileset.TileHeight)).IsMember(Category);
   }
   #endregion

   #region Activation
   /// &lt;summary&gt;
   /// Deactivate this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Deactivated sprites are no longer be drawn and their rules are not processed.
   /// In debug mode, attempting to refer to inactive sprites from active rules (or otherwise
   /// attempting to execute functions on inactive sprites) will display errors. If the
   /// sprite was added as a dynamic sprite by &lt;see cref="TileAddSprite"/&gt;, deactivating it
   /// will cause &lt;see cref="LayerBase.ProcessSprites"/&gt; to remove the sprite from all
   /// categories so it cannot even be considered for re-activation.
   /// &lt;seealso cref="TileAddSprite"/&gt;&lt;seealso cref="TileActivateSprite"/&gt;&lt;/remarks&gt;
   [Description("Deactivate this sprite.  It will no longer be drawn, and in debug mode, will display errors if rules try to execute on it.")]
   public virtual void Deactivate()
   {
      isActive = false;
   }
   #endregion

   #region Pushing
   /// &lt;summary&gt;
   /// Alter the velocity of TargetSprite to plan to move out of the way of this sprite
   /// if TargetSprite is obstructing this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="TargetSprite"&gt;Sprite whose velocity may be affected.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was pushed, false otherwise.&lt;/returns&gt;
   [Description("Alter the velocity of TargetSprite to plan to move out of the way of this sprite.")]
   public virtual bool PushSprite(SpriteBase TargetSprite)
   {
      Debug.Assert(this.isActive, "Attempted to execute PushSprite on an inactive sprite");

      int x1 = ProposedPixelX;
      int w1 = SolidWidth;
      int x2 = TargetSprite.ProposedPixelX;
      int w2 = TargetSprite.SolidWidth;
      int y1 = ProposedPixelY;
      int h1 = SolidHeight;
      int y2 = TargetSprite.ProposedPixelY;
      int h2 = TargetSprite.SolidHeight;

      int pushright = x1 + w1 - x2;
      int pushleft = x2 + w2 - x1;
      if ((pushright &gt; 0) &amp;&amp; (pushleft &gt; 0))
      {
         int pushx;
         pushx = (pushright &lt; pushleft) ? pushright : -pushleft;
         int pushdown = y1 + h1 - y2;
         int pushup = y2 + h2 - y1;
         if ((pushup &gt; 0) &amp;&amp; (pushdown &gt; 0))
         {
            int pushy = (pushdown &lt; pushup) ? pushdown : -pushup;
            if (System.Math.Abs(pushx) &gt; System.Math.Abs(pushy))
            {
               if (!double.IsNaN(TargetSprite.LocalDY))
                  TargetSprite.LocalDY += pushy;
               TargetSprite.dy += pushy;
            }
            else
            {
               if (!double.IsNaN(TargetSprite.LocalDX))
                  TargetSprite.LocalDX += pushx;
               TargetSprite.dx += pushx;
            }
            return true;
         }
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Alter the velocity of this sprite to plan to move out of the way of sprites in Pushers
   /// if this sprite is obstructing sprites in Pushers.
   /// &lt;/summary&gt;
   /// &lt;param name="Pushers"&gt;Sprites that can push this sprite.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was pushed, false otherwise.&lt;/returns&gt;
   [Description("Alter the velocity of this sprite to plan to move out of the way of sprites in Pushers.")]
   public virtual bool ReactToPush(SpriteCollection Pushers)
   {
      if (!isActive)
         return false;
      bool result = false;
      for (int idx = 0; idx &lt; Pushers.Count; idx++)
      {
         SpriteBase TargetSprite = Pushers[idx];
         if ((TargetSprite == this) || (!TargetSprite.isActive))
            continue;
         if (TargetSprite.Processed)
            result |= TargetSprite.PushSprite(this);
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Alter the velocity of this sprite to plan to move out of the way of sprites in
   /// Pushers but if this sprite is planning to overlap a sprite in Pushers, only
   /// after those sprites have processed their rules (usually to react to this
   /// sprite's pushing first).
   /// &lt;/summary&gt;
   /// &lt;param name="Pushers"&gt;Sprites that can push back on this sprite.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was pushed, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;The process of making moving sprites push and avoid each other is
   /// relatively complex and not 100% reliable. If only one of the sprites is moving,
   /// it's recommended to use the simpler &lt;see cref="ReactToPush"/&gt; function on the
   /// moving sprite instead. This function is designed to be used on sprites that can
   /// both move and push other sprites, and the other sprites need to push back if
   /// they cannot move any farther.&lt;/remarks&gt;
   [Description("Alter the velocity of this sprite to plan to move out of the way of sprites in Pushers, but only after they have processed their rules where necessary.")]
   public virtual bool ReactToPushback(SpriteCollection Pushers)
   {
      if (!isActive)
         return false;

      bool result = false;
      for (int idx = 0; idx &lt; Pushers.Count; idx++)
      {
         SpriteBase TargetSprite = Pushers[idx];
         if (!TargetSprite.isActive || TargetSprite.Processed || TargetSprite == this)
            continue;
         if (TestCollisionRect(TargetSprite))
         {
            TargetSprite.ProcessRules();
            result |= TargetSprite.PushSprite(this);
         }
      }

      return result;
   }

   /// &lt;summary&gt;
   /// Determine if this sprite is planning to overlap the target sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="TargetSprite"&gt;Sprite against which planned overlap is checked.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite will overlap TargetSprite.&lt;/returns&gt;
   public virtual bool TestCollisionRect(SpriteBase TargetSprite)
   {
      Debug.Assert(this.isActive, "Attempted to execute TestCollision on an inactive sprite");

      int x1 = ProposedPixelX;
      int w1 = SolidWidth;
      int x2 = TargetSprite.ProposedPixelX;
      int w2 = TargetSprite.SolidWidth;
      int y1 = ProposedPixelY;
      int h1 = SolidHeight;
      int y2 = TargetSprite.ProposedPixelY;
      int h2 = TargetSprite.SolidHeight;

      int pushright = x1 + w1 - x2;
      int pushleft = x2 + w2 - x1;
      if ((pushright &gt; 0) &amp;&amp; (pushleft &gt; 0))
      {
         int pushdown = y1 + h1 - y2;
         int pushup = y2 + h2 - y1;
         if ((pushup &gt; 0) &amp;&amp; (pushdown &gt; 0))
            return true;
      }
      return false;
   }
   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="Player.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Defines a common interface by which a sprite can receive input from a player
/// or some object simulating a player.
/// &lt;/summary&gt;
public partial interface IPlayer
{
   /// &lt;summary&gt;
   /// Returns true when the player is pressing up, or false otherwise.
   /// &lt;/summary&gt;
   bool Up
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing left, or false otherwise.
   /// &lt;/summary&gt;
   bool Left
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing right, or false otherwise.
   /// &lt;/summary&gt;
   bool Right
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing down, or false otherwise.
   /// &lt;/summary&gt;
   bool Down
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 1, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 1" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button1
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 2, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 2" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button2
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 3, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 3" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button3
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 4, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 4" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button4
   {
      get;
   }
}

/// &lt;summary&gt;
/// Represents interactions between the game and a player via the keyboard
/// &lt;/summary&gt;
[Serializable()]
public partial class KeyboardPlayer : IPlayer
{
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing left.
   /// &lt;/summary&gt;
   public Key key_left;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing up.
   /// &lt;/summary&gt;
   public Key key_up;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing right.
   /// &lt;/summary&gt;
   public Key key_right;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing down.
   /// &lt;/summary&gt;
   public Key key_down;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 1.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 1" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button1;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 2.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 2" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button2;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 3.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 3" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button3;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 4.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 4" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button4;

   /// &lt;summary&gt;
   /// Constructs a new player given the key mappings it will use.
   /// &lt;/summary&gt;
   /// &lt;param name="up"&gt;Initial value for &lt;see cref="key_up"/&gt;&lt;/param&gt;
   /// &lt;param name="left"&gt;Initial value for &lt;see cref="key_left"/&gt;&lt;/param&gt;
   /// &lt;param name="right"&gt;Initial value for &lt;see cref="key_right"/&gt;&lt;/param&gt;
   /// &lt;param name="down"&gt;Initial value for &lt;see cref="key_down"/&gt;&lt;/param&gt;
   /// &lt;param name="button1"&gt;Initial value for &lt;see cref="key_button1"/&gt;&lt;/param&gt;
   /// &lt;param name="button2"&gt;Initial value for &lt;see cref="key_button2"/&gt;&lt;/param&gt;
   /// &lt;param name="button3"&gt;Initial value for &lt;see cref="key_button3"/&gt;&lt;/param&gt;
   /// &lt;param name="button4"&gt;Initial value for &lt;see cref="key_button4"/&gt;&lt;/param&gt;
   private void InitializeKeys(Key up, Key left, Key right, Key down,
      Key button1, Key button2, Key button3, Key button4)
   {
      key_up = up;
      key_left = left;
      key_right = right;
      key_down = down;
      key_button1 = button1;
      key_button2 = button2;
      key_button3 = button3;
      key_button4 = button4;
   }

   /// &lt;summary&gt;
   /// Constructs a new player based on one of 4 possible sets of default key mappings
   /// &lt;/summary&gt;
   /// &lt;param name="defaultSet"&gt;Number 0 through 3 indicating which set of defaults to use.
   /// Default set number 0 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;Up Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Left Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Right Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Down Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Right Ctrl&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Space&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Return&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Right Shift&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// Default set number 1 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;W&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;A&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;D&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;S&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Left Shift&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Left Ctrl&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Q&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;E&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// Default set number 2 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Up/8&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Left/4&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Right/6&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Down/2&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad 5&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad 0&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Enter&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad 7&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// Default set number 3 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;I&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;J&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;L&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;K&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;U&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;O&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;M&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;,&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// &lt;/param&gt;
   public KeyboardPlayer(int defaultSet)
   {
      switch(defaultSet)
      {
         case 0:
            InitializeKeys(
               Key.Up,           // Up
               Key.Left,         // Left
               Key.Right,        // Right
               Key.Down,         // Down
               Key.RControl,     // Button 1
               Key.Space,        // Button 2
               Key.Enter,        // Button 3
               Key.RShift);      // Button 4
            break;
         case 1:
            InitializeKeys(
               Key.W,            // Up
               Key.A,            // Left
               Key.D,            // Right
               Key.S,            // Down
               Key.LShift,       // Button 1
               Key.LControl,     // Button 2
               Key.Q,            // Button 3
               Key.E);           // Button 4
            break;
         case 2:
            InitializeKeys(
               Key.NumPad8,      // Up
               Key.NumPad4,      // Right
               Key.NumPad6,      // Left
               Key.NumPad2,      // Down
               Key.NumPad5,      // Button 1
               Key.NumPad0,      // Button 2
               Key.NumPadEnter,  // Button 3
               Key.NumPad7);     // Button 4
            break;
         default:
            InitializeKeys(
               Key.I,            // Up
               Key.J,            // Right
               Key.L,            // Left
               Key.K,            // Down
               Key.U,            // Button 1
               Key.O,            // Button 2
               Key.M,            // Button 3
               Key.Comma);       // Button 4
            break;
      }
   }

   #region IPlayer Members

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Up"/&gt;.
   /// &lt;/summary&gt;
   public bool Up
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_up];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Left"/&gt;.
   /// &lt;/summary&gt;
   public bool Left
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_left];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Right"/&gt;.
   /// &lt;/summary&gt;
   public bool Right
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_right];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Down"/&gt;.
   /// &lt;/summary&gt;
   public bool Down
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_down];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button1"/&gt;.
   /// &lt;/summary&gt;
   public bool Button1
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button1];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button2"/&gt;.
   /// &lt;/summary&gt;
   public bool Button2
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button2];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button3"/&gt;.
   /// &lt;/summary&gt;
   public bool Button3
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button3];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button4"/&gt;.
   /// &lt;/summary&gt;
   public bool Button4
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button4];
      }
   }

   #endregion
}

/// &lt;summary&gt;
/// Represents interactions between the game and a player via a joystick/gamepad
/// &lt;/summary&gt;
[Serializable()]
public partial class ControllerPlayer : IPlayer
{
   public int deviceNumber;
   /// &lt;summary&gt;
   /// Array of 4 integers mapping controller button numbers to player button inputs.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The array element at index 0 contains index of the button on the controller
   /// that is mapped to player button number 1. Element 1 is the index for button 2 and
   /// so forth.&lt;/remarks&gt;
   public byte[] buttonMap;

   /// &lt;summary&gt;
   /// Constructs a player object that links input from the specified game controller device
   /// to game input.
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNumber"&gt;Device number as defined in user's Control Panel&lt;/param&gt;
   public ControllerPlayer(int deviceNumber)
   {
      this.deviceNumber = deviceNumber;
      buttonMap = new byte[4] {0, 1, 2, 3};
   }

   public Joystick MyController
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber);
      }
   }
   #region IPlayer Members

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Up"/&gt;.
   /// &lt;/summary&gt;
   public bool Up
   {
      get
      {
         return MyController.YPosition &lt; (MyController.MinimumY * 3 + MyController.MaximumY) / 4;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Left"/&gt;.
   /// &lt;/summary&gt;
   public bool Left
   {
      get
      {
         return MyController.XPosition &lt; (MyController.MinimumX * 3 + MyController.MaximumX) / 4;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Right"/&gt;.
   /// &lt;/summary&gt;
   public bool Right
   {
      get
      {
         return MyController.XPosition &gt; (MyController.MinimumX + MyController.MaximumX * 3) / 4;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Down"/&gt;.
   /// &lt;/summary&gt;
   public bool Down
   {
      get
      {
         return MyController.YPosition &gt; (MyController.MinimumY + MyController.MaximumY * 3) / 4;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button1"/&gt;.
   /// &lt;/summary&gt;
   public bool Button1
   {
      get
      {
         return MyController[buttonMap[0]];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button2"/&gt;.
   /// &lt;/summary&gt;
   public bool Button2
   {
      get
      {
         return MyController[buttonMap[1]];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button3"/&gt;.
   /// &lt;/summary&gt;
   public bool Button3
   {
      get
      {
         return MyController[buttonMap[2]];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button4"/&gt;.
   /// &lt;/summary&gt;
   public bool Button4
   {
      get
      {
         return MyController[buttonMap[3]];
      }
   }

   #endregion
}
</Text>
  </SourceCode>
  <SourceCode Name="Display.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */

using System;
using System.Collections;
using OpenTK;
using OpenTK.Graphics;
using OpenTK.Graphics.OpenGL;

/// &lt;summary&gt;
/// Specifies a size and color depth for a display.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Color depth only applies when the display is in full screen mode.&lt;/remarks&gt;
public enum GameDisplayMode
{
   /// &lt;summary&gt;
   /// 320x240-pixel display with 16-bit color
   /// &lt;/summary&gt;
   m320x240x16,
   /// &lt;summary&gt;
   /// 640x480-pixel display with 16-bit color
   /// &lt;/summary&gt;
   m640x480x16,
   /// &lt;summary&gt;
   /// 800x600-pixel display with 16-bit color
   /// &lt;/summary&gt;
   m800x600x16,
   /// &lt;summary&gt;
   /// 1024x768-pixel display with 16-bit color
   /// &lt;/summary&gt;
   m1024x768x16,
   /// &lt;summary&gt;
   /// 1280x1024-pixel display with 16-bit color
   /// &lt;/summary&gt;
   m1280x1024x16,
   /// &lt;summary&gt;
   /// 320x240-pixel display with 24-bit color
   /// &lt;/summary&gt;
   m320x240x24,
   /// &lt;summary&gt;
   /// 640x480-pixel display with 24-bit color
   /// &lt;/summary&gt;
   m640x480x24,
   /// &lt;summary&gt;
   /// 800x600-pixel display with 24-bit color
   /// &lt;/summary&gt;
   m800x600x24,
   /// &lt;summary&gt;
   /// 1024x768-pixel display with 24-bit color
   /// &lt;/summary&gt;
   m1024x768x24,
   /// &lt;summary&gt;
   /// 1280x1024-pixel display with 24-bit color
   /// &lt;/summary&gt;
   m1280x1024x24
}

/// &lt;summary&gt;
/// Manages the display device on which real-time game graphics are drawn
/// &lt;/summary&gt;
[Serializable()]
public partial class Display : GLControl, IDisposable, System.Runtime.Serialization.ISerializable
{
   #region Embedded Classes
   /// &lt;summary&gt;
   /// Object used to refer to a texture (graphic sheet) managed by a particular &lt;see cref="Display" /&gt;.
   /// &lt;/summary&gt;
   public partial class TextureRef : IDisposable
   {
      private string m_Name;
      private int m_Texture = 0;
      private Display m_Display;
      private int m_Width = 0;
      private int m_Height = 0;

      public TextureRef(Display Disp, string Name)
      {
         m_Display = Disp;
         m_Name = Name;
      }

      /// &lt;summary&gt;
      /// Name of a graphic sheet
      /// &lt;/summary&gt;
      public string Name
      {
         get
         {
            return m_Name;
         }
      }

      /// &lt;summary&gt;
      /// Returns OpenGL handle to the texture referenced by this object
      /// &lt;/summary&gt;
      public int Texture
      {
         get
         {
            if (m_Texture == 0)
            {
               m_Texture = m_Display.GetTexture(m_Name);
            }
            return m_Texture;
         }
      }

      public int Width
      {
         get
         {
            if (m_Width &lt;= 0)
               m_Width = m_Display.m_TextureSizes[m_Name].Width;
            return m_Width;
         }
      }

      public int Height
      {
         get
         {
            if (m_Height &lt;= 0)
               m_Height = m_Display.m_TextureSizes[m_Name].Height;
            return m_Height;
         }
      }

      #region IDisposable Members
      /// &lt;summary&gt;
      /// Releases all resources for the associated texture.
      /// &lt;/summary&gt;
      public void Dispose()
      {
         if (m_Texture != 0)
         {
            if (m_Display.Context != null)
            {
               if (!m_Display.Context.IsCurrent)
                  m_Display.MakeCurrent();
               GL.DeleteTextures(1, ref m_Texture);
            }
            m_Texture = 0;
         }
      }
      #endregion
   }

   private enum DisplayOperation
   {
      None = 0,
      DrawFrames,
      DrawLines,
      DrawPoints
   }
   #endregion

   #region Fields
   private System.Collections.Generic.Dictionary&lt;string, WeakReference&gt; m_TextureRefs = null;
   private System.Collections.Generic.Dictionary&lt;string, System.Drawing.Size&gt; m_TextureSizes = null;
   private GameDisplayMode m_GameDisplayMode;
   private DisplayOperation m_currentOp;
   private TextureRef m_currentTexture = null;
   private bool scaleNativeSize = false;
   private const TextureTarget texTarget = TextureTarget.Texture2D;
   private const EnableCap texCap = EnableCap.Texture2D;
   private static TextureRef m_DefaultFont = null;
   private static byte[] shadedStipple = new byte[] {
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
      0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA};
   private System.Drawing.Point endPoint = System.Drawing.Point.Empty;
   /// &lt;summary&gt;
   /// Determines if requirements have already been checked or need to be
   /// (re-)checked during the next call to &lt;see cref="DrawFrame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;value&gt;If true, requirements have already been checked.
   /// If false, requirements will be checked next time DrawFrame executes.&lt;/value&gt;
   public bool requirementsChecked = false;
   #endregion

   #region Initialization and clean-up
   public Display()
      : this(GameDisplayMode.m640x480x24, true)
   {
   }

   public Display(GameDisplayMode mode, bool windowed)
      : base(CreateGraphicsMode(mode))
   {
      m_GameDisplayMode = mode;
   }

   protected override void Dispose(bool disposing)
   {
      if (disposing)
      {
         OpenTK.DisplayDevice.Default.RestoreResolution();
         DisposeAllTextures();
      }
      base.Dispose(disposing);
   }
   #endregion

   #region Overrides
   protected override bool IsInputKey(System.Windows.Forms.Keys keyData)
   {
      return true;
   }
   protected override void OnResize(EventArgs e)
   {
      base.OnResize(e);
      if (GraphicsContext.CurrentContext == null)
         return;
      GL.Viewport(0, 0, ClientSize.Width, ClientSize.Height);
      GL.MatrixMode(MatrixMode.Projection);
      GL.LoadIdentity();
      if (scaleNativeSize)
      {
         System.Drawing.Size nativeSize = GetScreenSize(m_GameDisplayMode);
         GL.Ortho(0, nativeSize.Width, nativeSize.Height, 0, -1, 1);
      }
      else
      {
         GL.Ortho(0, ClientSize.Width, ClientSize.Height, 0, -1, 1);
      }
   }
   #endregion

   #region Private members
   static int NextPow2(int value)
   {
      int result;
      for (result = 1; result &lt; value; result &lt;&lt;= 1)
         ;
      return result;
   }

   private int GetTexture(string Name)
   {
      int texture;
      GL.GenTextures(1, out texture);
      GL.BindTexture(texTarget, texture);
      GL.TexParameter(texTarget, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
      GL.TexParameter(texTarget, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
      GL.TexParameter(texTarget, TextureParameterName.TextureWrapS, (int)TextureWrapMode.Clamp);
      GL.TexParameter(texTarget, TextureParameterName.TextureWrapT, (int)TextureWrapMode.Clamp);

      System.Drawing.Bitmap bmpTexture = (System.Drawing.Bitmap)Project.Resources.GetObject(Name);

      int useWidth = NextPow2(bmpTexture.Width);
      int useHeight = NextPow2(bmpTexture.Height);

      bool useSubTexture = (useWidth != bmpTexture.Width) || (useHeight != bmpTexture.Height);

      int texSize;
      GL.GetInteger(GetPName.MaxTextureSize, out texSize);
      if ((texSize &lt; useWidth) ||
          (texSize &lt; useHeight))
         throw new System.ApplicationException("Texture " + Name + " is size " + useWidth + "x" + useHeight +
            " (after rounding up to power of 2), but the current OpenGL video drivers only support textures up to " + texSize.ToString());

      if (m_TextureSizes == null)
         m_TextureSizes = new System.Collections.Generic.Dictionary&lt;string, System.Drawing.Size&gt;();
      if (!m_TextureSizes.ContainsKey(Name))
         m_TextureSizes[Name] = new System.Drawing.Size(useWidth, useHeight);

      System.Drawing.Imaging.BitmapData bits = bmpTexture.LockBits(new System.Drawing.Rectangle(0, 0, bmpTexture.Width, bmpTexture.Height),
         System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
      try
      {
         if (useSubTexture)
         {
            GL.TexImage2D(texTarget, 0, PixelInternalFormat.Rgba8, useWidth, useHeight, 0, PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);
            GL.TexSubImage2D(texTarget, 0, 0, 0, bmpTexture.Width, bmpTexture.Height, PixelFormat.Bgra, PixelType.UnsignedByte, bits.Scan0);
         }
         else
         {
            GL.TexImage2D(texTarget, 0, PixelInternalFormat.Rgba8, useWidth, useHeight, 0, PixelFormat.Bgra, PixelType.UnsignedByte, bits.Scan0);
         }
      }
      finally
      {
         bmpTexture.UnlockBits(bits);
      }
      return texture;
   }
   #endregion

   #region Public members
   /// &lt;summary&gt;
   /// Retrieve a reference to a hardware-supported graphic sheet ("texture") given its name
   /// &lt;/summary&gt;
   /// &lt;param name="Name"&gt;The name of a graphic sheet defined by the game&lt;/param&gt;
   /// &lt;returns&gt;Object that manages graphics on the hardware for this graphic sheet&lt;/returns&gt;
   public TextureRef GetTextureRef(string Name)
   {
      if (m_TextureRefs == null)
         m_TextureRefs = new System.Collections.Generic.Dictionary&lt;string, WeakReference&gt;();

      if (m_TextureRefs.ContainsKey(Name))
      {
         WeakReference wr = m_TextureRefs[Name];
         if (wr.IsAlive)
            return (TextureRef)wr.Target;
      }

      TextureRef tex = new TextureRef(this, Name);
      m_TextureRefs[Name] = new WeakReference(tex);
      return tex;
   }

   /// &lt;summary&gt;
   /// Release resources used by all hardware copies of graphic sheets
   /// &lt;/summary&gt;
   public void DisposeAllTextures()
   {
      if (m_TextureRefs != null)
      {
         foreach (System.Collections.Generic.KeyValuePair&lt;string, WeakReference&gt; de in m_TextureRefs)
         {
            if (de.Value.IsAlive)
               ((TextureRef)(de.Value).Target).Dispose();
         }
      }
   }

   /// &lt;summary&gt;
   /// Get the size of a display based on the specified mode
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;Game display mode used for the display&lt;/param&gt;
   /// &lt;returns&gt;Width and height in pixels&lt;/returns&gt;
   public static System.Drawing.Size GetScreenSize(GameDisplayMode mode)
   {
      switch (mode)
      {
         case GameDisplayMode.m320x240x16:
         case GameDisplayMode.m320x240x24:
            return new System.Drawing.Size(320, 240);
         case GameDisplayMode.m640x480x16:
         case GameDisplayMode.m640x480x24:
            return new System.Drawing.Size(640, 480);
         case GameDisplayMode.m800x600x16:
         case GameDisplayMode.m800x600x24:
            return new System.Drawing.Size(800, 600);
         case GameDisplayMode.m1024x768x16:
         case GameDisplayMode.m1024x768x24:
            return new System.Drawing.Size(1024, 768);
         case GameDisplayMode.m1280x1024x16:
         case GameDisplayMode.m1280x1024x24:
            return new System.Drawing.Size(1280, 1024);
      }
      return new System.Drawing.Size(0, 0);
   }

   /// &lt;summary&gt;
   /// Checks that the current video drivers support features required by the framework code,
   /// and didplays a message if not.
   /// &lt;/summary&gt;
   public void CheckRequirements()
   {
      if (!requirementsChecked)
      {
         requirementsChecked = true;
         GL.Finish();
         string[] versionParts = GL.GetString(StringName.Version).Split(new char[] { '.' }, 3);
         int majorVer = int.Parse(versionParts[0]);
         int minorVer = int.Parse(versionParts[1]);
         if ((majorVer &lt; 1) || ((majorVer == 1) &amp;&amp; (minorVer &lt; 2)))
         {
            string errString = "OpenGL version 1.2 is required";
            try
            {
               errString += "; your version is: " + GL.GetString(StringName.Version);
            }
            catch
            {
            }
            if (System.Windows.Forms.DialogResult.Cancel == System.Windows.Forms.MessageBox.Show(this, errString + "\r\nTry updating your video drivers.", "Requirement Check Warning", System.Windows.Forms.MessageBoxButtons.OKCancel, System.Windows.Forms.MessageBoxIcon.Exclamation, System.Windows.Forms.MessageBoxDefaultButton.Button2))
               throw new ApplicationException(errString);
         }
      }
   }

   /// &lt;summary&gt;
   /// Return the bit depth of the specified mode
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;GameDisplayMode value whose depth will be returned&lt;/param&gt;
   /// &lt;returns&gt;Integer value of 16 or 24&lt;/returns&gt;
   public static int GetModeDepth(GameDisplayMode mode)
   {
      switch (mode)
      {
         case GameDisplayMode.m320x240x16:
         case GameDisplayMode.m640x480x16:
         case GameDisplayMode.m800x600x16:
         case GameDisplayMode.m1024x768x16:
         case GameDisplayMode.m1280x1024x16:
            return 16;
         default:
            return 24;
      }
   }

   /// &lt;summary&gt;
   /// Returns a GraphicsMode structure corresponding to the requested GameDisplayMode
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;Game requested display mode&lt;/param&gt;
   public static GraphicsMode CreateGraphicsMode(GameDisplayMode mode)
   {
      return new GraphicsMode(new ColorFormat(GetModeDepth(mode)));
   }

   /// &lt;summary&gt;
   /// Restore the resolution of the display after a call to &lt;see cref="SwitchToResolution" /&gt;
   /// &lt;/summary&gt;
   public void SwitchToResolution()
   {
      System.Drawing.Size size = GetScreenSize(m_GameDisplayMode);
      int depth = GetModeDepth(m_GameDisplayMode);
      OpenTK.DisplayResolution best = null;
      foreach (OpenTK.DisplayResolution dr in OpenTK.DisplayDevice.Default.AvailableResolutions)
      {
         if ((dr.Width == size.Width) &amp;&amp; (dr.Height == size.Height))
         {
            if ((dr.BitsPerPixel == 32 ? 24 : 32) == depth)
            {
               if ((best == null) || (best.RefreshRate &lt; dr.RefreshRate))
                  best = dr;
            }
            else
            {
               if ((best == null) || (best.BitsPerPixel != depth) &amp;&amp;
                   (best.BitsPerPixel &lt; dr.BitsPerPixel))
                  best = dr;
            }
         }
      }
      if (best != null)
      {
         OpenTK.DisplayDevice.Default.ChangeResolution(best);
         return;
      }
      throw new ApplicationException("Cannot match display mode " + m_GameDisplayMode.ToString());
   }

   /// &lt;summary&gt;
   /// Restores the original (desktop) resolution, for example after switching to full
   /// screen mode in another resolution.
   /// &lt;/summary&gt;
   public static void RestoreResolution()
   {
      OpenTK.DisplayDevice.Default.RestoreResolution();
   }

   /// &lt;summary&gt;
   /// Gets or sets the size/resolution and color depth of the display
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If the display is windowed, this only affects the size. The color depth
   /// will match that of the user's desktop. In full screen mode this affects the
   /// resolution and color depth of the display.&lt;/remarks&gt;
   public GameDisplayMode GameDisplayMode
   {
      get
      {
         return m_GameDisplayMode;
      }
      set
      {
         m_GameDisplayMode = value;
         if (this.Context != null) // Forces context to be created
         {
            GL.MatrixMode(MatrixMode.Projection);
            GL.LoadIdentity();
            System.Drawing.Size naturalSize = GetScreenSize(value);
            GL.Ortho(0, naturalSize.Width, naturalSize.Height, 0, -1, 1);
         }
      }
   }

   /// &lt;summary&gt;
   /// Draw a rectangle from a texture on the display
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Texture from which graphics are copied&lt;/param&gt;
   /// &lt;param name="sourceRect"&gt;Specifies the source area of the copy&lt;/param&gt;
   /// &lt;param name="corners"&gt;Specifies the corners (counter-clockwise) of the output quadrilateral&lt;/param&gt;
   /// &lt;param name="offsetX"&gt;Specifies the horizontal (rightward) offset of the corners&lt;/param&gt;
   /// &lt;param name="offsetY"&gt;Specifies the vertical (downward) offset of the corners&lt;/param&gt;
   public void DrawFrame(TextureRef texture, System.Drawing.Rectangle sourceRect, System.Drawing.PointF[] corners, int offsetX, int offsetY)
   {
      if ((m_currentOp != DisplayOperation.DrawFrames) ||
          (m_currentTexture != texture))
      {
         if (m_currentOp != DisplayOperation.None)
            GL.End();
         CheckError();

         CheckRequirements();
         GL.TexEnv(TextureEnvTarget.TextureEnv, TextureEnvParameter.TextureEnvMode, (float)TextureEnvMode.Modulate);
         GL.Enable(EnableCap.Blend);
         GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
         GL.Disable(EnableCap.PolygonSmooth);
         GL.Enable(texCap);
         GL.Disable(EnableCap.DepthTest);
         GL.Disable(EnableCap.Lighting);
         GL.Disable(EnableCap.Dither);

         CheckError();
         GL.BindTexture(texTarget, texture.Texture);
         GL.Begin(BeginMode.Quads);
         m_currentOp = DisplayOperation.DrawFrames;
         m_currentTexture = texture;
      }
      GL.TexCoord2((float)sourceRect.Left / texture.Width, (float)sourceRect.Top / texture.Height);
      GL.Vertex2(corners[0].X + offsetX, corners[0].Y + offsetY);
      GL.TexCoord2((float)sourceRect.Left / texture.Width, (float)(sourceRect.Top + sourceRect.Height) / texture.Height);
      GL.Vertex2(corners[1].X + offsetX, corners[1].Y + offsetY);
      GL.TexCoord2((float)(sourceRect.Left + sourceRect.Width) / texture.Width, (float)(sourceRect.Top + sourceRect.Height) / texture.Height);
      GL.Vertex2(corners[2].X + offsetX, corners[2].Y + offsetY);
      GL.TexCoord2((float)(sourceRect.Left + sourceRect.Width) / texture.Width, (float)sourceRect.Top / texture.Height);
      GL.Vertex2(corners[3].X + offsetX, corners[3].Y + offsetY);
   }

   /// &lt;summary&gt;
   /// Finishes any pending drawing operation on the display.
   /// &lt;/summary&gt;
   public void Flush()
   {
      if (m_currentOp != DisplayOperation.None)
      {
         GL.End();
         m_currentOp = DisplayOperation.None;
      }
      CheckError();
   }

   /// &lt;summary&gt;
   /// Draw series of connected lines connecting points ending in an arrow head.
   /// &lt;/summary&gt;
   /// &lt;param name="points"&gt;Points between which lines are drawn&lt;/param&gt;
   /// &lt;param name="width"&gt;Width of the lines&lt;/param&gt;
   /// &lt;param name="pattern"&gt;Bit pattern defining the line's dash style&lt;/param&gt;
   /// &lt;param name="antiAlias"&gt;Determines whether or not the line should be anti-aliased&lt;/param&gt;
   /// &lt;param name="arrowSize"&gt;The length of the arrow head in pixels&lt;/param&gt;
   /// &lt;param name="arrowShorten"&gt;The number of pixels (beyond arrowSize) by which the last line is shortened, and the arrowhead pulled back.&lt;/param&gt;
   public void DrawArrow(System.Drawing.Point[] points, int width, short pattern, bool antiAlias, int arrowSize, int arrowShorten)
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      GL.Disable(texCap);
      if (antiAlias)
      {
         GL.Enable(EnableCap.LineSmooth);
         GL.Hint(HintTarget.LineSmoothHint, HintMode.Nicest);
         GL.Enable(EnableCap.PolygonSmooth);
         GL.Hint(HintTarget.PolygonSmoothHint, HintMode.Nicest);
      }
      else
      {
         GL.Disable(EnableCap.LineSmooth);
         GL.Disable(EnableCap.PolygonSmooth);
      }
      GL.LineWidth(width);

      if ((pattern != unchecked((short)(0xffff))) &amp;&amp; (pattern != 0))
      {
         GL.Enable(EnableCap.LineStipple);
         GL.LineStipple(1, pattern);
      }
      else
      {
         GL.Disable(EnableCap.LineStipple);
      }
      GL.Begin(BeginMode.LineStrip);
      for (int i = 0; i &lt; points.Length - 1; i++)
         GL.Vertex2(points[i].X, points[i].Y);
      int x = points[points.Length - 1].X;
      int y = points[points.Length - 1].Y;
      int dx = x - points[points.Length - 2].X;
      int dy = y - points[points.Length - 2].Y;
      float len = (float)Math.Sqrt(dx * dx + dy * dy);
      if (len &gt; 1)
      {
         float ndx = dx * (arrowSize + arrowShorten) / len;
         float ndy = dy * (arrowSize + arrowShorten) / len;
         float x1 = x - ndx;
         float y1 = y - ndy;
         GL.Vertex2(x1, y1);
         ndx = dx * arrowSize / len;
         ndy = dy * arrowSize / len;
         GL.End();

         m_currentOp = DisplayOperation.None;

         GL.Enable(EnableCap.PolygonSmooth);
         GL.Hint(HintTarget.PolygonSmoothHint, HintMode.Nicest);
         GL.Begin(BeginMode.Triangles);
         GL.Vertex2(x1 - ndy / 2, y1 + ndx / 2);
         GL.Vertex2(x1 + ndx, y1 + ndy);
         GL.Vertex2(x1 + ndy / 2, y1 - ndx / 2);
         GL.End();
      }
      else
      {
         GL.Vertex2(points[points.Length - 1].X, points[points.Length - 1].Y);
         GL.End();
      }
      m_currentOp = DisplayOperation.None;
   }

   /// &lt;summary&gt;
   /// Begins drawing a series of connected lines.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the lines.&lt;/param&gt;
   /// &lt;param name="pattern"&gt;Bit pattern determining how/if the line is dashed.&lt;/param&gt;
   /// &lt;param name="antiAlias"&gt;Determines if the lines are anti-aliased.&lt;/param&gt;
   public void BeginLine(float width, short pattern, bool antiAlias)
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      GL.Disable(texCap);
      if (antiAlias)
      {
         GL.Enable(EnableCap.LineSmooth);
         GL.Hint(HintTarget.LineSmoothHint, HintMode.Nicest);
      }
      else
      {
         GL.Disable(EnableCap.LineSmooth);
      }
      GL.LineWidth(width);

      if ((pattern != unchecked((short)(0xffff))) &amp;&amp; (pattern != 0))
      {
         GL.Enable(EnableCap.LineStipple);
         GL.LineStipple(1, pattern);
      }
      else
      {
         GL.Disable(EnableCap.LineStipple);
      }
      GL.Begin(BeginMode.LineStrip);
      m_currentOp = DisplayOperation.DrawLines;
   }

   /// &lt;summary&gt;
   /// Continues a line started with &lt;see cref="BeginLine"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal coordinate within the display&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical coordinate within the display&lt;/param&gt;
   /// &lt;remarks&gt;First first call to LineTo sets the beginning point
   /// of the line. Coordinates are relative to the top left corner of
   /// the display, not the layer or map.&lt;/remarks&gt;
   public void LineTo(int x, int y)
   {
      if (m_currentOp != DisplayOperation.DrawLines)
      {
         if (m_currentOp != DisplayOperation.None)
            GL.End();
         BeginLine(1, 0, false);
      }
      GL.Vertex2(x, y);
      endPoint = new System.Drawing.Point(x, y);
   }

   /// &lt;summary&gt;
   /// End a line begun with &lt;see cref="BeginLine"/&gt; with an arrowhead.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal coordinate of the tip of the arrow head&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical coordinate of the tip of the arrowhead&lt;/param&gt;
   /// &lt;param name="ArrowSize"&gt;Length of the arrowhead&lt;/param&gt;
   public void ArrowTo(int x, int y, int ArrowSize)
   {
      if (m_currentOp != DisplayOperation.DrawLines)
      {
         if (m_currentOp != DisplayOperation.None)
            GL.End();
         BeginLine(1, 0, true);
         GL.Vertex2(endPoint.X, endPoint.Y);
      }
      int dx = (x - endPoint.X);
      int dy = (y - endPoint.Y);
      float len = (float)Math.Sqrt(dx * dx + dy * dy);
      if (len &gt; 1)
      {
         float ndx = dx * ArrowSize / len;
         float ndy = dy * ArrowSize / len;
         float x1 = x - ndx;
         float y1 = y - ndy;
         GL.Vertex2(x1, y1);
         GL.End();

         m_currentOp = DisplayOperation.None;

         GL.Enable(EnableCap.PolygonSmooth);
         GL.Hint(HintTarget.PolygonSmoothHint, HintMode.Nicest);
         GL.Begin(BeginMode.Triangles);
         GL.Vertex2(x1 - ndy / 2, y1 + ndx / 2);
         GL.Vertex2(x1 + ndx, y1 + ndy);
         GL.Vertex2(x1 + ndy / 2, y1 - ndx / 2);
         GL.End();
      }
      else
         LineTo(x, y);
   }

   /// &lt;summary&gt;
   /// Draw a rectangular outline on the display.
   /// &lt;/summary&gt;
   /// &lt;param name="rect"&gt;Rectangle relative to the top left corner of the display.&lt;/param&gt;
   /// &lt;param name="pattern"&gt;Dash pattern applied to the lines forming the outline.&lt;/param&gt;
   public void DrawRectangle(System.Drawing.Rectangle rect, short pattern)
   {
      if (m_currentOp != DisplayOperation.None)
      {
         GL.End();
         m_currentOp = DisplayOperation.None;
      }
      if ((pattern == 0) || (pattern == unchecked((short)(0xffff))))
         GL.Disable(EnableCap.LineStipple);
      else
      {
         GL.Enable(EnableCap.LineStipple);
         GL.LineStipple(1, pattern);
      }
      System.Drawing.RectangleF rectf = rect;
      rectf.Offset(0.5f, 0.5f); // Align to pixel grid
      GL.Disable(EnableCap.LineSmooth);
      GL.LineWidth(1);
      GL.Disable(texCap);
      GL.Begin(BeginMode.LineLoop);
      GL.Vertex2(rectf.X, rectf.Y);
      GL.Vertex2(rectf.X, rectf.Y + rectf.Height - 1);
      GL.Vertex2(rectf.X + rectf.Width - 1, rectf.Y + rectf.Height - 1);
      GL.Vertex2(rectf.X + rectf.Width - 1, rectf.Y);
      GL.End();
   }

   /// &lt;summary&gt;
   /// Fills a rectangular area with a solid color
   /// &lt;/summary&gt;
   /// &lt;param name="rect"&gt;Rectangular area to fill.&lt;/param&gt;
   /// &lt;remarks&gt;
   /// &lt;see cref="SetColor"/&gt; determines the color with which to fill
   /// the rectangle, and may be semi-translucent.
   /// &lt;seealso cref="SetColor"/&gt;&lt;/remarks&gt;
   public void FillRectangle(System.Drawing.Rectangle rect)
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      m_currentOp = DisplayOperation.None;
      GL.Disable(texCap);
      GL.Begin(BeginMode.Quads);
      GL.Vertex2(rect.X, rect.Y);
      GL.Vertex2(rect.X, rect.Y + rect.Height);
      GL.Vertex2(rect.X + rect.Width, rect.Y + rect.Height);
      GL.Vertex2(rect.X + rect.Width, rect.Y);
      GL.End();
   }

   /// &lt;summary&gt;
   /// Specifies the size of points drawn with &lt;see cref="DrawPoint"/&gt;.
   /// &lt;/summary&gt;
   public int PointSize
   {
      set
      {
         if (m_currentOp != DisplayOperation.None)
            GL.End();
         m_currentOp = DisplayOperation.None;
         GL.PointSize(value);
      }
   }

   /// &lt;summary&gt;
   /// Draw a point in the display
   /// &lt;/summary&gt;
   /// &lt;param name="location"&gt;Coordinate relative to the top left corner of the display.&lt;/param&gt;
   public void DrawPoint(System.Drawing.Point location)
   {
      if (m_currentOp != DisplayOperation.DrawPoints)
      {
         if (m_currentOp != DisplayOperation.None)
            GL.End();
         GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
         GL.Enable(EnableCap.PointSmooth);
         GL.Disable(texCap);
         GL.Begin(BeginMode.Points);
         m_currentOp = DisplayOperation.DrawPoints;
      }
      GL.Vertex2(location.X, location.Y);
   }

   /// &lt;summary&gt;
   /// Set the current color for drawing operations.
   /// &lt;/summary&gt;
   /// &lt;param name="color"&gt;Color to select.&lt;/param&gt;
   public void SetColor(System.Drawing.Color color)
   {
      GL.Color4(color.R, color.G, color.B, color.A);
   }

   /// &lt;summary&gt;
   /// Set the current color for drawing operations.
   /// &lt;/summary&gt;
   /// &lt;param name="color"&gt;Color as an integer with bytes in ARGB order.&lt;/param&gt;
   public void SetColor(int color)
   {
      System.Drawing.Color c = System.Drawing.Color.FromArgb(color);
      SetColor(c);
   }

   /// &lt;summary&gt;
   /// Draw a shaded rectangular frame.
   /// &lt;/summary&gt;
   /// &lt;param name="inner"&gt;Inner, empty portion of the rectangle&lt;/param&gt;
   /// &lt;param name="thickness"&gt;Thickness of the frame in pixels.&lt;/param&gt;
   /// &lt;param name="color1"&gt;Background color&lt;/param&gt;
   /// &lt;param name="color2"&gt;Foreground dither color&lt;/param&gt;
   public void DrawShadedRectFrame(System.Drawing.Rectangle inner, int thickness, System.Drawing.Color color1, System.Drawing.Color color2)
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      m_currentOp = DisplayOperation.None;
      GL.Disable(texCap);
      GL.Disable(EnableCap.PolygonStipple);
      SetColor(color1);
      GL.Begin(BeginMode.QuadStrip);
      SendRectFramePoints(inner, thickness);
      GL.End();
      GL.Enable(EnableCap.PolygonStipple);
      GL.PolygonStipple(shadedStipple);
      SetColor(color2);
      GL.Begin(BeginMode.QuadStrip);
      SendRectFramePoints(inner, thickness);
      GL.End();
      GL.Disable(EnableCap.PolygonStipple);
   }

   private void SendRectFramePoints(System.Drawing.Rectangle inner, int thickness)
   {
      GL.Vertex2(inner.X - thickness, inner.Y - thickness);
      GL.Vertex2(inner.X - 1, inner.Y - 1);
      GL.Vertex2(inner.X - thickness, inner.Y + inner.Height + thickness - 1);
      GL.Vertex2(inner.X - 1, inner.Y + inner.Height);
      GL.Vertex2(inner.X + inner.Width + thickness - 1, inner.Y + inner.Height + thickness - 1);
      GL.Vertex2(inner.X + inner.Width, inner.Y + inner.Height);
      GL.Vertex2(inner.X + inner.Width + thickness - 1, inner.Y - thickness);
      GL.Vertex2(inner.X + inner.Width, inner.Y - 1);
      GL.Vertex2(inner.X - thickness, inner.Y - thickness);
      GL.Vertex2(inner.X - 1, inner.Y - 1);
   }

   /// &lt;summary&gt;
   /// Clear the display of all graphics.
   /// &lt;/summary&gt;
   public void Clear()
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      m_currentOp = DisplayOperation.None;
      GL.Clear(ClearBufferMask.AccumBufferBit | ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
   }

   /// &lt;summary&gt;
   /// Set the clipping rectangle that determines the area of the display which will be
   /// affected by all drawing operations.
   /// &lt;/summary&gt;
   /// &lt;param name="rect"&gt;Rectangle relative to the top-left corner of the display in pixel coordinates.&lt;/param&gt;
   public void Scissor(System.Drawing.Rectangle rect)
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      m_currentOp = DisplayOperation.None;
      GL.Enable(EnableCap.ScissorTest);
      GL.Scissor(rect.X, ClientRectangle.Height - rect.Y - rect.Height, rect.Width, rect.Height);
   }

   /// &lt;summary&gt;
   /// Disables clipping defined with &lt;see cref="Scissor"/&gt;.
   /// &lt;/summary&gt;
   public void ScissorOff()
   {
      if (m_currentOp != DisplayOperation.None)
         GL.End();
      m_currentOp = DisplayOperation.None;
      GL.Disable(EnableCap.ScissorTest);
   }

   private static void CheckError()
   {
      ErrorCode ec = GL.GetError();
      if (ec != 0)
      {
         throw new System.Exception(ec.ToString());
      }
   }

   /// &lt;summary&gt;
   /// Draws a string of text on the display using the "CoolFont" graphic sheet
   /// &lt;/summary&gt;
   /// &lt;param name="text"&gt;String to be drawn. Embedded line feeds (\n) are the only cause for line breaks.&lt;/param&gt;
   /// &lt;param name="x"&gt;Horizontal coordinate relative to the top left corner of the display where drawing begins.&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical coordinate relative to the top left corner of the display where drawing begins.&lt;/param&gt;
   /// &lt;remarks&gt;An error will occur if there is no "CoolFont" graphic sheet in the project.
   /// This function is only a very basic implementation of text drawing intended for debugging purposes.
   /// For more full-featured text support, see the &lt;see cref="GeneralRules.ShowMessage"/&gt; rule function.&lt;/remarks&gt;
   public void DrawText(string text, int x, int y)
   {
      const int charWidth = 13;
      const int charHeight = 18;
      if (m_DefaultFont == null)
      {
         object testExist = Project.Resources.GetObject("CoolFont");
         if (testExist == null)
            throw new ApplicationException("In order to use Display.DrawText, the project must have a Graphic Sheet named \"CoolFont\"");
         m_DefaultFont = GetTextureRef("CoolFont");
      }
      byte[] charBytes = System.Text.Encoding.ASCII.GetBytes(text);
      System.Drawing.PointF[] corners = new System.Drawing.PointF[]
         { new System.Drawing.PointF(0, 0),
           new System.Drawing.PointF(0, charHeight),
           new System.Drawing.PointF(charWidth, charHeight),
           new System.Drawing.PointF(charWidth, 0)};
      int origX = x;
      for (int charIdx = 0; charIdx &lt; charBytes.Length; charIdx++)
      {
         byte curChar = charBytes[charIdx];
         if (curChar &gt; 32)
         {
            int col = (curChar - 33) % 24;
            int row = (curChar - 33) / 24;
            System.Drawing.Rectangle sourceRect = new System.Drawing.Rectangle(
               col * charWidth, row * charHeight, charWidth, charHeight);
            DrawFrame(m_DefaultFont, sourceRect, corners, x, y);
            x += charWidth;
         }
         else if (curChar == 10)
         {
            x = origX;
            y += charHeight;
         }
      }
   }
   #endregion

   #region ISerializable Members
   /// &lt;summary&gt;
   /// This is for internal use only and is needed to control behavior of the
   /// Display with respect to the Save Game functions.
   /// &lt;/summary&gt;
   /// &lt;param name="info"&gt;Internal use only&lt;/param&gt;
   /// &lt;param name="context"&gt;Not used&lt;/param&gt;
   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      info.SetType(typeof(DisplayRef));
   }

   #endregion
}

/// &lt;summary&gt;
/// Provides serialization "services" for the &lt;see cref="Display"/&gt; object, preventing
/// attempts to save or load data for the display object when the game is saved/loaded.
/// &lt;/summary&gt;
[Serializable()]
public partial class DisplayRef : System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
{

   private DisplayRef(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
   }

   /// &lt;summary&gt;
   /// This is for internal use only and is needed to control behavior of the
   /// Display with respect to the Save Game functions.
   /// &lt;/summary&gt;
   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      throw new System.NotImplementedException("Unexpected serialization call");
   }

   #region IObjectReference Members
   /// &lt;summary&gt;
   /// This is for internal use only and is needed to control behavior of the
   /// Display with respect to the Load Game functions.
   /// &lt;/summary&gt;
   public object GetRealObject(System.Runtime.Serialization.StreamingContext context)
   {
      return Project.GameWindow.GameDisplay;
   }
   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="Controls.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

/// &lt;summary&gt;
/// UI to support the player's customization of input device.
/// &lt;/summary&gt;
public partial class frmControls : System.Windows.Forms.Form
{
   #region Embedded Types
   class KeyTextBox : TextBox
   {
      protected override void WndProc(ref Message m)
      {
         base.WndProc(ref m);
         if (Parent is frmControls)
            ((frmControls)Parent).ProcessMessage(this, m);
      }
   }
   #endregion

   #region Non-control members
   private System.Threading.Thread readControllerThread = null;
   private bool bExitControllerThread = false;
   private delegate void ControllerButtonPressedDelegate(byte button);
   private int pressedButtons = 0;
   private int currentPlayer;
   private System.Windows.Forms.TextBox txtCurJButton = null;
   private bool bLoading = false;
   private const int WM_KEYDOWN = 0x100;
   #endregion

   #region Windows Form Designer Members
   private System.Windows.Forms.Label lblController;
   private System.Windows.Forms.ComboBox cboController;
   private System.Windows.Forms.RadioButton rdoController;
   private System.Windows.Forms.RadioButton rdoKeyboard;
   private KeyTextBox txtButton4;
   private System.Windows.Forms.Label lblButton4;
   private KeyTextBox txtButton3;
   private System.Windows.Forms.Label lblButton3;
   private KeyTextBox txtButton2;
   private System.Windows.Forms.Label lblButton2;
   private KeyTextBox txtButton1;
   private System.Windows.Forms.Label lblButton1;
   private KeyTextBox txtDown;
   private System.Windows.Forms.Label lblDown;
   private KeyTextBox txtRight;
   private System.Windows.Forms.Label lblRight;
   private KeyTextBox txtLeft;
   private System.Windows.Forms.Label lblLeft;
   private KeyTextBox txtUp;
   private System.Windows.Forms.Label lblUp;
   private System.Windows.Forms.ComboBox cboPlayer;
   private System.Windows.Forms.Label lblPlayer;
   private System.Windows.Forms.TextBox txtJButton4;
   private System.Windows.Forms.TextBox txtJButton3;
   private System.Windows.Forms.TextBox txtJButton2;
   private System.Windows.Forms.TextBox txtJButton1;
   private System.Windows.Forms.Label lblJButton4;
   private System.Windows.Forms.Label lblJButton3;
   private System.Windows.Forms.Label lblJButton2;
   private System.Windows.Forms.Label lblJButton1;
   private System.Windows.Forms.Label label1;

   /// &lt;summary&gt;
   /// Required designer variable.
   /// &lt;/summary&gt;
   private System.ComponentModel.Container components = null;
   #endregion
   
   public frmControls()
   {
      //
      // Required for Windows Form Designer support
      //
      InitializeComponent();

      if (Project.MaxPlayers &lt;= 1)
      {
         lblPlayer.Hide();
         cboPlayer.Hide();
         this.ClientSize = new System.Drawing.Size(298, 270);
      }

      for(int i = 0; i &lt; Project.GameWindow.ControllerCount; i++)
         cboController.Items.Add(Project.GameWindow.GetControllerName(i));
      rdoController.Enabled = (cboController.Items.Count &gt; 0);

      for (int i = 0; i&lt;Project.MaxPlayers; i++)
         cboPlayer.Items.Add("Player " + (i+1).ToString());
      cboPlayer.SelectedIndex = 0;
   }

   /// &lt;summary&gt;
   /// Clean up any resources being used.
   /// &lt;/summary&gt;
   protected override void Dispose( bool disposing )
   {
      if( disposing )
      {
         if(components != null)
         {
            components.Dispose();
         }
      }
      base.Dispose( disposing );
      EndControllerThread();
   }

   #region Windows Form Designer generated code
   private void InitializeComponent()
   {
      this.lblController = new System.Windows.Forms.Label();
      this.cboController = new System.Windows.Forms.ComboBox();
      this.rdoController = new System.Windows.Forms.RadioButton();
      this.rdoKeyboard = new System.Windows.Forms.RadioButton();
      this.txtButton4 = new KeyTextBox();
      this.lblButton4 = new System.Windows.Forms.Label();
      this.txtButton3 = new KeyTextBox();
      this.lblButton3 = new System.Windows.Forms.Label();
      this.txtButton2 = new KeyTextBox();
      this.lblButton2 = new System.Windows.Forms.Label();
      this.txtButton1 = new KeyTextBox();
      this.lblButton1 = new System.Windows.Forms.Label();
      this.txtDown = new KeyTextBox();
      this.lblDown = new System.Windows.Forms.Label();
      this.txtRight = new KeyTextBox();
      this.lblRight = new System.Windows.Forms.Label();
      this.txtLeft = new KeyTextBox();
      this.lblLeft = new System.Windows.Forms.Label();
      this.txtUp = new KeyTextBox();
      this.lblUp = new System.Windows.Forms.Label();
      this.cboPlayer = new System.Windows.Forms.ComboBox();
      this.lblPlayer = new System.Windows.Forms.Label();
      this.txtJButton4 = new System.Windows.Forms.TextBox();
      this.txtJButton3 = new System.Windows.Forms.TextBox();
      this.txtJButton2 = new System.Windows.Forms.TextBox();
      this.txtJButton1 = new System.Windows.Forms.TextBox();
      this.lblJButton4 = new System.Windows.Forms.Label();
      this.lblJButton3 = new System.Windows.Forms.Label();
      this.lblJButton2 = new System.Windows.Forms.Label();
      this.lblJButton1 = new System.Windows.Forms.Label();
      this.label1 = new System.Windows.Forms.Label();
      this.SuspendLayout();
      // 
      // lblController
      // 
      this.lblController.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblController.Enabled = false;
      this.lblController.Location = new System.Drawing.Point(24, 184);
      this.lblController.Name = "lblController";
      this.lblController.Size = new System.Drawing.Size(64, 16);
      this.lblController.TabIndex = 43;
      this.lblController.Text = "Controller:";
      // 
      // cboController
      // 
      this.cboController.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.cboController.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
      this.cboController.Enabled = false;
      this.cboController.Location = new System.Drawing.Point(88, 184);
      this.cboController.Name = "cboController";
      this.cboController.Size = new System.Drawing.Size(200, 21);
      this.cboController.TabIndex = 42;
      this.cboController.SelectedIndexChanged += new System.EventHandler(this.cboController_SelectedIndexChanged);
      // 
      // rdoController
      // 
      this.rdoController.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.rdoController.Location = new System.Drawing.Point(8, 160);
      this.rdoController.Name = "rdoController";
      this.rdoController.Size = new System.Drawing.Size(272, 16);
      this.rdoController.TabIndex = 41;
      this.rdoController.Text = "Game Controller";
      this.rdoController.CheckedChanged += new System.EventHandler(this.InputType_Changed);
      // 
      // rdoKeyboard
      // 
      this.rdoKeyboard.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.rdoKeyboard.Location = new System.Drawing.Point(8, 40);
      this.rdoKeyboard.Name = "rdoKeyboard";
      this.rdoKeyboard.Size = new System.Drawing.Size(272, 16);
      this.rdoKeyboard.TabIndex = 40;
      this.rdoKeyboard.Text = "Keyboard";
      this.rdoKeyboard.CheckedChanged += new System.EventHandler(this.InputType_Changed);
      // 
      // txtButton4
      // 
      this.txtButton4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton4.Enabled = false;
      this.txtButton4.Location = new System.Drawing.Point(224, 128);
      this.txtButton4.Name = "txtButton4";
      this.txtButton4.ReadOnly = true;
      this.txtButton4.Size = new System.Drawing.Size(64, 20);
      this.txtButton4.TabIndex = 39;
      this.txtButton4.Text = "";
      // 
      // lblButton4
      // 
      this.lblButton4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton4.Enabled = false;
      this.lblButton4.Location = new System.Drawing.Point(160, 128);
      this.lblButton4.Name = "lblButton4";
      this.lblButton4.Size = new System.Drawing.Size(64, 20);
      this.lblButton4.TabIndex = 38;
      this.lblButton4.Text = "Button 4:";
      this.lblButton4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtButton3
      // 
      this.txtButton3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton3.Enabled = false;
      this.txtButton3.Location = new System.Drawing.Point(224, 104);
      this.txtButton3.Name = "txtButton3";
      this.txtButton3.ReadOnly = true;
      this.txtButton3.Size = new System.Drawing.Size(64, 20);
      this.txtButton3.TabIndex = 37;
      this.txtButton3.Text = "";
      // 
      // lblButton3
      // 
      this.lblButton3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton3.Enabled = false;
      this.lblButton3.Location = new System.Drawing.Point(160, 104);
      this.lblButton3.Name = "lblButton3";
      this.lblButton3.Size = new System.Drawing.Size(64, 20);
      this.lblButton3.TabIndex = 36;
      this.lblButton3.Text = "Button 3:";
      this.lblButton3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtButton2
      // 
      this.txtButton2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton2.Enabled = false;
      this.txtButton2.Location = new System.Drawing.Point(224, 80);
      this.txtButton2.Name = "txtButton2";
      this.txtButton2.ReadOnly = true;
      this.txtButton2.Size = new System.Drawing.Size(64, 20);
      this.txtButton2.TabIndex = 35;
      this.txtButton2.Text = "";
      // 
      // lblButton2
      // 
      this.lblButton2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton2.Enabled = false;
      this.lblButton2.Location = new System.Drawing.Point(160, 80);
      this.lblButton2.Name = "lblButton2";
      this.lblButton2.Size = new System.Drawing.Size(64, 20);
      this.lblButton2.TabIndex = 34;
      this.lblButton2.Text = "Button 2:";
      this.lblButton2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtButton1
      // 
      this.txtButton1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton1.Enabled = false;
      this.txtButton1.Location = new System.Drawing.Point(224, 56);
      this.txtButton1.Name = "txtButton1";
      this.txtButton1.ReadOnly = true;
      this.txtButton1.Size = new System.Drawing.Size(64, 20);
      this.txtButton1.TabIndex = 33;
      this.txtButton1.Text = "";
      // 
      // lblButton1
      // 
      this.lblButton1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton1.Enabled = false;
      this.lblButton1.Location = new System.Drawing.Point(160, 56);
      this.lblButton1.Name = "lblButton1";
      this.lblButton1.Size = new System.Drawing.Size(64, 20);
      this.lblButton1.TabIndex = 32;
      this.lblButton1.Text = "Button 1:";
      this.lblButton1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtDown
      // 
      this.txtDown.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtDown.Enabled = false;
      this.txtDown.Location = new System.Drawing.Point(88, 128);
      this.txtDown.Name = "txtDown";
      this.txtDown.ReadOnly = true;
      this.txtDown.Size = new System.Drawing.Size(64, 20);
      this.txtDown.TabIndex = 31;
      this.txtDown.Text = "";
      // 
      // lblDown
      // 
      this.lblDown.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblDown.Enabled = false;
      this.lblDown.Location = new System.Drawing.Point(24, 128);
      this.lblDown.Name = "lblDown";
      this.lblDown.Size = new System.Drawing.Size(64, 20);
      this.lblDown.TabIndex = 30;
      this.lblDown.Text = "Down:";
      this.lblDown.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtRight
      // 
      this.txtRight.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtRight.Enabled = false;
      this.txtRight.Location = new System.Drawing.Point(88, 104);
      this.txtRight.Name = "txtRight";
      this.txtRight.ReadOnly = true;
      this.txtRight.Size = new System.Drawing.Size(64, 20);
      this.txtRight.TabIndex = 29;
      this.txtRight.Text = "";
      // 
      // lblRight
      // 
      this.lblRight.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblRight.Enabled = false;
      this.lblRight.Location = new System.Drawing.Point(24, 104);
      this.lblRight.Name = "lblRight";
      this.lblRight.Size = new System.Drawing.Size(64, 20);
      this.lblRight.TabIndex = 28;
      this.lblRight.Text = "Right:";
      this.lblRight.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtLeft
      // 
      this.txtLeft.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtLeft.Enabled = false;
      this.txtLeft.Location = new System.Drawing.Point(88, 80);
      this.txtLeft.Name = "txtLeft";
      this.txtLeft.ReadOnly = true;
      this.txtLeft.Size = new System.Drawing.Size(64, 20);
      this.txtLeft.TabIndex = 27;
      this.txtLeft.Text = "";
      // 
      // lblLeft
      // 
      this.lblLeft.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblLeft.Enabled = false;
      this.lblLeft.Location = new System.Drawing.Point(24, 80);
      this.lblLeft.Name = "lblLeft";
      this.lblLeft.Size = new System.Drawing.Size(64, 20);
      this.lblLeft.TabIndex = 26;
      this.lblLeft.Text = "Left:";
      this.lblLeft.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtUp
      // 
      this.txtUp.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtUp.Enabled = false;
      this.txtUp.Location = new System.Drawing.Point(88, 56);
      this.txtUp.Name = "txtUp";
      this.txtUp.ReadOnly = true;
      this.txtUp.Size = new System.Drawing.Size(64, 20);
      this.txtUp.TabIndex = 25;
      this.txtUp.Text = "";
      // 
      // lblUp
      // 
      this.lblUp.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblUp.Enabled = false;
      this.lblUp.Location = new System.Drawing.Point(24, 56);
      this.lblUp.Name = "lblUp";
      this.lblUp.Size = new System.Drawing.Size(64, 20);
      this.lblUp.TabIndex = 24;
      this.lblUp.Text = "Up:";
      this.lblUp.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // cboPlayer
      // 
      this.cboPlayer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.cboPlayer.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
      this.cboPlayer.Location = new System.Drawing.Point(88, 8);
      this.cboPlayer.Name = "cboPlayer";
      this.cboPlayer.Size = new System.Drawing.Size(200, 21);
      this.cboPlayer.TabIndex = 23;
      this.cboPlayer.SelectedIndexChanged += new System.EventHandler(this.cboPlayer_SelectedIndexChanged);
      // 
      // lblPlayer
      // 
      this.lblPlayer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblPlayer.Location = new System.Drawing.Point(8, 8);
      this.lblPlayer.Name = "lblPlayer";
      this.lblPlayer.Size = new System.Drawing.Size(80, 21);
      this.lblPlayer.TabIndex = 22;
      this.lblPlayer.Text = "Player:";
      this.lblPlayer.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtJButton4
      // 
      this.txtJButton4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtJButton4.Enabled = false;
      this.txtJButton4.Location = new System.Drawing.Point(224, 232);
      this.txtJButton4.Name = "txtJButton4";
      this.txtJButton4.ReadOnly = true;
      this.txtJButton4.Size = new System.Drawing.Size(64, 20);
      this.txtJButton4.TabIndex = 51;
      this.txtJButton4.Text = "";
      this.txtJButton4.Leave += new System.EventHandler(this.txtJButton_Leave);
      this.txtJButton4.Enter += new System.EventHandler(this.txtJButton_Enter);
      // 
      // txtJButton3
      // 
      this.txtJButton3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtJButton3.Enabled = false;
      this.txtJButton3.Location = new System.Drawing.Point(224, 208);
      this.txtJButton3.Name = "txtJButton3";
      this.txtJButton3.ReadOnly = true;
      this.txtJButton3.Size = new System.Drawing.Size(64, 20);
      this.txtJButton3.TabIndex = 49;
      this.txtJButton3.Text = "";
      this.txtJButton3.Leave += new System.EventHandler(this.txtJButton_Leave);
      this.txtJButton3.Enter += new System.EventHandler(this.txtJButton_Enter);
      // 
      // txtJButton2
      // 
      this.txtJButton2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtJButton2.Enabled = false;
      this.txtJButton2.Location = new System.Drawing.Point(88, 232);
      this.txtJButton2.Name = "txtJButton2";
      this.txtJButton2.ReadOnly = true;
      this.txtJButton2.Size = new System.Drawing.Size(64, 20);
      this.txtJButton2.TabIndex = 47;
      this.txtJButton2.Text = "";
      this.txtJButton2.Leave += new System.EventHandler(this.txtJButton_Leave);
      this.txtJButton2.Enter += new System.EventHandler(this.txtJButton_Enter);
      // 
      // txtJButton1
      // 
      this.txtJButton1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtJButton1.Enabled = false;
      this.txtJButton1.Location = new System.Drawing.Point(88, 208);
      this.txtJButton1.Name = "txtJButton1";
      this.txtJButton1.ReadOnly = true;
      this.txtJButton1.Size = new System.Drawing.Size(64, 20);
      this.txtJButton1.TabIndex = 45;
      this.txtJButton1.Text = "";
      this.txtJButton1.Leave += new System.EventHandler(this.txtJButton_Leave);
      this.txtJButton1.Enter += new System.EventHandler(this.txtJButton_Enter);
      // 
      // lblJButton4
      // 
      this.lblJButton4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblJButton4.Enabled = false;
      this.lblJButton4.Location = new System.Drawing.Point(160, 232);
      this.lblJButton4.Name = "lblJButton4";
      this.lblJButton4.Size = new System.Drawing.Size(64, 20);
      this.lblJButton4.TabIndex = 50;
      this.lblJButton4.Text = "Button 4:";
      this.lblJButton4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // lblJButton3
      // 
      this.lblJButton3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblJButton3.Enabled = false;
      this.lblJButton3.Location = new System.Drawing.Point(160, 208);
      this.lblJButton3.Name = "lblJButton3";
      this.lblJButton3.Size = new System.Drawing.Size(64, 20);
      this.lblJButton3.TabIndex = 48;
      this.lblJButton3.Text = "Button 3:";
      this.lblJButton3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // lblJButton2
      // 
      this.lblJButton2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblJButton2.Enabled = false;
      this.lblJButton2.Location = new System.Drawing.Point(24, 232);
      this.lblJButton2.Name = "lblJButton2";
      this.lblJButton2.Size = new System.Drawing.Size(64, 20);
      this.lblJButton2.TabIndex = 46;
      this.lblJButton2.Text = "Button 2:";
      this.lblJButton2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // lblJButton1
      // 
      this.lblJButton1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblJButton1.Enabled = false;
      this.lblJButton1.Location = new System.Drawing.Point(24, 208);
      this.lblJButton1.Name = "lblJButton1";
      this.lblJButton1.Size = new System.Drawing.Size(64, 20);
      this.lblJButton1.TabIndex = 44;
      this.lblJButton1.Text = "Button 1:";
      this.lblJButton1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // label1
      // 
      this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.label1.Location = new System.Drawing.Point(8, 264);
      this.label1.Name = "label1";
      this.label1.Size = new System.Drawing.Size(288, 32);
      this.label1.TabIndex = 52;
      this.label1.Text = "To change button configuration, click on a box and press the key/button to map to" +
         " that button.";
      // 
      // frmControls
      // 
      this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
      this.ClientSize = new System.Drawing.Size(298, 295);
      this.Controls.Add(this.label1);
      this.Controls.Add(this.txtJButton4);
      this.Controls.Add(this.txtJButton3);
      this.Controls.Add(this.txtJButton2);
      this.Controls.Add(this.txtJButton1);
      this.Controls.Add(this.txtButton4);
      this.Controls.Add(this.txtButton3);
      this.Controls.Add(this.txtButton2);
      this.Controls.Add(this.txtButton1);
      this.Controls.Add(this.txtDown);
      this.Controls.Add(this.txtRight);
      this.Controls.Add(this.txtLeft);
      this.Controls.Add(this.txtUp);
      this.Controls.Add(this.lblJButton4);
      this.Controls.Add(this.lblJButton3);
      this.Controls.Add(this.lblJButton2);
      this.Controls.Add(this.lblJButton1);
      this.Controls.Add(this.lblController);
      this.Controls.Add(this.cboController);
      this.Controls.Add(this.rdoController);
      this.Controls.Add(this.rdoKeyboard);
      this.Controls.Add(this.lblButton4);
      this.Controls.Add(this.lblButton3);
      this.Controls.Add(this.lblButton2);
      this.Controls.Add(this.lblButton1);
      this.Controls.Add(this.lblDown);
      this.Controls.Add(this.lblRight);
      this.Controls.Add(this.lblLeft);
      this.Controls.Add(this.lblUp);
      this.Controls.Add(this.cboPlayer);
      this.Controls.Add(this.lblPlayer);
      this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
      this.MaximizeBox = false;
      this.Name = "frmControls";
      this.Text = "Customize Controls";
      this.ResumeLayout(false);

   }
   #endregion

   private void InputType_Changed(object sender, System.EventArgs e)
   {
      if (((RadioButton)sender).Checked)
      {
         lblUp.Enabled = txtUp.Enabled =
            lblLeft.Enabled = txtLeft.Enabled =
            lblRight.Enabled = txtRight.Enabled =
            lblDown.Enabled = txtDown.Enabled =
            lblButton1.Enabled = txtButton1.Enabled = 
            lblButton2.Enabled = txtButton2.Enabled = 
            lblButton3.Enabled = txtButton3.Enabled = 
            lblButton4.Enabled = txtButton4.Enabled =
            sender == rdoKeyboard;

         lblController.Enabled = cboController.Enabled = 
            lblJButton1.Enabled = txtJButton1.Enabled =
            lblJButton2.Enabled = txtJButton2.Enabled =
            lblJButton3.Enabled = txtJButton3.Enabled =
            lblJButton4.Enabled = txtJButton4.Enabled =
            (sender != rdoKeyboard);

         if (!bLoading)
         {
            if (sender == rdoKeyboard)
               Project.GameWindow.Players[SelectedPlayer] = new KeyboardPlayer(SelectedPlayer);
            else
               Project.GameWindow.Players[SelectedPlayer] = new ControllerPlayer(SelectedPlayer % cboController.Items.Count);
         }

         LoadCurrentControls();
      }
   }

   private int SelectedPlayer
   {
      get
      {
         return cboPlayer.SelectedIndex;
      }
   }

   private void ProcessMessage(KeyTextBox sender, Message m)
   {
      if (m.Msg == WM_KEYDOWN)
      {
         KeyboardState kbs = Project.GameWindow.KeyboardState;
         kbs.Poll();
         sender.Text = System.Enum.Format(typeof(Key), kbs.GetFirstKey(), "g");
         KeyboardPlayer player = (KeyboardPlayer)Project.GameWindow.Players[SelectedPlayer];
         if (sender == txtUp)
            player.key_up = kbs.GetFirstKey();
         else if (sender == txtLeft)
            player.key_left = kbs.GetFirstKey();
         else if (sender == txtRight)
            player.key_right = kbs.GetFirstKey();
         else if (sender == txtDown)
            player.key_down = kbs.GetFirstKey();
         else if (sender == txtButton1)
            player.key_button1 = kbs.GetFirstKey();
         else if (sender == txtButton2)
            player.key_button2 = kbs.GetFirstKey();
         else if (sender == txtButton3)
            player.key_button3 = kbs.GetFirstKey();
         else if (sender == txtButton4)
            player.key_button4 = kbs.GetFirstKey();
      }
   }

   private void cboController_SelectedIndexChanged(object sender, System.EventArgs e)
   {
      if (cboController.SelectedIndex &gt;= 0)
         ((ControllerPlayer)Project.GameWindow.Players[SelectedPlayer]).deviceNumber = cboController.SelectedIndex;
   }

   private void cboPlayer_SelectedIndexChanged(object sender, System.EventArgs e)
   {
      // Required for cross-thread access
      currentPlayer = SelectedPlayer;
      LoadCurrentControls();
   }

   private void LoadCurrentControls()
   {
      if (Project.GameWindow.Players[SelectedPlayer] is KeyboardPlayer)
      {
         bLoading = true;
         KeyboardPlayer player = (KeyboardPlayer)Project.GameWindow.Players[SelectedPlayer];
         rdoKeyboard.Checked = true;
         txtUp.Text = System.Enum.Format(typeof(Key), player.key_up, "g");
         txtLeft.Text = System.Enum.Format(typeof(Key), player.key_left, "g");
         txtRight.Text = System.Enum.Format(typeof(Key), player.key_right, "g");
         txtDown.Text = System.Enum.Format(typeof(Key), player.key_down, "g");
         txtButton1.Text = System.Enum.Format(typeof(Key), player.key_button1, "g");
         txtButton2.Text = System.Enum.Format(typeof(Key), player.key_button2, "g");
         txtButton3.Text = System.Enum.Format(typeof(Key), player.key_button3, "g");
         txtButton4.Text = System.Enum.Format(typeof(Key), player.key_button4, "g");
         bLoading = false;
      }
      else
      {
         bLoading = true;
         rdoController.Checked = true;
         ControllerPlayer player = ((ControllerPlayer)Project.GameWindow.Players[SelectedPlayer]);
         int devNum = player.deviceNumber;
         if (cboController.Items.Count &gt; devNum)
         {
            cboController.SelectedIndex = devNum;
            txtJButton1.Text = player.buttonMap[0].ToString();
            txtJButton2.Text = player.buttonMap[1].ToString();
            txtJButton3.Text = player.buttonMap[2].ToString();
            txtJButton4.Text = player.buttonMap[3].ToString();
         }
         else
            cboController.SelectedIndex = -1;
         bLoading = false;
      }
   }

   private void ControllerButtonPressed(byte button)
   {
      ControllerPlayer plr = (ControllerPlayer)Project.GameWindow.Players[SelectedPlayer];
      if (txtCurJButton == txtJButton1)
         plr.buttonMap[0] = button;
      else if (txtCurJButton == txtJButton2)
         plr.buttonMap[1] = button;
      else if (txtCurJButton == txtJButton3)
         plr.buttonMap[2] = button;
      else if (txtCurJButton == txtJButton4)
         plr.buttonMap[3] = button;
      if (txtCurJButton != null)
         txtCurJButton.Text = button.ToString();
   }

   private void ReadControllerLoop()
   {
      ControllerButtonPressedDelegate cbp = new ControllerButtonPressedDelegate(ControllerButtonPressed);
      while (!bExitControllerThread)
      {
         Project.GameWindow.ReadControllers();
         for (byte button = 0; button &lt; 32; button++)
         {
            if (((pressedButtons &amp; (1 &lt;&lt; button)) == 0) &amp;&amp;
               (Project.GameWindow.GetControllerState(((ControllerPlayer)Project.GameWindow.Players[
            currentPlayer]).deviceNumber)[button]))
            {
               this.Invoke(cbp, new object[] { button });
               pressedButtons |= (1 &lt;&lt; button);
            }
            else
               pressedButtons &amp;= ~(1 &lt;&lt; button);
         }
         System.Threading.Thread.Sleep(0);
      }
   }

   private void BeginControllerThread()
   {
      EndControllerThread();
      System.Threading.ThreadStart ts = new System.Threading.ThreadStart(ReadControllerLoop);
      readControllerThread = new System.Threading.Thread(ts);
      readControllerThread.Start();
   }

   private void EndControllerThread()
   {
      if (readControllerThread != null)
      {
         bExitControllerThread = true;
         readControllerThread.Join();
      }
      readControllerThread = null;
      bExitControllerThread = false;
   }

   private void txtJButton_Enter(object sender, System.EventArgs e)
   {
      txtCurJButton = (System.Windows.Forms.TextBox)sender;
      BeginControllerThread();
   }

   private void txtJButton_Leave(object sender, System.EventArgs e)
   {
      txtCurJButton = null;
      EndControllerThread();
   }
}

</Text>
  </SourceCode>
  <SourceCode Name="Tile.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Maps a tile index to frameset frames based on counter values etc
/// &lt;/summary&gt;
public abstract partial class TileBase
{
   protected TileCategoryMembershipBase m_membership;

   protected TileBase(TileCategoryMembershipBase membership)
   {
      m_membership = membership;
   }

   /// &lt;summary&gt;
   /// Returns an array of frameset frames to draw for a tile during a particular frame
   /// &lt;/summary&gt;
   public abstract int[] CurrentFrame
   {
      get;
   }

   /// &lt;summary&gt;
   /// Determines if the tile is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="cat"&gt;Enumerated value that designates a tile category&lt;/param&gt;
   /// &lt;returns&gt;True if the tile is a member of the specified category&lt;/returns&gt;
   public abstract bool IsMember(TileCategoryName cat);
}

/// &lt;summary&gt;
/// Represents the definition for an animated tile in a tileset
/// &lt;/summary&gt;
public partial class AnimTile : TileBase
{
   private readonly TileFrame[] m_frames;
   private readonly Counter m_counter;
   private short[] m_frameIndexMap;

   /// &lt;summary&gt;
   /// Creates an animated tile definition
   /// &lt;/summary&gt;
   /// &lt;param name="counter"&gt;Which counter affects this tile's animation&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames sorted by chronological sequence&lt;/param&gt;
   public AnimTile(Counter counter, params TileFrame[] frames) : base(null)
   {
      if (frames.Length &lt;= 0)
         throw new System.ApplicationException("Use EmptyTile to create empty tiles");
      this.m_frames = frames;
      this.m_counter = counter;
      GenerateFrameIndexMap();
   }

   /// &lt;summary&gt;
   /// Creates an animated tile definition and defines the tile's membership in tiel categories.
   /// &lt;/summary&gt;
   /// &lt;param name="counter"&gt;Which counter affects this tile's animation&lt;/param&gt;
   /// &lt;param name="membership"&gt;Defines the categories of which this tile is a member&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames sorted by chronological sequence&lt;/param&gt;
   public AnimTile(Counter counter, TileCategoryMembershipBase membership, params TileFrame[] frames) : base(membership)
   {
      if (frames.Length &lt;= 0)
         throw new System.ApplicationException("Use EmptyTile to create empty tiles");
      this.m_frames = frames;
      this.m_counter = counter;
      GenerateFrameIndexMap();
   }

   private void GenerateFrameIndexMap()
   {
      m_frameIndexMap = new short[m_frames[m_frames.Length - 1].m_nAccumulatedDuration];
      short frameIndex = 0;
      for (int frameValue=0; frameValue&lt;m_frameIndexMap.Length; frameValue++)
      {
         if (m_frames[frameIndex].m_nAccumulatedDuration &lt;= frameValue)
            frameIndex++;
         m_frameIndexMap[frameValue] = frameIndex;
      }
   }

   /// &lt;summary&gt;
   /// Return the index of the current distinct animation frame in the tile's animation sequence.
   /// (NOT a counter value)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If a tile's first frame has a repeat count of 2, then counter values of 1
   /// and 2 will yield the same animation frame for that tile, and a counter value of 3
   /// will yield the next animation frame. Notice that these were 3 counter values, but only 2
   /// distinct frames. This property will return 1 for counter values of 1 and 2, and 2 for a
   /// counter value of 3 in this example.&lt;/remarks&gt;
   public int FrameSequenceIndex
   {
      get
      {
         return m_frameIndexMap[m_counter.CurrentValue % m_frameIndexMap.Length];
      }
   }

   /// &lt;summary&gt;
   /// Return the total number of distinct animation frames in the tile.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Although a tile may have (for example) 3 distinct animation frames, they may be
   /// spread out over 24 separate counter values be giving each frame a repeat count of 8.
   /// This value will return 3 in this example, not 24.&lt;/remarks&gt;
   public int FrameSequenceLength
   {
      get
      {
         return m_frames.Length;
      }
   }

   /// &lt;summary&gt;
   /// Return an array of frame indexes representing the frames from this tile's
   /// frameset that should be drawn for the tile in its current state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Often times this will be an array of 1 integer because tiles will
   /// often only have one frameset frame per animation frame. But multiple frameset
   /// frames can be combined into a single tile animation frame by specifying a
   /// repeat count of 0, in which case this will return all the "sub-frames" that are
   /// active in the current frame of this tile.&lt;/remarks&gt;
   public override int[] CurrentFrame
   {
      get
      {
         return m_frames[FrameSequenceIndex].subFrames;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileBase.IsMember"/&gt;.
   /// &lt;/summary&gt;
   public override bool IsMember(TileCategoryName cat)
   {
      if (m_membership == null) return false;
      if (m_membership is TileCategoryFrameMembership)
         return ((TileCategoryFrameMembership)m_membership)[FrameSequenceIndex, cat];
      else
         return ((TileCategorySimpleMembership)m_membership)[cat];
   }
}

/// &lt;summary&gt;
/// Represents a non-animated composite or single-cell tile
/// &lt;/summary&gt;
public partial class SimpleTile : TileBase
{
   private readonly int[] frame;

   /// &lt;summary&gt;
   /// Constructs a tile based on a single frame index from a frameset.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;Zero-based index of the frame within the frameset.&lt;/param&gt;
   public SimpleTile(int frame) : base(null)
   {
      this.frame = new int[] {frame};
   }

   /// &lt;summary&gt;
   /// Constructs a single-frame tile based on multiple frameset frames.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;An array of frame indexes that make of this compisite tile.&lt;/param&gt;
   /// &lt;remarks&gt;The frame indexes represent the multiple frames that this tile will always
   /// draw. The first frame is drawn behind, and the last frame is drawn in front.&lt;/remarks&gt;
   public SimpleTile(int[] frame) : base(null)
   {
      this.frame = frame;
   }

   /// &lt;summary&gt;
   /// Constructs a tile based on a single frame index from a frameset, and specifies
   /// the tile's membership in tile categories.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;Zero-based index of the frame within the frameset.&lt;/param&gt;
   /// &lt;param name="membership"&gt;Provides an object that determines in which categories
   /// this tile is a member.&lt;/param&gt;
   public SimpleTile(int frame, TileCategoryMembershipBase membership) : base(membership)
   {
      this.frame = new int[] {frame};
   }

   /// &lt;summary&gt;
   /// Constructs a single-frame tile based on multiple frameset frames, and specifies
   /// the tile's membership in tile categories.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;An array of frame indexes that make of this compisite tile.&lt;/param&gt;
   /// &lt;param name="membership"&gt;Provides an object that determines in which categories
   /// this tile is a member.&lt;/param&gt;
   /// &lt;remarks&gt;The frame indexes represent the multiple frames that this tile will always
   /// draw. The first frame is drawn behind, and the last frame is drawn in front.&lt;/remarks&gt;
   public SimpleTile(int[] frame, TileCategoryMembershipBase membership) : base(membership)
   {
      this.frame = frame;
   }

   /// &lt;summary&gt;
   /// Returns an array of frameset frame indexes that represent the current appearance of the tile.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;For a simple single-frame tile this will always be an array of 1.  For a
   /// compound tile, this will contain multiple frame indexes in sequence from back-most to
   /// fore-most on the display.&lt;/remarks&gt;
   public override int[] CurrentFrame
   {
      get
      {
         return frame;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileBase.IsMember"/&gt;.
   /// &lt;/summary&gt;
   public override bool IsMember(TileCategoryName cat)
   {
      if (m_membership == null) return false;
      return ((TileCategorySimpleMembership)m_membership)[cat];
   }
}

/// &lt;summary&gt;
/// Represents a tile that doesn't draw anything onto the layer
/// &lt;/summary&gt;
public partial class EmptyTile : TileBase
{
   /// &lt;summary&gt;
   /// Returns the single empty tile object used for all empty tiles.
   /// &lt;/summary&gt;
   public static readonly EmptyTile Value = new EmptyTile();
   private readonly int[] frame;

   private EmptyTile() : base(null)
   {
      frame = new int[] {};
   }

   /// &lt;summary&gt;
   /// Returns an empty array
   /// &lt;/summary&gt;
   public override int[] CurrentFrame
   {
      get
      {
         return frame;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileBase.IsMember"/&gt;.
   /// &lt;/summary&gt;
   public override bool IsMember(TileCategoryName cat)
   {
      return false;
   }
}

/// &lt;summary&gt;
/// Represents the appearance of a tile during one iteration of the game loop.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Composite tiles are tiles that draw multiple images at once for a single
/// iteration of the game loop. Such tiles will have sub-frames representing the multiple
/// images that are drawn overlapped.&lt;/remarks&gt;
public partial class TileFrame : IComparable
{
   /// &lt;summary&gt;
   /// Represents counter value, and is used to optimize frame searching
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is the sum of all the repeat count values on this frame
   /// and before and is used to optimize the translation between a counter
   /// value and an index into the series of distinct tile frames/appearances.&lt;/remarks&gt;
   public readonly int m_nAccumulatedDuration;
   /// &lt;summary&gt;
   /// A list of all the frameset frame indexes contained in this tile frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Composite tiles may have multiple frames drawn on top of each other.&lt;/remarks&gt;
   public readonly int[] subFrames;

   /// &lt;summary&gt;
   /// Constructs a composite TileFrame given its &lt;see cref="m_nAccumulatedDuration"/&gt; and
   /// &lt;see cref="subFrames"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="nAccumulatedDuration"&gt;&lt;see cref="m_nAccumulatedDuration"/&gt; value&lt;/param&gt;
   /// &lt;param name="subFrames"&gt;&lt;see cref="subFrames"/&gt; value&lt;/param&gt;
   public TileFrame(int nAccumulatedDuration, int[] subFrames)
   {
      this.m_nAccumulatedDuration = nAccumulatedDuration;
      this.subFrames = subFrames;
   }

   /// &lt;summary&gt;
   /// Constructs a simple (non-composite) TileFrame given its &lt;see cref="m_nAccumulatedDuration"/&gt;
   /// and the single frameset frame index.
   /// &lt;/summary&gt;
   /// &lt;param name="nAccumulatedDuration"&gt;&lt;see cref="m_nAccumulatedDuration"/&gt; value&lt;/param&gt;
   /// &lt;param name="frame"&gt;Frameset frame index drawn by this tile frame. This gets converted into
   /// a single-element array of integers in &lt;see cref="subFrames"/&gt;.&lt;/param&gt;
   public TileFrame(int nAccumulatedDuration, int frame)
   {
      this.m_nAccumulatedDuration= nAccumulatedDuration;
      this.subFrames = new int[] {frame};
   }

   #region IComparable Members
   /// &lt;summary&gt;
   /// Compares frames based on their &lt;see cref="m_nAccumulatedDuration"/&gt; value
   /// &lt;/summary&gt;
   /// &lt;param name="obj"&gt;Another TileFrame object, or a counter value&lt;/param&gt;
   /// &lt;returns&gt;
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Return Value&lt;/term&gt;&lt;item&gt;Description&lt;/item&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;Less than zero&lt;/term&gt;&lt;description&gt;This frame comes before &lt;paramref name="obj"/&gt;
   /// in the counter indexing sequence.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Zero&lt;/term&gt;&lt;description&gt;This frame should be drawn when the specified counter value is current&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Greater than zero&lt;/term&gt;&lt;description&gt;This frame comes after
   /// &lt;paramref name="obj"/&gt; in the counter indexing sequence.&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;&lt;/returns&gt;
   public int CompareTo(object obj)
   {
      if (obj is TileFrame)
         return m_nAccumulatedDuration.CompareTo(((TileFrame)obj).m_nAccumulatedDuration);
      else
         return m_nAccumulatedDuration.CompareTo(obj);
   }
   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="app.config" IsCustomObject="false">
    <Text>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;!-- The following line is not necessary if you use the file named libfmodex.so,
       and it causes errors in .NET environments, so it's commented out. --&gt;
  &lt;!-- &lt;dllmap os="linux" dll="fmodex" target="./libfmodex-4.22.01.so"/&gt; --&gt;
&lt;/configuration&gt;</Text>
  </SourceCode>
  <SourceCode Name="SpriteState.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// This specialization of TileFrame is used specifically for sprite frames
/// with collision masks (when mask alpha level is non-zero).
/// &lt;/summary&gt;
/// &lt;remarks&gt;Some sprites are simple enough that they can be treated very similar to tiles, and
/// will simply use &lt;see cref="TileFrame"/&gt; directly. Others will use this class.&lt;/remarks&gt;
public partial class SpriteFrame : TileFrame
{
   private CollisionMask m_Mask;

   public SpriteFrame(System.Drawing.Rectangle localBounds, Frameset frameset, int nAccumulatedDuration, int[] subFrames, byte[] alphas) : base(nAccumulatedDuration, subFrames)
   {
      m_Mask = new CollisionMask(localBounds, frameset, subFrames, alphas);
   }

   public SpriteFrame(System.Drawing.Rectangle localBounds, Frameset frameset, int nAccumulatedDuration, int frame, byte alpha) : base(nAccumulatedDuration, frame)
   {
      m_Mask = new CollisionMask(localBounds, frameset, new int[] {frame}, new byte[] {alpha});
   }

   /// &lt;summary&gt;
   /// Returns the mask for this sprite frame.
   /// &lt;/summary&gt;
   public CollisionMask Mask
   {
      get
      {
         return m_Mask;
      }
   }
}

/// &lt;summary&gt;
/// Represents one state within a sprite definition, primarily defining how a it can animate.
/// &lt;/summary&gt;
public partial class SpriteState
{
   private readonly TileFrame[] m_frames;
   private short[] m_frameIndexMap;
   private Frameset m_Frameset;
   private int m_nSolidWidth;
   private int m_nSolidHeight;
   private System.Drawing.Rectangle m_LocalBounds;

   /// &lt;summary&gt;
   /// Constructs a new state given all the information for the state.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Solid width of this state. Each state within a sprite can have its own solid width.&lt;/param&gt;
   /// &lt;param name="height"&gt;Solid height of this state. Each state within a sprite can have its own solid height.&lt;/param&gt;
   /// &lt;param name="frameset"&gt;&lt;see cref="Frameset"/&gt; containing all the graphics for this state.&lt;/param&gt;
   /// &lt;param name="localBounds"&gt;Rectangle that visually enclompases the graphics of all the frames of this state.
   /// This is used to determine when the sprite is fully or partially visible on the layer and needs to be drawn.&lt;/param&gt;
   /// &lt;param name="frames"&gt;A sequential list of all frames from &lt;paramref name="frameset"/&gt; that are included in this state.&lt;/param&gt;
   public SpriteState(int width, int height, Frameset frameset, System.Drawing.Rectangle localBounds, params TileFrame[] frames)
   {
      m_nSolidWidth = width;
      m_nSolidHeight = height;
      m_Frameset = frameset;
      m_LocalBounds = localBounds;
      m_frames = frames;
      if (m_frames.Length &gt; 0)
      {
         m_frameIndexMap = new short[m_frames[m_frames.Length - 1].m_nAccumulatedDuration];
         short frameIndex = 0;
         for (int frameValue=0; frameValue&lt;m_frameIndexMap.Length; frameValue++)
         {
            if (m_frames[frameIndex].m_nAccumulatedDuration &lt;= frameValue)
               frameIndex++;
            m_frameIndexMap[frameValue] = frameIndex;
         }
      }
   }

   /// &lt;summary&gt;
   /// Returns the frameset on which all graphics in this state are based.
   /// &lt;/summary&gt;
   public Frameset Frameset
   {
      get
      {
         return m_Frameset;
      }
   }

   /// &lt;summary&gt;
   /// Return a list of all frame indexes that represent a particular animation frame of a sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="frameIndex"&gt;Frame counter value.&lt;/param&gt;
   /// &lt;returns&gt;Array if integers that represent indexes into &lt;see cref="Frameset"/&gt; for the
   /// frames that should be drawn for the specified frame.&lt;/returns&gt;
   /// &lt;remarks&gt;Often times this will return an array of one integer because a sprite will only
   /// display one frame at a time. Compound frames defined by using a repeat count of "0" on some
   /// frames, however, will cause multiple frameset frames to be comined into a single sprite
   /// frame. So a single &lt;paramref name="frameIndex"/&gt; value can yield multiple frameset frame
   /// indexes to be drawn at once. But also note that multiple &lt;paramref name="frameIndex"/&gt;
   /// values can yield the same frames because a frame with a repeat count greater than 1 will
   /// cause the sprite to remain on the same frame for multiple iterations.&lt;/remarks&gt;
   public int[] GetFrame(int frameIndex)
   {
      return m_frames[m_frameIndexMap[frameIndex % m_frameIndexMap.Length]].subFrames;
   }

   /// &lt;summary&gt;
   /// Get the collision mask for a specified sprite frame.
   /// &lt;/summary&gt;
   /// &lt;param name="frameIndex"&gt;Frame counter value.&lt;/param&gt;
   /// &lt;returns&gt;Collision mask for the specified frame of the sprite (simply or compound)
   /// if applicable, otherwise a null reference.
   /// See &lt;see cref="GetFrame"/&gt; for more information about &lt;paramref name="frameIndex"/&gt; and
   /// frame counters.&lt;/returns&gt;
   public CollisionMask GetMask(int frameIndex)
   {
      SpriteFrame frame = m_frames[m_frameIndexMap[frameIndex % m_frameIndexMap.Length]] as SpriteFrame;
      if (frame == null)
         return null;
      return frame.Mask;
   }

   /// &lt;summary&gt;
   /// Retrieve the solid width of this state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each sprite state can have its own solid width. For example a leaping sprite might
   /// be wider than a standing sprite, and might react to solidity on the map as such.&lt;/remarks&gt;
   public int SolidWidth
   {
      get
      {
         return m_nSolidWidth;
      }
   }

   /// &lt;summary&gt;
   /// Retrieve the solid height of this state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each sprite state can have its own solid height. For example a crouching sprite might
   /// be shorter than a standing sprite, and might react to solidity on the map as such.&lt;/remarks&gt;
   public int SolidHeight
   {
      get
      {
         return m_nSolidHeight;
      }
   }

   /// &lt;summary&gt;
   /// Returns a rectangle (relative to the origin of the sprite) that bounds
   /// all the graphics in this state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is used to determine when part or all of the sprite is visible on the current
   /// view of the sprite's layer, and consequently, whether it should be drawn.&lt;/remarks&gt;
   public System.Drawing.Rectangle LocalBounds
   {
      get
      {
         return m_LocalBounds;
      }
   }
}</Text>
  </SourceCode>
  <SourceCode Name="Frame.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;

/// &lt;summary&gt;
/// An instance of the Frame class represents one image from a frameset.
/// &lt;/summary&gt;
public partial struct Frame
{
   /// &lt;summary&gt;
   /// References the un-transformed graphics on which this frame is based
   /// &lt;/summary&gt;
   public Display.TextureRef GraphicSheetTexture;
   /// &lt;summary&gt;
   /// Refers to an index into the graphic sheet of the individual graphic on which this frame is based
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is informational only. The actual graphic is obtained using
   /// &lt;see cref="SourceRect"/&gt;.&lt;/remarks&gt;
   public short CellIndex;
   /// &lt;summary&gt;
   /// Defines the transformed corners of this frame when drawn.
   /// &lt;/summary&gt;
   public PointF[] Corners;
   /// &lt;summary&gt;
   /// Specifies color channel modulations that are applied to this frame
   /// &lt;/summary&gt;
   public int Color;
   /// &lt;summary&gt;
   /// Specifies the area on the graphic sheet which is used to form the graphic cell on which
   /// this frame is based.
   /// &lt;/summary&gt;
   public Rectangle SourceRect;

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index, transformation, source rectangle and color modulation.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="corners"&gt;Corners of the output rectangle for drawing this frame in
   /// counter-clockwise order beginning with the top left corner.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   /// &lt;param name="color"&gt;Provides this frame's &lt;see cref="Color"/&gt;.&lt;/param&gt;
   public Frame(Display.TextureRef texture, short cell, PointF[] corners, Rectangle srcRect, int color)
   {
      GraphicSheetTexture = texture;
      CellIndex = cell;
      this.Corners = corners;
      SourceRect = srcRect;
      this.Color = color;
   }

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index, transformation and source rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="corners"&gt;Corners of the output rectangle for drawing this frame in
   /// counter-clockwise order beginning with the top left corner.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   public Frame(Display.TextureRef texture, short cell, PointF[] corners, Rectangle srcRect) :
      this(texture, cell, corners, srcRect, -1)
   {
   }

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index, source rectangle and color modulation.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   /// &lt;param name="color"&gt;Provides this frame's &lt;see cref="Color"/&gt;.&lt;/param&gt;
   /// &lt;remarks&gt;This constructor provides a shortcut for creating frames without transformations.&lt;/remarks&gt;
   public Frame(Display.TextureRef texture, short cell, Rectangle srcRect, int color)
   {
      GraphicSheetTexture = texture;
      CellIndex = cell;
      Corners = new PointF[] {
         new PointF(0, 0),
         new PointF(0, srcRect.Height),
         new PointF(srcRect.Width, srcRect.Height),
         new PointF(srcRect.Width, 0) };
      SourceRect = srcRect;
      this.Color = color;
   }

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index and source rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   /// &lt;remarks&gt;This constructor provides a shortcut for creating frames without transformations or color modulations.&lt;/remarks&gt;
   public Frame(Display.TextureRef texture, short cell, Rectangle srcRect) :
      this(texture, cell, srcRect, -1)
   {
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="SpriteCustom.cs" IsCustomObject="true" DependsOn="">
    <Text>using System.ComponentModel;
using System.Diagnostics;

public abstract partial class SpriteBase : GeneralRules
{
   /// &lt;summary&gt;
   /// Determines if a tile at the sprite's current position is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Tile category against which the tile will be checked.&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;The sprite may be on multiple tiles at once. This parameter
   /// indicates which part of the sprite to look at, and gets the tile from the layer at
   /// the specified position.&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point in the sprite is on a tile in the specified category, false otherwise.&lt;/returns&gt;
   [Description("Examines the tile on the layer at the sprite's current position and determines if it is a member of the specified category. The RelativePosition parameter determines which part of the sprite to use when identifying a location on the layer, and Direction determines which direction from that point to check. (TouchTiles is not necessary for this function.)")]
   public bool IsAgainstTile(TileCategoryName Category, RelativePosition RelativePosition, Direction Direction)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsAgainstTile on an inactive sprite");

      System.Drawing.Point rp = GetRelativePosition(RelativePosition);
      switch(Direction)
      {
         case Direction.Up:
            rp.Offset(0, -1);
            break;
         case Direction.Right:
            rp.Offset(1, 0);
            break;
         case Direction.Down:
            rp.Offset(0, 1);
            break;
         case Direction.Left:
            rp.Offset(-1, 0);
            break;
      }
      return layer.GetTile((int)(rp.X / layer.Tileset.TileWidth), (int)(rp.Y / layer.Tileset.TileHeight)).IsMember(Category);
   }

   protected byte OnConveyorBelt = 0;
   [Description("Tests if the sprite is standing on a conveyor belt; if so, prepare it to react to it.")]
   public void LandOnConveyor(double speed)
   {
      // If on rightward conveyor
      if (this.IsAgainstTile(TileCategoryName.ConveyorRight, RelativePosition.BottomLeft, SpriteBase.Direction.Down) ||
          this.IsAgainstTile(TileCategoryName.ConveyorRight, RelativePosition.BottomRight, SpriteBase.Direction.Down)) {
         // If not already on a conveyor belt (right)
         if (OnConveyorBelt == 0) {
            // Set rightward conveyor local velocity
            LocalDX = dx - speed;
            // Set rightward conveyor belt
            OnConveyorBelt = 1;
         }
      }
      else {
         // Else if on leftward conveyor
         if (this.IsAgainstTile(TileCategoryName.ConveyorLeft, RelativePosition.BottomLeft, SpriteBase.Direction.Down) ||
             this.IsAgainstTile(TileCategoryName.ConveyorLeft, RelativePosition.BottomRight, SpriteBase.Direction.Down)) {
            // If not already on a conveyor (left)
            if (OnConveyorBelt == 0) {
               // Set local leftward conveyor local velocity
               LocalDX = dx + speed;
               // Set leftward conveyor belt
               OnConveyorBelt = 2;
            }
         }
         else {
            // Else if was on a conveyor (and no longer is)
            if (OnConveyorBelt != 0) {
               // Stop riding conveyor
               this.StopRiding();
               OnConveyorBelt = 0;
            }
         }
      }
   }

   [Description("Reacts to a conveyor belt if the sprite is riding one.")]
   public void ReactToConveyor(double speed)
   {
      // If riding rightward conveyor
      if (OnConveyorBelt == 1) {
         // React to rightward conveyor
         dx = LocalDX + speed;
      }
      else {
         // Else if riding leftward conveyor
         if (OnConveyorBelt == 2) {
            // React to leftward conveyor
            dx = LocalDX - speed;
         }
      }
   }

   /// &lt;summary&gt;
   /// Set the value of the tile that this sprite overlaps (does not require &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="NewTileValue"&gt;New tile value&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;The sprite may overlap multiple tiles at once.
   /// This parameter determines which part of the sprite overlaps the tile to change.&lt;/param&gt;
   [Description("Set the value of the tile behind this sprite (does not require TouchTiles)")]
   public void TileSetValue(int NewTileValue, RelativePosition RelativePosition)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileSetValue on an inactive sprite");

      System.Drawing.Point rp = GetRelativePosition(RelativePosition);
      layer[(int)(rp.X / layer.Tileset.TileWidth), (int)(rp.Y / layer.Tileset.TileHeight)] = NewTileValue;
   }

   /// &lt;summary&gt;
   /// Get the value of the tile that this sprite overlaps (does not require &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="RelativePosition"&gt;The sprite may overlap multiple tiles at once.
   /// This parameter determines which part of the sprite overlaps the tile to read.&lt;/param&gt;
   [Description("Set the value of the tile behind this sprite (does not require TouchTiles)")]
   public int  TileGetValue(RelativePosition RelativePosition)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileGetValue on an inactive sprite");

      System.Drawing.Point rp = GetRelativePosition(RelativePosition);
      return layer[(int)(rp.X / layer.Tileset.TileWidth), (int)(rp.Y / layer.Tileset.TileHeight)];
   }

   /// &lt;summary&gt;
   /// Determines if a tile at the sprite's current position is a specifiv tile value.
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Tile value against which the tile will be compared.&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;The sprite may be on multiple tiles at once. This parameter
   /// indicates which part of the sprite to look at, and gets the tile from the layer at
   /// the specified position.&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point in the sprite is on a tile with the specified value, false otherwise.&lt;/returns&gt;
   [Description("Determines if the tile on the layer at the sprite's current position matches the specified value. The RelativePosition parameter determines which part of the sprite to use when identifying a location on the layer. (TouchTiles is not necessary for this function.)")]
   public bool IsOnTileValue(int TileValue, RelativePosition RelativePosition)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsOnTileValue on an inactive sprite");

      System.Drawing.Point rp = GetRelativePosition(RelativePosition);
      return layer[(int)(rp.X / layer.Tileset.TileWidth), (int)(rp.Y / layer.Tileset.TileHeight)] == TileValue;
   }

   /// &lt;summary&gt;
   /// Determine if the sprite selected with &lt;see cref="GeneralRules.SelectTargetSprite"/&gt;
   /// is in the specified direction relative to this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Direction"&gt;Determines which direction will be tested.&lt;/param&gt;
   /// &lt;returns&gt;True is the currently selected target sprite is in the specified direction
   /// relative to this sprite, false otherwise.&lt;/returns&gt;
   [Description("Determine if the selected target sprite is in the specified direction relative to this sprite.")]
   public bool IsTargetDirection(Direction Direction)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsTargetDirection on an inactive sprite");

      SpriteBase target = GetSelectedTargetFor(System.String.Empty);
      if (target == null)
         return false;

      switch(Direction)
      {
         case Direction.Up:
            return target.y &lt; y;
         case Direction.Left:
            return target.x &lt; x;
         case Direction.Right:
            return target.x &gt; x;
         case Direction.Down:
            return target.y &gt; y;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// If this sprite is not already riding/attached to another sprite, link this sprite to the nearest sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="ParentList"&gt;Specifies the category of sprite to look in for the nearest sprite.&lt;/param&gt;
   /// &lt;returns&gt;True if this sprite is attached.&lt;/returns&gt;
   [Description("If this sprite is not already riding/attached to another sprite, link this sprite to the nearest sprite in the specified category.")]
   public bool AttachToNearest(SpriteCollection ParentList)
   {
      Debug.Assert(this.isActive, "Attempted to execute AttachToNearest on an inactive sprite");
      if (RidingOn != null)
         return true;
      int nearest = GetNearestSpriteIndex(ParentList);
      if (nearest &gt;= 0)
         RidingOn = ParentList[nearest];
      else
         return false;
      return true;
   }

   /// &lt;summary&gt;
   /// If this sprite is riding on or attached to another sprite, position it relative to that sprite now.
   /// &lt;/summary&gt;
   /// &lt;param name="ParentPoint"&gt;Specifies which point in the attached sprite should be matched.&lt;/param&gt;
   /// &lt;param name="MyPoint"&gt;Specifies which point on this sprite should match the parent's position.&lt;/param&gt;
   [Description("If this sprite is riding on or attached to another sprite, position it relative to that sprite now.")]
   public void StickToAttached(RelativePosition ParentPoint, RelativePosition MyPoint)
   {
      Debug.Assert(this.isActive, "Attempted to execute StickToAttached on an inactive sprite");
      if (RidingOn == null)
         return;
      if (!RidingOn.Processed)
         RidingOn.ProcessRules();
      if (RidingOn.isActive == false)
      {
         RidingOn = null;
         return;
      }
      System.Drawing.Point ptParent = RidingOn.GetRelativePosition(ParentPoint);
      System.Drawing.Point ptSelf = GetRelativePosition(MyPoint);
      oldX = x;
      oldY = y;
      x += ptParent.X - ptSelf.X;
      y += ptParent.Y - ptSelf.Y;      
   }

   /// &lt;summary&gt;
   /// Determine if sprite number Index in category Targets has a sprite in Attachments attached. Index of -1 is nearest sprite in Targets.
   /// &lt;/summary&gt;
   /// &lt;param name="Targets"&gt;Specifies a category of sprites containing tha target sprite to be tested.&lt;/param&gt;
   /// &lt;param name="Index"&gt;0-based index into Targets of sprite to check for attachments.&lt;/param&gt;
   /// &lt;param name="Attachments"&gt;Specified which sprites may be attached.&lt;/param&gt;
   /// &lt;returns&gt;If an attachment is found, the 0-based index to the sprite in Attachments, otherwise -1.&lt;/returns&gt;
   [Description("Determine if sprite number Index in category Targets has a sprite in Attachments attached. Return 0-based index if it does, or -1 of none exists. Index of -1 is nearest sprite in Targets.")]
   public int GetTargetAttachment(SpriteCollection Targets, int Index, SpriteCollection Attachments)
   {
      Debug.Assert(this.isActive, "Attepmted to execute TargetHasAttachment on an inactive sprite");
      Debug.Assert(Index &lt; Targets.Count, "Attempted to TargetHasAttachment on an index beyond the bounds of a collection");

      if (Index &lt; 0)
         Index = GetNearestSpriteIndex(Targets);
      if (Index &lt; 0)
         return -1;
      for(int i = 0; i &lt; Attachments.Count; i++)
         if (Attachments[i].RidingOn == Targets[Index])
            return i;
      return -1;
   }

   /// &lt;summary&gt;
   /// Locate the nearest sprite in a specified category that does not already have
   /// an attachment from another specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies a category containing the target
   /// sprite toward which this sprite will be pushed.&lt;/param&gt;
   /// in order for this sprite to be pushed. &lt;/param&gt;
   /// &lt;param name="Attachments"&gt;Avoid targets that have sprites from this collection already attached.&lt;/param&gt;
   /// &lt;param name="MaxDistance"&gt;Specifies the radius in pixels within which the target must be found
   /// &lt;returns&gt;0-based index into Target collection of the nearest sprite satisfying the parameters,
   /// or -1 if no sprite matches.&lt;/returns&gt;
   [Description("Locate the nearest sprite in a specified category that does not already have an attachment from another specified category. Returns 0-based index into Target or -1 if nothing is in range.")]
   public virtual int FindNearestFreeBot(SpriteCollection Target, SpriteCollection Attachments, int MaxDistance)
   {
      Debug.Assert(this.isActive, "Attepmted to execute FindNearestFreeBot on an inactive sprite");

      int minDist = MaxDistance * MaxDistance;
      int index = -1;
      for (int i = 0; i &lt; Target.Count; i++)
      {
         if ((!Target[i].isActive) || (Target[i] == this))
            continue;
         int xOff = Target[i].PixelX - PixelX;
         int yOff = Target[i].PixelY - PixelY;
         int dist = xOff * xOff + yOff * yOff;
         if ((dist &lt; minDist) &amp;&amp; (GetTargetAttachment(Target, i, Attachments) &lt; 0))
         {
            minDist = dist;
            index = i;
         }
      }

      return index;
   }

   /// &lt;summary&gt;
   /// Determine if this sprite is currently visible
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if the sprite is active and any part of the
   /// sprite insersects with the currently displayed area of the
   /// map layer it is on, otherwise false.&lt;/returns&gt;
   [Description("Determine if this sprite is currently visible")]
   public bool IsVisible()
   {
      return isActive &amp;&amp; layer.IsSpriteVisible(this);
   }

   /// &lt;summary&gt;
   /// Determine if the specified input was being pressed for this sprite before the
   /// current inputs were acquired.
   /// &lt;/summary&gt;
   /// &lt;param name="Input"&gt;Which of thes sprite's inputs should be checked&lt;/param&gt;
   /// &lt;returns&gt;True only when the specified input on this sprite was pressed before
   /// the current inputs were acquired.&lt;/returns&gt;
   /// &lt;remarks&gt;This function uses &lt;see cref="oldinputs"/&gt; to determine whether an input
   /// was pressed before or not. &lt;see cref="oldinputs"/&gt;
   /// is automatically managed by the &lt;see cref="MapPlayerToInputs"/&gt; function.
   /// &lt;seealso cref="oldinputs"/&gt;&lt;/remarks&gt;
   [Description("Determine if the specified input was being pressed for this sprite before the current inputs were acquired.")]
   public virtual bool WasInputPressed(InputBits Input)
   {
      Debug.Assert(this.isActive, "Attempted to execute WasInputPressed on an inactive sprite");
      return (0 != (oldinputs &amp; Input));
   }

   [Description("Move this sprite in the specified direction by the specified number of rows or columns.")]
   public virtual void MoveOverTiles(Direction Direction, int Count)
   {
      switch(Direction)
      {
         case Direction.Up:
            y -= layer.Tileset.TileHeight * Count;
            break;
         case Direction.Right:
            x += layer.Tileset.TileWidth * Count;
            break;
         case Direction.Down:
            y += layer.Tileset.TileHeight * Count;
            break;
         case Direction.Left:
            x -= layer.Tileset.TileWidth * Count;
            break;
      }
  }

   [Description("Determine whether the solidity rectangle of the sprite overlaps that of any sprite in the specified category by more than margin pixels. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public virtual int TestCollisionRectMargin(SpriteCollection Targets, int Margin)
   {
      if (!isActive)
         return -1;
      for (int idx = 0; idx &lt; Targets.Count; idx++)
      {
         SpriteBase TargetSprite = Targets[idx];
         if ((TargetSprite == this) || (!TargetSprite.isActive))
            continue;
         int x1 = PixelX;
         int w1 = SolidWidth;
         int x2 = TargetSprite.PixelX;
         int w2 = TargetSprite.SolidWidth;
         int y1 = PixelY;
         int h1 = SolidHeight;
         int y2 = TargetSprite.PixelY;
         int h2 = TargetSprite.SolidHeight;

         if ((x1 + w1 &gt; x2 + Margin) &amp;&amp; (x2 + w2 &gt; x1 + Margin) &amp;&amp; (y1 + h1 &gt; y2 + Margin) &amp;&amp; (y2 + h2 &gt; y1 + Margin))
            return idx;
      }
      return -1;
   }

   [Description("Snap the sprite to the nearest tile")]
   public virtual void SnapToTile()
   {
      x = ((int)((x + layer.Tileset.TileWidth / 2) / layer.Tileset.TileWidth)) * layer.Tileset.TileWidth;
      y = ((int)((y + layer.Tileset.TileHeight / 2) / layer.Tileset.TileHeight)) * layer.Tileset.TileHeight;
   }

   [Description("Get the specified number with the last digit removed")]
   public virtual int RemoveDigit(int Value)
   {
      return Value / 10;
   }
}</Text>
  </SourceCode>
  <SourceCode Name="PlayerCustom.cs" IsCustomObject="true" DependsOn="">
    <Text>using System.ComponentModel;
using System.Diagnostics;

namespace Sprites {
   public partial class Player
   {
      [Description("Switch from crouching to standing state and return true if sprite is standing afterward")]
      public bool UnCrouch()
      {
         Debug.Assert(this.isActive, "Attempted to execute UnCrouch on an inactive sprite");

         // If crouching left
         if (this.IsInState((int)Sprites.Player.State.Crouch_left, (int)Sprites.Player.State.Crouch_left)) {
            // Stand left
            return this.SwitchToState((int)Sprites.Player.State.Left, RelativePosition.BottomCenter);
         }
         // If crouching right
         if (this.IsInState((int)Sprites.Player.State.Crouch_right, (int)Sprites.Player.State.Crouch_right)) {
            // Stand right
            return this.SwitchToState((int)Sprites.Player.State.Right, RelativePosition.BottomCenter);
         }

         return this.IsInState((int)Sprites.Player.State.Right, (int)Sprites.Player.State.Left);
      }
   }
}</Text>
  </SourceCode>
  <SourceCode Name="ShapeCustom.cs" IsCustomObject="true" DependsOn="">
    <Text>/*
   +--------+
   |        |
   |        |
   |        |
   |^^^^^^^^|
   |        |
   |        |
   |        |
   |        |
   +--------+
   (Top is solid only from above)
*/
/// &lt;summary&gt;
/// Represents a tile that is only solid from above starting at the vertical center of the tile.
/// A sprite can move freely through this tile in any direction unless the sprite is above the
/// tile in which case it cannot penetrate below the middle.
/// &lt;/summary&gt;
public partial class TopSolidMidTileShape : TileShape
{
   private static TopSolidMidTileShape m_Value = new TopSolidMidTileShape ();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static TopSolidMidTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public TopSolidMidTileShape ()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height/2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }
}</Text>
  </SourceCode>
  <SourceCode Name="CollectionCustom.cs" IsCustomObject="true" DependsOn="">
    <Text>public partial class SpriteCollection : System.Collections.CollectionBase
{
   public void CopyTo(System.Array array, int index)
   {
      ((System.Collections.ICollection)this).CopyTo(array, index);
   }
}</Text>
  </SourceCode>
  <SourceCode Name="fmodex.dll" IsCustomObject="true">
    <Text>/*
   Because this is a binary file, this text only
   serves as a comment and will not be compiled.
*/
</Text>
  </SourceCode>
  <SourceCode Name="fmod.cs" IsCustomObject="true" DependsOn="fmodex.dll">
    <Text>/* The content of this "file" is taken from the fmod.cs, fmod_dsp.cs and      */
/* fmod_errors.cs files provided in the api directory of the FMOD package.    */
/* Editing this file in the IDE exhibits strange behavior due to possible     */
/* bugs in the RTF control, but it doesn't need much editing.  To locate      */
/* the bondaries between files, search for NEXT FILE - Ben Marty              */

/* ========================================================================================== */
/* FMOD Ex - C# Wrapper . Copyright (c), Firelight Technologies Pty, Ltd. 2004-2008.          */
/*                                                                                            */
/*                                                                                            */
/* ========================================================================================== */

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace FMOD
{
    /*
        FMOD version number.  Check this against FMOD::System::getVersion / System_GetVersion
        0xaaaabbcc -&gt; aaaa = major version number.  bb = minor version number.  cc = development version number.
    */
    public class VERSION
    {
        public const int    number = 0x00042006;
        public const string dll    = "fmodex";
    }

    /*
        FMOD types 
    */
    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]   
        Structure describing a point in 3D space.

        [REMARKS]
        FMOD uses a left handed co-ordinate system by default.
        To use a right handed co-ordinate system specify FMOD_INIT_3D_RIGHTHANDED from FMOD_INITFLAGS in System::init.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        System::set3DListenerAttributes
        System::get3DListenerAttributes
        Channel::set3DAttributes
        Channel::get3DAttributes
        Geometry::addPolygon
        Geometry::setPolygonVertex
        Geometry::getPolygonVertex
        Geometry::setRotation
        Geometry::getRotation
        Geometry::setPosition
        Geometry::getPosition
        Geometry::setScale
        Geometry::getScale
        FMOD_INITFLAGS
    ]
    */
    public struct VECTOR
    {
        public float x;        /* X co-ordinate in 3D space. */
        public float y;        /* Y co-ordinate in 3D space. */
        public float z;        /* Z co-ordinate in 3D space. */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]   
        Structure describing a globally unique identifier.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii, Solaris

        [SEE_ALSO]      
        System::getDriverInfo
    ]
    */
    public struct GUID
    {
        public uint   Data1;       /* Specifies the first 8 hexadecimal digits of the GUID */
        public ushort Data2;       /* Specifies the first group of 4 hexadecimal digits.   */
        public ushort Data3;       /* Specifies the second group of 4 hexadecimal digits.  */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=8)]
        public char[] Data4;    /* Array of 8 bytes. The first 2 bytes contain the third group of 4 hexadecimal digits. The remaining 6 bytes contain the final 12 hexadecimal digits. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        error codes.  Returned from every function.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
    ]
    */
    public enum RESULT
    {
        OK,                        /* No errors. */
        ERR_ALREADYLOCKED,         /* Tried to call lock a second time before unlock was called. */
        ERR_BADCOMMAND,            /* Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock on a streaming sound). */
        ERR_CDDA_DRIVERS,          /* Neither NTSCSI nor ASPI could be initialised. */
        ERR_CDDA_INIT,             /* An error occurred while initialising the CDDA subsystem. */
        ERR_CDDA_INVALID_DEVICE,   /* Couldn't find the specified device. */
        ERR_CDDA_NOAUDIO,          /* No audio tracks on the specified disc. */
        ERR_CDDA_NODEVICES,        /* No CD/DVD devices were found. */ 
        ERR_CDDA_NODISC,           /* No disc present in the specified drive. */
        ERR_CDDA_READ,             /* A CDDA read error occurred. */
        ERR_CHANNEL_ALLOC,         /* Error trying to allocate a channel. */
        ERR_CHANNEL_STOLEN,        /* The specified channel has been reused to play another sound. */
        ERR_COM,                   /* A Win32 COM related error occured. COM failed to initialize or a QueryInterface failed meaning a Windows codec or driver was not installed properly. */
        ERR_DMA,                   /* DMA Failure.  See debug output for more information. */
        ERR_DSP_CONNECTION,        /* DSP connection error.  Connection possibly caused a cyclic dependancy. */
        ERR_DSP_FORMAT,            /* DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format. */
        ERR_DSP_NOTFOUND,          /* DSP connection error.  Couldn't find the DSP unit specified. */
        ERR_DSP_RUNNING,           /* DSP error.  Cannot perform this operation while the network is in the middle of running.  This will most likely happen if a connection or disconnection is attempted in a DSP callback. */
        ERR_DSP_TOOMANYCONNECTIONS,/* DSP connection error.  The unit being connected to or disconnected should only have 1 input or output. */
        ERR_FILE_BAD,              /* Error loading file. */
        ERR_FILE_COULDNOTSEEK,     /* Couldn't perform seek operation.  This is a limitation of the medium (ie netstreams) or the file format. */
        ERR_FILE_DISKEJECTED,      /* Media was ejected while reading. */
        ERR_FILE_EOF,              /* End of file unexpectedly reached while trying to read essential data (truncated data?). */
        ERR_FILE_NOTFOUND,         /* File not found. */
        ERR_FILE_UNWANTED,         /* Unwanted file access occured. */
        ERR_FORMAT,                /* Unsupported file or audio format. */
        ERR_HTTP,                  /* A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere. */
        ERR_HTTP_ACCESS,           /* The specified resource requires authentication or is forbidden. */
        ERR_HTTP_PROXY_AUTH,       /* Proxy authentication is required to access the specified resource. */
        ERR_HTTP_SERVER_ERROR,     /* A HTTP server error occurred. */
        ERR_HTTP_TIMEOUT,          /* The HTTP request timed out. */
        ERR_INITIALIZATION,        /* FMOD was not initialized correctly to support this function. */
        ERR_INITIALIZED,           /* Cannot call this command after System::init. */
        ERR_INTERNAL,              /* An error occured that wasn't supposed to.  Contact support. */
        ERR_INVALID_ADDRESS,       /* On Xbox 360, this memory address passed to FMOD must be physical, (ie allocated with XPhysicalAlloc.) */
        ERR_INVALID_FLOAT,         /* Value passed in was a NaN, Inf or denormalized float. */
        ERR_INVALID_HANDLE,        /* An invalid object handle was used. */
        ERR_INVALID_PARAM,         /* An invalid parameter was passed to this function. */
        ERR_INVALID_SPEAKER,       /* An invalid speaker was passed to this function based on the current speaker mode. */
        ERR_INVALID_SYNCPOINT,     /* The syncpoint did not come from this sound handle. */
        ERR_INVALID_VECTOR,        /* The vectors passed in are not unit length, or perpendicular. */
        ERR_IRX,                   /* PS2 only.  fmodex.irx failed to initialize.  This is most likely because you forgot to load it. */
        ERR_MAXAUDIBLE,            /* Reached maximum audible playback count for this sound's soundgroup. */
        ERR_MEMORY,                /* Not enough memory or resources. */
        ERR_MEMORY_CANTPOINT,      /* Can't use FMOD_OPENMEMORY_POINT on non PCM source data, or non mp3/xma/adpcm data if CREATECOMPRESSEDSAMPLE was used. */
        ERR_MEMORY_IOP,            /* PS2 only.  Not enough memory or resources on PlayStation 2 IOP ram. */
        ERR_MEMORY_SRAM,           /* Not enough memory or resources on console sound ram. */
        ERR_NEEDS2D,               /* Tried to call a command on a 3d sound when the command was meant for 2d sound. */
        ERR_NEEDS3D,               /* Tried to call a command on a 2d sound when the command was meant for 3d sound. */
        ERR_NEEDSHARDWARE,         /* Tried to use a feature that requires hardware support.  (ie trying to play a VAG compressed sound in software on PS2). */
        ERR_NEEDSSOFTWARE,         /* Tried to use a feature that requires the software engine.  Software engine has either been turned off, or command was executed on a hardware channel which does not support this feature. */
        ERR_NET_CONNECT,           /* Couldn't connect to the specified host. */
        ERR_NET_SOCKET_ERROR,      /* A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere. */
        ERR_NET_URL,               /* The specified URL couldn't be resolved. */
        ERR_NET_WOULD_BLOCK,       /* Operation on a non-blocking socket could not complete immediately. */
        ERR_NOTREADY,              /* Operation could not be performed because specified sound is not ready. */
        ERR_OUTPUT_ALLOCATED,      /* Error initializing output device, but more specifically, the output device is already in use and cannot be reused. */
        ERR_OUTPUT_CREATEBUFFER,   /* Error creating hardware sound buffer. */
        ERR_OUTPUT_DRIVERCALL,     /* A call to a standard soundcard driver failed, which could possibly mean a bug in the driver or resources were missing or exhausted. */
        ERR_OUTPUT_ENUMERATION,    /* Error enumerating the available driver list. List may be inconsistent due to a recent device addition or removal. */
        ERR_OUTPUT_FORMAT,         /* Soundcard does not support the minimum features needed for this soundsystem (16bit stereo output). */
        ERR_OUTPUT_INIT,           /* Error initializing output device. */
        ERR_OUTPUT_NOHARDWARE,     /* FMOD_HARDWARE was specified but the sound card does not have the resources nescessary to play it. */
        ERR_OUTPUT_NOSOFTWARE,     /* Attempted to create a software sound but no software channels were specified in System::init. */
        ERR_PAN,                   /* Panning only works with mono or stereo sound sources. */
        ERR_PLUGIN,                /* An unspecified error has been returned from a 3rd party plugin. */
        ERR_PLUGIN_INSTANCES,      /* The number of allowed instances of a plugin has been exceeded */
        ERR_PLUGIN_MISSING,        /* A requested output, dsp unit type or codec was not available. */
        ERR_PLUGIN_RESOURCE,       /* A resource that the plugin requires cannot be found. (ie the DLS file for MIDI playback) */
        ERR_RECORD,                /* An error occured trying to initialize the recording device. */
        ERR_REVERB_INSTANCE,       /* Specified Instance in REVERB_PROPERTIES couldn't be set. Most likely because another application has locked the EAX4 FX slot. */
        ERR_SUBSOUND_ALLOCATED,    /* This subsound is already being used by another sound, you cannot have more than one parent to a sound.  Null out the other parent's entry first. */
        ERR_SUBSOUND_CANTMOVE,     /* Shared subsounds cannot be replaced or moved from their parent stream, such as when the parent stream is an FSB file. */
        ERR_SUBSOUND_MODE,         /* The subsound's mode bits do not match with the parent sound's mode bits.  See documentation for function that it was called with. */
        ERR_SUBSOUNDS,             /* The error occured because the sound referenced contains subsounds.  (ie you cannot play the parent sound as a static sample, only its subsounds.) */
        ERR_TAGNOTFOUND,           /* The specified tag could not be found or there are no tags. */
        ERR_TOOMANYCHANNELS,       /* The sound created exceeds the allowable input channel count.  This can be increased using the maxinputchannels parameter in System::setSoftwareFormat. */
        ERR_UNIMPLEMENTED,         /* Something in FMOD hasn't been implemented when it should be! contact support! */
        ERR_UNINITIALIZED,         /* This command failed because System::init or System::setDriver was not called. */
        ERR_UNSUPPORTED,           /* A command issued was not supported by this object.  Possibly a plugin without certain callbacks specified. */
        ERR_UPDATE,                /* An error caused by System::update occured. */
        ERR_VERSION,               /* The version number of this file format is not supported. */

        ERR_EVENT_FAILED,          /* An Event failed to be retrieved, most likely due to 'just fail' being specified as the max playbacks behavior. */
        ERR_EVENT_INFOONLY,        /* Can't execute this command on an EVENT_INFOONLY event. */
        ERR_EVENT_INTERNAL,        /* An error occured that wasn't supposed to.  See debug log for reason. */
        ERR_EVENT_MAXSTREAMS,      /* Event failed because 'Max streams' was hit when FMOD_INIT_FAIL_ON_MAXSTREAMS was specified. */
        ERR_EVENT_MISMATCH,        /* FSB mis-matches the FEV it was compiled with. */
        ERR_EVENT_NAMECONFLICT,    /* A category with the same name already exists. */
        ERR_EVENT_NOTFOUND,        /* The requested event, event group, event category or event property could not be found. */
    }



    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These output types are used with System::setOutput/System::getOutput, to choose which output method to use.
  
        [REMARKS]
        To drive the output synchronously, and to disable FMOD's timing thread, use the FMOD_INIT_NONREALTIME flag.
        
        To pass information to the driver when initializing fmod use the extradriverdata parameter for the following reasons.
        &lt;li&gt;FMOD_OUTPUTTYPE_WAVWRITER - extradriverdata is a pointer to a char * filename that the wav writer will output to.
        &lt;li&gt;FMOD_OUTPUTTYPE_WAVWRITER_NRT - extradriverdata is a pointer to a char * filename that the wav writer will output to.
        &lt;li&gt;FMOD_OUTPUTTYPE_DSOUND - extradriverdata is a pointer to a HWND so that FMOD can set the focus on the audio for a particular window.
        &lt;li&gt;FMOD_OUTPUTTYPE_GC - extradriverdata is a pointer to a FMOD_ARAMBLOCK_INFO struct. This can be found in fmodgc.h.
        Currently these are the only FMOD drivers that take extra information.  Other unknown plugins may have different requirements.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        System::setOutput
        System::getOutput
        System::setSoftwareFormat
        System::getSoftwareFormat
        System::init
    ]
    */
    public enum OUTPUTTYPE
    {
        AUTODETECT,    /* Picks the best output mode for the platform.  This is the default. */

        UNKNOWN,       /* All         - 3rd party plugin, unknown.  This is for use with System::getOutput only. */
        NOSOUND,       /* All         - All calls in this mode succeed but make no sound. */
        WAVWRITER,     /* All         - All         - Writes output to fmodout.wav by default.  Use System::setSoftwareFormat to set the filename. */
        NOSOUND_NRT,   /* All         - Non-realtime version of FMOD_OUTPUTTYPE_NOSOUND.  User can drive mixer with System::update at whatever rate they want. */
        WAVWRITER_NRT, /* All         - Non-realtime version of FMOD_OUTPUTTYPE_WAVWRITER.  User can drive mixer with System::update at whatever rate they want. */

        DSOUND,        /* Win32/Win64 - DirectSound output.  Use this to get hardware accelerated 3d audio and EAX Reverb support. (Default on Windows) */
        WINMM,         /* Win32/Win64 - Windows Multimedia output. */
        OPENAL,        /* Win32/Win64 - OpenAL 1.1 output. Use this for lower CPU overhead than FMOD_OUTPUTTYPE_DSOUND, and also Vista H/W support with Creative Labs cards. */
        WASAPI,        /* Win32       - Windows Audio Session API. (Default on Windows Vista) */        
        ASIO,          /* Win32       - Low latency ASIO driver. */
        OSS,           /* Linux       - Open Sound System output. */
        ALSA,          /* Linux       - Advanced Linux Sound Architecture output. */
        ESD,           /* Linux       - Enlightment Sound Daemon output. */
        SOUNDMANAGER,  /* Mac         - Macintosh SoundManager output. */
        COREAUDIO,     /* Mac         - Macintosh CoreAudio output */
        XBOX,          /* Xbox        - Native hardware output. */
        PS2,           /* PS2         - Native hardware output. */
        PS3,           /* PS3         - Native hardware output. (Default on PS3) */
        GC,            /* GameCube    - Native hardware output. */
        XBOX360,       /* Xbox 360    - Native hardware output. */
        PSP,           /* PSP         - Native hardware output. */
        WII,           /* Wii         - Native hardware output. (Default on Wii) */

        MAX            /* Maximum number of output types supported. */
    }


    /*
    [ENUM] 
    [
        [DESCRIPTION]   

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
    ]
    */
    public enum CAPS
    {
        NONE                   = 0x00000000,    /* Device has no special capabilities. */
        HARDWARE               = 0x00000001,    /* Device supports hardware mixing. */
        HARDWARE_EMULATED      = 0x00000002,    /* User has device set to 'Hardware acceleration = off' in control panel, and now extra 200ms latency is incurred. */
        OUTPUT_MULTICHANNEL    = 0x00000004,    /* Device can do multichannel output, ie greater than 2 channels. */
        OUTPUT_FORMAT_PCM8     = 0x00000008,    /* Device can output to 8bit integer PCM. */
        OUTPUT_FORMAT_PCM16    = 0x00000010,    /* Device can output to 16bit integer PCM. */
        OUTPUT_FORMAT_PCM24    = 0x00000020,    /* Device can output to 24bit integer PCM. */
        OUTPUT_FORMAT_PCM32    = 0x00000040,    /* Device can output to 32bit integer PCM. */
        OUTPUT_FORMAT_PCMFLOAT = 0x00000080,    /* Device can output to 32bit floating point PCM. */
        REVERB_EAX2            = 0x00000100,    /* Device supports EAX2 reverb. */
        REVERB_EAX3            = 0x00000200,    /* Device supports EAX3 reverb. */
        REVERB_EAX4            = 0x00000400,    /* Device supports EAX4 reverb  */
        REVERB_EAX5            = 0x00000800,    /* Device supports EAX5 reverb  */
        REVERB_I3DL2           = 0x00000800,    /* Device supports I3DL2 reverb. */
        REVERB_LIMITED         = 0x00001000     /* Device supports some form of limited hardware reverb, maybe parameterless and only selectable by environment. */
    }

    /*
    [DEFINE] 
    [
        [NAME]
        FMOD_DEBUGLEVEL

        [DESCRIPTION]   
        Bit fields to use with FMOD::Debug_SetLevel / FMOD::Debug_GetLevel to control the level of tty debug output with logging versions of FMOD (fmodL).

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        Debug_SetLevel 
        Debug_GetLevel
    ]
    */
    public enum DEBUGLEVEL
    {
        LEVEL_NONE           = 0x00000000,
        LEVEL_LOG            = 0x00000001,
        LEVEL_ERROR          = 0x00000002,
        LEVEL_WARNING        = 0x00000004,
        LEVEL_HINT           = 0x00000008,
        LEVEL_ALL            = 0x000000FF,   
        TYPE_MEMORY          = 0x00000100,
        TYPE_THREAD          = 0x00000200,
        TYPE_FILE            = 0x00000400,
        TYPE_NET             = 0x00000800,
        TYPE_EVENT           = 0x00001000,
        TYPE_ALL             = 0x0000FFFF,                     
        DISPLAY_TIMESTAMPS   = 0x01000000,
        DISPLAY_LINENUMBERS  = 0x02000000,
        DISPLAY_COMPRESS     = 0x04000000,
        DISPLAY_ALL          = 0x0F000000,   
        ALL                  = unchecked((int)0xffffffff)
    }


    /*
    [DEFINE] 
    [
        [NAME]
        FMOD_MEMORY_TYPE

        [DESCRIPTION]   
        Bit fields for memory allocation type being passed into FMOD memory callbacks.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        FMOD_MEMORY_ALLOCCALLBACK
        FMOD_MEMORY_REALLOCCALLBACK
        FMOD_MEMORY_FREECALLBACK
        Memory_Initialize
    
    ]
    */
    public enum MEMORY_TYPE
    {
        NORMAL           = 0x00000000,       /* Standard memory. */
        XBOX360_PHYSICAL = 0x00100000,       /* Requires XPhysicalAlloc / XPhysicalFree. */
        PERSISTENT       = 0x00200000        /* Persistent memory. Memory will be freed when System::release is called. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These are speaker types defined for use with the System::setSpeakerMode or System::getSpeakerMode command.

        [REMARKS]
        These are important notes on speaker modes in regards to sounds created with FMOD_SOFTWARE.&lt;br&gt;
        Note below the phrase 'sound channels' is used.  These are the subchannels inside a sound, they are not related and 
        have nothing to do with the FMOD class "Channel".&lt;br&gt;
        For example a mono sound has 1 sound channel, a stereo sound has 2 sound channels, and an AC3 or 6 channel wav file have 6 "sound channels".&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_RAW&lt;br&gt;
        ---------------------&lt;br&gt;
        This mode is for output devices that are not specifically mono/stereo/quad/surround/5.1 or 7.1, but are multichannel.&lt;br&gt;
        Sound channels map to speakers sequentially, so a mono sound maps to output speaker 0, stereo sound maps to output speaker 0 &amp; 1.&lt;br&gt;
        The user assumes knowledge of the speaker order.  FMOD_SPEAKER enumerations may not apply, so raw channel indicies should be used.&lt;br&gt;
        Multichannel sounds map input channels to output channels 1:1. &lt;br&gt;
        Channel::setPan and Channel::setSpeakerMix do not work.&lt;br&gt;
        Speaker levels must be manually set with Channel::setSpeakerLevels.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_MONO&lt;br&gt;
        ---------------------&lt;br&gt;
        This mode is for a 1 speaker arrangement.&lt;br&gt;
        Panning does not work in this speaker mode.&lt;br&gt;
        Mono, stereo and multichannel sounds have each sound channel played on the one speaker unity.&lt;br&gt;
        Mix behaviour for multichannel sounds can be set with Channel::setSpeakerLevels.&lt;br&gt;
        Channel::setSpeakerMix does not work.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_STEREO&lt;br&gt;
        -----------------------&lt;br&gt;
        This mode is for 2 speaker arrangements that have a left and right speaker.&lt;br&gt;
        &lt;li&gt;Mono sounds default to an even distribution between left and right.  They can be panned with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Stereo sounds default to the middle, or full left in the left speaker and full right in the right speaker.  
        &lt;li&gt;They can be cross faded with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Multichannel sounds have each sound channel played on each speaker at unity.&lt;br&gt;
        &lt;li&gt;Mix behaviour for multichannel sounds can be set with Channel::setSpeakerLevels.&lt;br&gt;
        &lt;li&gt;Channel::setSpeakerMix works but only front left and right parameters are used, the rest are ignored.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_QUAD&lt;br&gt;
        ------------------------&lt;br&gt;
        This mode is for 4 speaker arrangements that have a front left, front right, rear left and a rear right speaker.&lt;br&gt;
        &lt;li&gt;Mono sounds default to an even distribution between front left and front right.  They can be panned with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.&lt;br&gt;
        &lt;li&gt;They can be cross faded with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Multichannel sounds default to all of their sound channels being played on each speaker in order of input.&lt;br&gt;
        &lt;li&gt;Mix behaviour for multichannel sounds can be set with Channel::setSpeakerLevels.&lt;br&gt;
        &lt;li&gt;Channel::setSpeakerMix works but side left, side right, center and lfe are ignored.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_SURROUND&lt;br&gt;
        ------------------------&lt;br&gt;
        This mode is for 4 speaker arrangements that have a front left, front right, front center and a rear center.&lt;br&gt;
        &lt;li&gt;Mono sounds default to the center speaker.  They can be panned with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.  
        &lt;li&gt;They can be cross faded with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Multichannel sounds default to all of their sound channels being played on each speaker in order of input.&lt;br&gt;
        &lt;li&gt;Mix behaviour for multichannel sounds can be set with Channel::setSpeakerLevels.&lt;br&gt;
        &lt;li&gt;Channel::setSpeakerMix works but side left, side right and lfe are ignored, and rear left / rear right are averaged into the rear speaker.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_5POINT1&lt;br&gt;
        ------------------------&lt;br&gt;
        This mode is for 5.1 speaker arrangements that have a left/right/center/rear left/rear right and a subwoofer speaker.&lt;br&gt;
        &lt;li&gt;Mono sounds default to the center speaker.  They can be panned with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.  
        &lt;li&gt;They can be cross faded with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Multichannel sounds default to all of their sound channels being played on each speaker in order of input.  
        &lt;li&gt;Mix behaviour for multichannel sounds can be set with Channel::setSpeakerLevels.&lt;br&gt;
        &lt;li&gt;Channel::setSpeakerMix works but side left / side right are ignored.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_7POINT1&lt;br&gt;
        ------------------------&lt;br&gt;
        This mode is for 7.1 speaker arrangements that have a left/right/center/rear left/rear right/side left/side right 
        and a subwoofer speaker.&lt;br&gt;
        &lt;li&gt;Mono sounds default to the center speaker.  They can be panned with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.  
        &lt;li&gt;They can be cross faded with Channel::setPan.&lt;br&gt;
        &lt;li&gt;Multichannel sounds default to all of their sound channels being played on each speaker in order of input.  
        &lt;li&gt;Mix behaviour for multichannel sounds can be set with Channel::setSpeakerLevels.&lt;br&gt;
        &lt;li&gt;Channel::setSpeakerMix works and every parameter is used to set the balance of a sound in any speaker.&lt;br&gt;
        &lt;br&gt;
        FMOD_SPEAKERMODE_PROLOGIC&lt;br&gt;
        ------------------------------------------------------&lt;br&gt;
        This mode is for mono, stereo, 5.1 and 7.1 speaker arrangements, as it is backwards and forwards compatible with stereo, 
        but to get a surround effect a Dolby Prologic or Prologic 2 hardware decoder / amplifier is needed.&lt;br&gt;
        Pan behaviour is the same as FMOD_SPEAKERMODE_5POINT1.&lt;br&gt;
        &lt;br&gt;
        If this function is called the numoutputchannels setting in System::setSoftwareFormat is overwritten.&lt;br&gt;
        &lt;br&gt;
        For 3D sounds, panning is determined at runtime by the 3D subsystem based on the speaker mode to determine which speaker the 
        sound should be placed in.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::setSpeakerMode
        System::getSpeakerMode
        System::getDriverCaps
        Channel::setSpeakerLevels
    ]
    */
    public enum SPEAKERMODE
    {
        RAW,              /* There is no specific speakermode.  Sound channels are mapped in order of input to output.  See remarks for more information. */
        MONO,             /* The speakers are monaural. */
        STEREO,           /* The speakers are stereo (DEFAULT). */
        QUAD,             /* 4 speaker setup.  This includes front left, front right, rear left, rear right.  */
        SURROUND,         /* 4 speaker setup.  This includes front left, front right, center, rear center (rear left/rear right are averaged). */
        _5POINT1,         /* 5.1 speaker setup.  This includes front left, front right, center, rear left, rear right and a subwoofer. */
        _7POINT1,         /* 7.1 speaker setup.  This includes front left, front right, center, rear left, rear right, side left, side right and a subwoofer. */
        PROLOGIC,         /* Stereo output, but data is encoded in a way that is picked up by a Prologic/Prologic2 decoder and split into a 5.1 speaker setup. */

        FMOD_SPEAKERMODE_MAX,              /* Maximum number of speaker modes supported. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These are speaker types defined for use with the Channel::setSpeakerLevels command.
        It can also be used for speaker placement in the System::setSpeakerPosition command.

        [REMARKS]
        If you are using FMOD_SPEAKERMODE_RAW and speaker assignments are meaningless, just cast a raw integer value to this type.&lt;br&gt;
        For example (FMOD_SPEAKER)7 would use the 7th speaker (also the same as FMOD_SPEAKER_SIDE_RIGHT).&lt;br&gt;
        Values higher than this can be used if an output system has more than 8 speaker types / output channels.  15 is the current maximum.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        FMOD_SPEAKERMODE
        Channel::setSpeakerLevels
        Channel::getSpeakerLevels
        System::setSpeakerPosition
        System::getSpeakerPosition
    ]
    */
    public enum SPEAKER
    {
        FRONT_LEFT,
        FRONT_RIGHT,
        FRONT_CENTER,
        LOW_FREQUENCY,
        BACK_LEFT,
        BACK_RIGHT,
        SIDE_LEFT,
        SIDE_RIGHT,
    
        MAX,                          /* Maximum number of speaker types supported. */
        MONO        = FRONT_LEFT,     /* For use with FMOD_SPEAKERMODE_MONO and Channel::SetSpeakerLevels.  Mapped to same value as FMOD_SPEAKER_FRONT_LEFT. */
        BACK_CENTER = LOW_FREQUENCY,  /* For use with FMOD_SPEAKERMODE_SURROUND and Channel::SetSpeakerLevels only.  Mapped to same value as FMOD_SPEAKER_LOW_FREQUENCY. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These are plugin types defined for use with the System::getNumPlugins / System_GetNumPlugins, 
        System::getPluginInfo / System_GetPluginInfo and System::unloadPlugin / System_UnloadPlugin functions.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::getNumPlugins
        System::getPluginInfo
        System::unloadPlugin
    ]
    */
    public enum PLUGINTYPE
    {
        OUTPUT,     /* The plugin type is an output module.  FMOD mixed audio will play through one of these devices */
        CODEC,      /* The plugin type is a file format codec.  FMOD will use these codecs to load file formats for playback. */
        DSP         /* The plugin type is a DSP unit.  FMOD will use these plugins as part of its DSP network to apply effects to output or generate sound in realtime. */
    }


    /*
    [ENUM] 
    [
        [DESCRIPTION]   
        Initialization flags.  Use them with System::init in the flags parameter to change various behaviour.  

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::init
    ]
    */
    public enum INITFLAG
    {
        NORMAL                  = 0x00000000,   /* All platforms - Initialize normally */
        STREAM_FROM_UPDATE      = 0x00000001,   /* All platforms - No stream thread is created internally.  Streams are driven from System::update.  Mainly used with non-realtime outputs. */
        _3D_RIGHTHANDED         = 0x00000002,   /* All platforms - FMOD will treat +X as left, +Y as up and +Z as forwards. */
        SOFTWARE_DISABLE        = 0x00000004,   /* All platforms - Disable software mixer to save memory.  Anything created with FMOD_SOFTWARE will fail and DSP will not work. */
        SOFTWARE_OCCLUSION      = 0x00000008,   /* All platforms - All FMOD_SOFTWARE with FMOD_3D based voices will add a software lowpass filter effect into the DSP chain which is automatically used when Channel::set3DOcclusion is used or the geometry API. */
        SOFTWARE_HRTF           = 0x00000010,   /* All platforms - All FMOD_SOFTWARE with FMOD_3D based voices will add a software lowpass filter effect into the DSP chain which causes sounds to sound duller when the sound goes behind the listener. */
        ENABLE_PROFILE          = 0x00000020,   /* All platforms - Enable TCP/IP based host which allows "DSPNet Listener.exe" to connect to it, and view the DSP dataflow network graph in real-time. */
        VOL0_BECOMES_VIRTUAL    = 0x00000080,   /* All platforms - Any sounds that are 0 volume will go virtual and not be processed except for having their positions updated virtually.  Use System::setAdvancedSettings to adjust what volume besides zero to switch to virtual at. */
        WASAPI_EXCLUSIVE        = 0x00000100,   /* Win32 Vista only - for WASAPI output - Enable exclusive access to hardware, lower latency at the expense of excluding other applications from accessing the audio hardware. */
        DSOUND_HRTFNONE         = 0x00000200,   /* Win32 only - for DirectSound output - FMOD_HARDWARE | FMOD_3D buffers use simple stereo panning/doppler/attenuation when 3D hardware acceleration is not present. */
        DSOUND_HRTFLIGHT        = 0x00000400,   /* Win32 only - for DirectSound output - FMOD_HARDWARE | FMOD_3D buffers use a slightly higher quality algorithm when 3D hardware acceleration is not present. */
        DSOUND_HRTFFULL         = 0x00000800,   /* Win32 only - for DirectSound output - FMOD_HARDWARE | FMOD_3D buffers use full quality 3D playback when 3d hardware acceleration is not present. */
        PS2_DISABLECORE0REVERB  = 0x00010000,   /* PS2 only - Disable reverb on CORE 0 to regain SRAM. */
        PS2_DISABLECORE1REVERB  = 0x00020000,   /* PS2 only - Disable reverb on CORE 1 to regain SRAM. */
        PS2_DONTUSESCRATCHPAD   = 0x00040000,   /* PS2 only - Disable FMOD's usage of the scratchpad. */
        PS2_SWAPDMACHANNELS     = 0x00080000,   /* PS2 only - Changes FMOD from using SPU DMA channel 0 for software mixing, and 1 for sound data upload/file streaming, to 1 and 0 respectively. */
        XBOX_REMOVEHEADROOM     = 0x00100000,   /* XBox only - By default DirectSound attenuates all sound by 6db to avoid clipping/distortion.  CAUTION.  If you use this flag you are responsible for the final mix to make sure clipping / distortion doesn't happen. */
        _360_MUSICMUTENOTPAUSE  = 0x00200000,   /* Xbox 360 only - The "music" channelgroup which by default pauses when custom 360 dashboard music is played, can be changed to mute (therefore continues playing) instead of pausing, by using this flag. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These definitions describe the type of song being played.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Sound::getFormat
    ]
    */
    public enum SOUND_TYPE
    {
        UNKNOWN,         /* 3rd party / unknown plugin format. */
        AAC,             /* AAC.  Currently unsupported. */
        AIFF,            /* AIFF. */
        ASF,             /* Microsoft Advanced Systems Format (ie WMA/ASF/WMV). */
        AT3,             /* Sony ATRAC 3 format */
        CDDA,            /* Digital CD audio. */
        DLS,             /* Sound font / downloadable sound bank. */
        FLAC,            /* FLAC lossless codec. */
        FSB,             /* FMOD Sample Bank. */
        GCADPCM,         /* GameCube ADPCM */
        IT,              /* Impulse Tracker. */
        MIDI,            /* MIDI. */
        MOD,             /* Protracker / Fasttracker MOD. */
        MPEG,            /* MP2/MP3 MPEG. */
        OGGVORBIS,       /* Ogg vorbis. */
        PLAYLIST,        /* Information only from ASX/PLS/M3U/WAX playlists */
        RAW,             /* Raw PCM data. */
        S3M,             /* ScreamTracker 3. */
        SF2,             /* Sound font 2 format. */
        USER,            /* User created sound. */
        WAV,             /* Microsoft WAV. */
        XM,              /* FastTracker 2 XM. */
        XMA,             /* Xbox360 XMA */
        VAG              /* PlayStation 2 / PlayStation Portable adpcm VAG format. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These definitions describe the native format of the hardware or software buffer that will be used.

        [REMARKS]
        This is the format the native hardware or software buffer will be or is created in.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::createSoundEx
        Sound::getFormat
    ]
    */
    public enum SOUND_FORMAT
    {
        NONE,     /* Unitialized / unknown */
        PCM8,     /* 8bit integer PCM data */
        PCM16,    /* 16bit integer PCM data  */
        PCM24,    /* 24bit integer PCM data  */
        PCM32,    /* 32bit integer PCM data  */
        PCMFLOAT, /* 32bit floating point PCM data  */
        GCADPCM,  /* Compressed GameCube DSP data */
        IMAADPCM, /* Compressed XBox ADPCM data */
        VAG,      /* Compressed PlayStation 2 ADPCM data */
        XMA,      /* Compressed Xbox360 data. */
        MPEG,     /* Compressed MPEG layer 2 or 3 data. */
        MAX       /* Maximum number of sound formats supported. */ 
    }


    /*
    [DEFINE]
    [
        [NAME] 
        FMOD_MODE

        [DESCRIPTION]   
        Sound description bitfields, bitwise OR them together for loading and describing sounds.

        [REMARKS]
        By default a sound will open as a static sound that is decompressed fully into memory.&lt;br&gt;
        To have a sound stream instead, use FMOD_CREATESTREAM.&lt;br&gt;
        Some opening modes (ie FMOD_OPENUSER, FMOD_OPENMEMORY, FMOD_OPENRAW) will need extra information.&lt;br&gt;
        This can be provided using the FMOD_CREATESOUNDEXINFO structure.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::createSound
        System::createStream
        Sound::setMode
        Sound::getMode
        Channel::setMode
        Channel::getMode
        Sound::set3DCustomRolloff
        Channel::set3DCustomRolloff
    ]
    */
    public enum MODE :uint
    {
        DEFAULT                = 0x00000000,  /* FMOD_DEFAULT is a default sound type.  Equivalent to all the defaults listed below.  FMOD_LOOP_OFF, FMOD_2D, FMOD_HARDWARE. */
        LOOP_OFF               = 0x00000001,  /* For non looping sounds. (default).  Overrides FMOD_LOOP_NORMAL / FMOD_LOOP_BIDI. */
        LOOP_NORMAL            = 0x00000002,  /* For forward looping sounds. */
        LOOP_BIDI              = 0x00000004,  /* For bidirectional looping sounds. (only works on software mixed static sounds). */
        _2D                    = 0x00000008,  /* Ignores any 3d processing. (default). */
        _3D                    = 0x00000010,  /* Makes the sound positionable in 3D.  Overrides FMOD_2D. */
        HARDWARE               = 0x00000020,  /* Attempts to make sounds use hardware acceleration. (default). */
        SOFTWARE               = 0x00000040,  /* Makes sound reside in software.  Overrides FMOD_HARDWARE.  Use this for FFT, DSP, 2D multi speaker support and other software related features. */
        CREATESTREAM           = 0x00000080,  /* Decompress at runtime, streaming from the source provided (standard stream).  Overrides FMOD_CREATESAMPLE. */
        CREATESAMPLE           = 0x00000100,  /* Decompress at loadtime, decompressing or decoding whole file into memory as the target sample format. (standard sample). */
        CREATECOMPRESSEDSAMPLE = 0x00000200,  /* Load MP2, MP3, IMAADPCM or XMA into memory and leave it compressed.  During playback the FMOD software mixer will decode it in realtime as a 'compressed sample'.  Can only be used in combination with FMOD_SOFTWARE. */
        OPENUSER               = 0x00000400,  /* Opens a user created static sample or stream. Use FMOD_CREATESOUNDEXINFO to specify format and/or read callbacks.  If a user created 'sample' is created with no read callback, the sample will be empty.  Use FMOD_Sound_Lock and FMOD_Sound_Unlock to place sound data into the sound if this is the case. */
        OPENMEMORY             = 0x00000800,  /* "name_or_data" will be interpreted as a pointer to memory instead of filename for creating sounds. */
        OPENMEMORY_POINT       = 0x10000000,  /* "name_or_data" will be interpreted as a pointer to memory instead of filename for creating sounds.  Use FMOD_CREATESOUNDEXINFO to specify length.  This differs to FMOD_OPENMEMORY in that it uses the memory as is, without duplicating the memory into its own buffers.  FMOD_SOFTWARE only.  Doesn't work with FMOD_HARDWARE, as sound hardware cannot access main ram on a lot of platforms.  Cannot be freed after open, only after Sound::release.   Will not work if the data is compressed and FMOD_CREATECOMPRESSEDSAMPLE is not used. */
        OPENRAW                = 0x00001000,  /* Will ignore file format and treat as raw pcm.  User may need to declare if data is FMOD_SIGNED or FMOD_UNSIGNED */
        OPENONLY               = 0x00002000,  /* Just open the file, dont prebuffer or read.  Good for fast opens for info, or when sound::readData is to be used. */
        ACCURATETIME           = 0x00004000,  /* For FMOD_CreateSound - for accurate FMOD_Sound_GetLength / FMOD_Channel_SetPosition on VBR MP3, AAC and MOD/S3M/XM/IT/MIDI files.  Scans file first, so takes longer to open. FMOD_OPENONLY does not affect this. */
        MPEGSEARCH             = 0x00008000,  /* For corrupted / bad MP3 files.  This will search all the way through the file until it hits a valid MPEG header.  Normally only searches for 4k. */
        NONBLOCKING            = 0x00010000,  /* For opening sounds and getting streamed subsounds (seeking) asyncronously.  Use Sound::getOpenState to poll the state of the sound as it opens or retrieves the subsound in the background. */
        UNIQUE                 = 0x00020000,  /* Unique sound, can only be played one at a time */
        _3D_HEADRELATIVE       = 0x00040000,  /* Make the sound's position, velocity and orientation relative to the listener. */
        _3D_WORLDRELATIVE      = 0x00080000,  /* Make the sound's position, velocity and orientation absolute (relative to the world). (DEFAULT) */
        _3D_LOGROLLOFF         = 0x00100000,  /* This sound will follow the standard logarithmic rolloff model where mindistance = full volume, maxdistance = where sound stops attenuating, and rolloff is fixed according to the global rolloff factor.  (default) */
        _3D_LINEARROLLOFF      = 0x00200000,  /* This sound will follow a linear rolloff model where mindistance = full volume, maxdistance = silence.  */
        _3D_CUSTOMROLLOFF      = 0x04000000,  /* This sound will follow a rolloff model defined by Sound::set3DCustomRolloff / Channel::set3DCustomRolloff.  */
        _3D_IGNOREGEOMETRY     = 0x40000000,  /* Is not affect by geometry occlusion.  If not specified in Sound::setMode, or Channel::setMode, the flag is cleared and it is affected by geometry again. */
        CDDA_FORCEASPI         = 0x00400000,  /* For CDDA sounds only - use ASPI instead of NTSCSI to access the specified CD/DVD device. */
        CDDA_JITTERCORRECT     = 0x00800000,  /* For CDDA sounds only - perform jitter correction. Jitter correction helps produce a more accurate CDDA stream at the cost of more CPU time. */
        UNICODE                = 0x01000000,  /* Filename is double-byte unicode. */
        IGNORETAGS             = 0x02000000,  /* Skips id3v2/asf/etc tag checks when opening a sound, to reduce seek/read overhead when opening files (helps with CD performance). */
        LOWMEM                 = 0x08000000,  /* Removes some features from samples to give a lower memory overhead, like Sound::getName. */
        LOADSECONDARYRAM       = 0x20000000,  /* Load sound into the secondary RAM of supported platform.  On PS3, sounds will be loaded into RSX/VRAM. */
        VIRTUAL_PLAYFROMSTART  = 0x80000000   /* For sounds that start virtual (due to being quiet or low importance), instead of swapping back to audible, and playing at the correct offset according to time, this flag makes the sound play from the start. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These values describe what state a sound is in after NONBLOCKING has been used to open it.

        [REMARKS]    

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        Sound::getOpenState
        MODE
    ]
    */
    public enum OPENSTATE
    {
        READY = 0,       /* Opened and ready to play */
        LOADING,         /* Initial load in progress */
        ERROR,           /* Failed to open - file not found, out of memory etc.  See return value of Sound::getOpenState for what happened. */
        CONNECTING,      /* Connecting to remote host (internet sounds only) */
        BUFFERING,       /* Buffering data */
        SEEKING,         /* Seeking to subsound and re-flushing stream buffer. */
        STREAMING,       /* Ready and playing, but not possible to release at this time without stalling the main thread. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These flags are used with SoundGroup::setMaxAudibleBehavior to determine what happens when more sounds 
        are played than are specified with SoundGroup::setMaxAudible.

        [REMARKS]
        When using FMOD_SOUNDGROUP_BEHAVIOR_MUTE, SoundGroup::setMuteFadeSpeed can be used to stop a sudden transition.  
        Instead, the time specified will be used to cross fade between the sounds that go silent and the ones that become audible.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        SoundGroup::setMaxAudibleBehavior
        SoundGroup::getMaxAudibleBehavior
        SoundGroup::setMaxAudible
        SoundGroup::getMaxAudible
        SoundGroup::setMuteFadeSpeed
        SoundGroup::getMuteFadeSpeed
    ]
    */
    public enum SOUNDGROUP_BEHAVIOR
    {
        BEHAVIOR_FAIL,              /* Any sound played that puts the sound count over the SoundGroup::setMaxAudible setting, will simply fail during System::playSound. */
        BEHAVIOR_MUTE,              /* Any sound played that puts the sound count over the SoundGroup::setMaxAudible setting, will be silent, then if another sound in the group stops the sound that was silent before becomes audible again. */
        BEHAVIOR_STEALLOWEST        /* Any sound played that puts the sound count over the SoundGroup::setMaxAudible setting, will steal the quietest / least important sound playing in the group. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These callback types are used with System::setCallback.

        [REMARKS]
        Each callback has commanddata parameters passed as int unique to the type of callback.&lt;br&gt;
        See reference to FMOD_SYSTEM_CALLBACK to determine what they might mean for each type of callback.&lt;br&gt;
        &lt;br&gt;
        &lt;b&gt;Note!&lt;/b&gt;  Currently the user must call System::update for these callbacks to trigger!

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii, Solaris

        [SEE_ALSO]      
        System::setCallback
        FMOD_SYSTEM_CALLBACK
        System::update
    ]
    */
    public enum SYSTEM_CALLBACKTYPE
    {
        DEVICELISTCHANGED,    /* Called when the enumerated list of devices has changed. */
        MEMORYALLOCATIONFAILED,    /* Called directly when a memory allocation fails somewhere in FMOD. */

        MAX                  /* Maximum number of callback types supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These callback types are used with Channel::setCallback.

        [REMARKS]
        Each callback has commanddata parameters passed int unique to the type of callback.
        See reference to FMOD_CHANNEL_CALLBACK to determine what they might mean for each type of callback.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Channel::setCallback
        FMOD_CHANNEL_CALLBACK
    ]
    */
    public enum CHANNEL_CALLBACKTYPE
    {
        END,                  /* Called when a sound ends. */
        VIRTUALVOICE,         /* Called when a voice is swapped out or swapped in. */
        SYNCPOINT,            /* Called when a syncpoint is encountered.  Can be from wav file markers. */
        OCCLUSION,            /* Called when the channel has its geometry occlusion value calculated.  Can be used to clamp or change the value. */

        MAX
    }


    /* 
        FMOD Callbacks
    */
    public delegate RESULT CHANNEL_CALLBACK      (IntPtr channelraw, CHANNEL_CALLBACKTYPE type, IntPtr commanddata1, IntPtr commanddata2);

    public delegate RESULT SOUND_NONBLOCKCALLBACK (IntPtr soundraw, RESULT result);
    public delegate RESULT SOUND_PCMREADCALLBACK  (IntPtr soundraw, IntPtr data, uint datalen);
    public delegate RESULT SOUND_PCMSETPOSCALLBACK(IntPtr soundraw, int subsound, uint position, TIMEUNIT postype);

    public delegate RESULT FILE_OPENCALLBACK     (string name, int unicode, ref uint filesize, ref IntPtr handle, ref IntPtr userdata);
    public delegate RESULT FILE_CLOSECALLBACK    (IntPtr handle, IntPtr userdata);
    public delegate RESULT FILE_READCALLBACK     (IntPtr handle, IntPtr buffer, uint sizebytes, ref uint bytesread, IntPtr userdata);
    public delegate RESULT FILE_SEEKCALLBACK     (IntPtr handle, int pos, IntPtr userdata);

    public delegate float  CB_3D_ROLLOFFCALLBACK    (IntPtr channelraw, float distance);

    /*
    [ENUM]
    [
        [DESCRIPTION]   
        List of windowing methods used in spectrum analysis to reduce leakage / transient signals intefering with the analysis.
        This is a problem with analysis of continuous signals that only have a small portion of the signal sample (the fft window size).
        Windowing the signal with a curve or triangle tapers the sides of the fft window to help alleviate this problem.

        [REMARKS]
        Cyclic signals such as a sine wave that repeat their cycle in a multiple of the window size do not need windowing.
        I.e. If the sine wave repeats every 1024, 512, 256 etc samples and the FMOD fft window is 1024, then the signal would not need windowing.
        Not windowing is the same as FMOD_DSP_FFT_WINDOW_RECT, which is the default.
        If the cycle of the signal (ie the sine wave) is not a multiple of the window size, it will cause frequency abnormalities, so a different windowing method is needed.
        &lt;exclude&gt;
        
        FMOD_DSP_FFT_WINDOW_RECT.
        &lt;img src = "rectangle.gif"&gt;&lt;/img&gt;
        
        FMOD_DSP_FFT_WINDOW_TRIANGLE.
        &lt;img src = "triangle.gif"&gt;&lt;/img&gt;
        
        FMOD_DSP_FFT_WINDOW_HAMMING.
        &lt;img src = "hamming.gif"&gt;&lt;/img&gt;
        
        FMOD_DSP_FFT_WINDOW_HANNING.
        &lt;img src = "hanning.gif"&gt;&lt;/img&gt;
        
        FMOD_DSP_FFT_WINDOW_BLACKMAN.
        &lt;img src = "blackman.gif"&gt;&lt;/img&gt;
        
        FMOD_DSP_FFT_WINDOW_BLACKMANHARRIS.
        &lt;img src = "blackmanharris.gif"&gt;&lt;/img&gt;
        &lt;/exclude&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        System::getSpectrum
        Channel::getSpectrum
    ]
    */
    public enum DSP_FFT_WINDOW
    {
        RECT,           /* w[n] = 1.0                                                                                            */
        TRIANGLE,       /* w[n] = TRI(2n/N)                                                                                      */
        HAMMING,        /* w[n] = 0.54 - (0.46 * COS(n/N) )                                                                      */
        HANNING,        /* w[n] = 0.5 *  (1.0  - COS(n/N) )                                                                      */
        BLACKMAN,       /* w[n] = 0.42 - (0.5  * COS(n/N) ) + (0.08 * COS(2.0 * n/N) )                                           */
        BLACKMANHARRIS, /* w[n] = 0.35875 - (0.48829 * COS(1.0 * n/N)) + (0.14128 * COS(2.0 * n/N)) - (0.01168 * COS(3.0 * n/N)) */

        MAX
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        List of interpolation types that the FMOD Ex software mixer supports.  

        [REMARKS]
        The default resampler type is FMOD_DSP_RESAMPLER_LINEAR.&lt;br&gt;
        Use System::setSoftwareFormat to tell FMOD the resampling quality you require for FMOD_SOFTWARE based sounds.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        System::setSoftwareFormat
        System::getSoftwareFormat
    ]
    */
    public enum DSP_RESAMPLER
    {
        NOINTERP,        /* No interpolation.  High frequency aliasing hiss will be audible depending on the sample rate of the sound. */
        LINEAR,          /* Linear interpolation (default method).  Fast and good quality, causes very slight lowpass effect on low frequency sounds. */
        CUBIC,           /* Cubic interoplation.  Slower than linear interpolation but better quality. */
        SPLINE,          /* 5 point spline interoplation.  Slowest resampling method but best quality. */

        MAX,             /* Maximum number of resample methods supported. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        List of tag types that could be stored within a sound.  These include id3 tags, metadata from netstreams and vorbis/asf data.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Sound::getTag
    ]
    */
    public enum TAGTYPE
    {
        UNKNOWN = 0,
        ID3V1,
        ID3V2,
        VORBISCOMMENT,
        SHOUTCAST,
        ICECAST,
        ASF,
        MIDI,
        PLAYLIST,
        FMOD,
        USER
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        List of data types that can be returned by Sound::getTag

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Sound::getTag
    ]
    */
    public enum TAGDATATYPE
    {
        BINARY = 0,
        INT,
        FLOAT,
        STRING,
        STRING_UTF16,
        STRING_UTF16BE,
        STRING_UTF8,
        CDTOC
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]   
        Types of delay that can be used with Channel::setDelay / Channel::getDelay.

        [REMARKS]
        If you haven't called Channel::setDelay yet, if you call Channel::getDelay with FMOD_DELAYTYPE_DSPCLOCK_START it will return the 
        equivalent global DSP clock value to determine when a channel started, so that you can use it for other channels to sync against.&lt;br&gt;
        &lt;br&gt;
        Use System::getDSPClock to also get the current dspclock time, a base for future calls to Channel::setDelay.&lt;br&gt;
        &lt;br&gt;
        Use FMOD_64BIT_ADD or FMOD_64BIT_SUB to add a hi/lo combination together and cope with wraparound.
        &lt;br&gt;
        If FMOD_DELAYTYPE_END_MS is specified, the value is not treated as a 64 bit number, just the delayhi value is used and it is treated as milliseconds.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii, Solaris

        [SEE_ALSO]      
        Channel::setDelay
        Channel::getDelay
        System::getDSPClock
    ]
    */
    public enum DELAYTYPE
    {
        END_MS,              /* Delay at the end of the sound in milliseconds.  Use delayhi only.   Channel::isPlaying will remain true until this delay has passed even though the sound itself has stopped playing.*/
        DSPCLOCK_START,      /* Time the sound started if Channel::getDelay is used, or if Channel::setDelay is used, the sound will delay playing until this exact tick. */
        DSPCLOCK_END,        /* Time the sound should end. If this is non-zero, the channel will go silent at this exact tick. */

        MAX                 /* Maximum number of tag datatypes supported. */
    }

    public class DELAYTYPE_UTILITY
    {
        void FMOD_64BIT_ADD(ref uint hi1, ref uint lo1, uint hi2, uint lo2)
        {
            hi1 += (uint)((hi2) + ((((lo1) + (lo2)) &lt; (lo1)) ? 1 : 0));
            lo1 += (lo2);
        }

        void FMOD_64BIT_SUB(ref uint hi1, ref uint lo1, uint hi2, uint lo2)
        {
            hi1 -= (uint)((hi2) + ((((lo1) - (lo2)) &gt; (lo1)) ? 1 : 0));
            lo1 -= (lo2);
        }
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]   
        Structure describing a piece of tag data.

        [REMARKS]
        Members marked with [in] mean the user sets the value before passing it to the function.
        Members marked with [out] mean FMOD sets the value to be used after the function exits.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Sound::getTag
        TAGTYPE
        TAGDATATYPE
    ]
    */
    [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Ansi)]
    public struct TAG
    {
        public TAGTYPE           type;         /* [out] The type of this tag. */
        public TAGDATATYPE       datatype;     /* [out] The type of data that this tag contains */
        public string            name;         /* [out] The name of this tag i.e. "TITLE", "ARTIST" etc. */
        public IntPtr            data;         /* [out] Pointer to the tag data - its format is determined by the datatype member */
        public uint              datalen;      /* [out] Length of the data contained in this tag */
        public bool              updated;      /* [out] True if this tag has been updated since last being accessed with Sound::getTag */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]   
        Structure describing a CD/DVD table of contents

        [REMARKS]
        Members marked with [in] mean the user sets the value before passing it to the function.
        Members marked with [out] mean FMOD sets the value to be used after the function exits.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Sound::getTag
    ]
    */
    public struct CDTOC
    {
        public int numtracks;                  /* [out] The number of tracks on the CD */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=100)]
        public int[] min;                   /* [out] The start offset of each track in minutes */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=100)]
        public int[] sec;                   /* [out] The start offset of each track in seconds */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=100)]
        public int[] frame;                 /* [out] The start offset of each track in frames */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        List of time types that can be returned by Sound::getLength and used with Channel::setPosition or Channel::getPosition.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        Sound::getLength
        Channel::setPosition
        Channel::getPosition
    ]
    */
    public enum TIMEUNIT
    {
        MS                = 0x00000001,  /* Milliseconds. */
        PCM               = 0x00000002,  /* PCM Samples, related to milliseconds * samplerate / 1000. */
        PCMBYTES          = 0x00000004,  /* Bytes, related to PCM samples * channels * datawidth (ie 16bit = 2 bytes). */
        RAWBYTES          = 0x00000008,  /* Raw file bytes of (compressed) sound data (does not include headers).  Only used by Sound::getLength and Channel::getPosition. */
        MODORDER          = 0x00000100,  /* MOD/S3M/XM/IT.  Order in a sequenced module format.  Use Sound::getFormat to determine the format. */
        MODROW            = 0x00000200,  /* MOD/S3M/XM/IT.  Current row in a sequenced module format.  Sound::getLength will return the number if rows in the currently playing or seeked to pattern. */
        MODPATTERN        = 0x00000400,  /* MOD/S3M/XM/IT.  Current pattern in a sequenced module format.  Sound::getLength will return the number of patterns in the song and Channel::getPosition will return the currently playing pattern. */
        SENTENCE_MS       = 0x00010000,  /* Currently playing subsound in a sentence time in milliseconds. */
        SENTENCE_PCM      = 0x00020000,  /* Currently playing subsound in a sentence time in PCM Samples, related to milliseconds * samplerate / 1000. */
        SENTENCE_PCMBYTES = 0x00040000,  /* Currently playing subsound in a sentence time in bytes, related to PCM samples * channels * datawidth (ie 16bit = 2 bytes). */
        SENTENCE          = 0x00080000,  /* Currently playing sentence index according to the channel. */
        SENTENCE_SUBSOUND = 0x00100000,  /* Currently playing subsound index in a sentence. */
        BUFFERED          = 0x10000000,  /* Time value as seen by buffered stream.  This is always ahead of audible time, and is only used for processing. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        When creating a multichannel sound, FMOD will pan them to their default speaker locations, for example a 6 channel sound will default to one channel per 5.1 output speaker.&lt;br&gt;
        Another example is a stereo sound.  It will default to left = front left, right = front right.&lt;br&gt;
        &lt;br&gt;
        This is for sounds that are not 'default'.  For example you might have a sound that is 6 channels but actually made up of 3 stereo pairs, that should all be located in front left, front right only.

        [REMARKS]
        For full flexibility of speaker assignments, use Channel::setSpeakerLevels.  This functionality is cheaper, uses less memory and easier to use.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        FMOD_CREATESOUNDEXINFO
        Channel::setSpeakerLevels
    ]
    */
    public enum SPEAKERMAPTYPE
    {
        DEFAULT,     /* This is the default, and just means FMOD decides which speakers it puts the source channels. */
        ALLMONO,     /* This means the sound is made up of all mono sounds.  All voices will be panned to the front center by default in this case.  */
        ALLSTEREO    /* This means the sound is made up of all stereo sounds.  All voices will be panned to front left and front right alternating every second channel.  */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Use this structure with System::createSound when more control is needed over loading.
        The possible reasons to use this with System::createSound are:
        &lt;li&gt;Loading a file from memory.
        &lt;li&gt;Loading a file from within another larger (possibly wad/pak) file, by giving the loader an offset and length.
        &lt;li&gt;To create a user created / non file based sound.
        &lt;li&gt;To specify a starting subsound to seek to within a multi-sample sounds (ie FSB/DLS/SF2) when created as a stream.
        &lt;li&gt;To specify which subsounds to load for multi-sample sounds (ie FSB/DLS/SF2) so that memory is saved and only a subset is actually loaded/read from disk.
        &lt;li&gt;To specify 'piggyback' read and seek callbacks for capture of sound data as fmod reads and decodes it.  Useful for ripping decoded PCM data from sounds as they are loaded / played.
        &lt;li&gt;To specify a MIDI DLS/SF2 sample set file to load when opening a MIDI file.
        See below on what members to fill for each of the above types of sound you want to create.

        [REMARKS]
        This structure is optional!  Specify 0 or NULL in System::createSound if you don't need it!
        
        Members marked with [in] mean the user sets the value before passing it to the function.
        Members marked with [out] mean FMOD sets the value to be used after the function exits.
        
        &lt;u&gt;Loading a file from memory.&lt;/u&gt;
        &lt;li&gt;Create the sound using the FMOD_OPENMEMORY flag.
        &lt;li&gt;Mandantory.  Specify 'length' for the size of the memory block in bytes.
        &lt;li&gt;Other flags are optional.
        
        
        &lt;u&gt;Loading a file from within another larger (possibly wad/pak) file, by giving the loader an offset and length.&lt;/u&gt;
        &lt;li&gt;Mandantory.  Specify 'fileoffset' and 'length'.
        &lt;li&gt;Other flags are optional.
        
        
        &lt;u&gt;To create a user created / non file based sound.&lt;/u&gt;
        &lt;li&gt;Create the sound using the FMOD_OPENUSER flag.
        &lt;li&gt;Mandantory.  Specify 'defaultfrequency, 'numchannels' and 'format'.
        &lt;li&gt;Other flags are optional.
        
        
        &lt;u&gt;To specify a starting subsound to seek to and flush with, within a multi-sample stream (ie FSB/DLS/SF2).&lt;/u&gt;
        
        &lt;li&gt;Mandantory.  Specify 'initialsubsound'.
        
        
        &lt;u&gt;To specify which subsounds to load for multi-sample sounds (ie FSB/DLS/SF2) so that memory is saved and only a subset is actually loaded/read from disk.&lt;/u&gt;
        
        &lt;li&gt;Mandantory.  Specify 'inclusionlist' and 'inclusionlistnum'.
        
        
        &lt;u&gt;To specify 'piggyback' read and seek callbacks for capture of sound data as fmod reads and decodes it.  Useful for ripping decoded PCM data from sounds as they are loaded / played.&lt;/u&gt;
        
        &lt;li&gt;Mandantory.  Specify 'pcmreadcallback' and 'pcmseekcallback'.
        
        
        &lt;u&gt;To specify a MIDI DLS/SF2 sample set file to load when opening a MIDI file.&lt;/u&gt;
        
        &lt;li&gt;Mandantory.  Specify 'dlsname'.
        
        
        Setting the 'decodebuffersize' is for cpu intensive codecs that may be causing stuttering, not file intensive codecs (ie those from CD or netstreams) which are normally altered with System::setStreamBufferSize.  As an example of cpu intensive codecs, an mp3 file will take more cpu to decode than a PCM wav file.
        If you have a stuttering effect, then it is using more cpu than the decode buffer playback rate can keep up with.  Increasing the decode buffersize will most likely solve this problem.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::createSound
        System::setStreamBufferSize
        FMOD_MODE
    ]
    */
    public struct CREATESOUNDEXINFO
    {
        public int                         cbsize;                 /* [in] Size of this structure.  This is used so the structure can be expanded in the future and still work on older versions of FMOD Ex. */
        public uint                        length;                 /* [in] Optional. Specify 0 to ignore. Size in bytes of file to load, or sound to create (in this case only if FMOD_OPENUSER is used).  Required if loading from memory.  If 0 is specified, then it will use the size of the file (unless loading from memory then an error will be returned). */
        public uint                        fileoffset;             /* [in] Optional. Specify 0 to ignore. Offset from start of the file to start loading from.  This is useful for loading files from inside big data files. */
        public int                         numchannels;            /* [in] Optional. Specify 0 to ignore. Number of channels in a sound specified only if OPENUSER is used. */
        public int                         defaultfrequency;       /* [in] Optional. Specify 0 to ignore. Default frequency of sound in a sound specified only if OPENUSER is used.  Other formats use the frequency determined by the file format. */
        public SOUND_FORMAT                format;                 /* [in] Optional. Specify 0 or SOUND_FORMAT_NONE to ignore. Format of the sound specified only if OPENUSER is used.  Other formats use the format determined by the file format.   */
        public uint                        decodebuffersize;       /* [in] Optional. Specify 0 to ignore. For streams.  This determines the size of the double buffer (in PCM samples) that a stream uses.  Use this for user created streams if you want to determine the size of the callback buffer passed to you.  Specify 0 to use FMOD's default size which is currently equivalent to 400ms of the sound format created/loaded. */
        public int                         initialsubsound;        /* [in] Optional. Specify 0 to ignore. In a multi-sample file format such as .FSB/.DLS/.SF2, specify the initial subsound to seek to, only if CREATESTREAM is used. */
        public int                         numsubsounds;           /* [in] Optional. Specify 0 to ignore or have no subsounds.  In a user created multi-sample sound, specify the number of subsounds within the sound that are accessable with Sound::getSubSound / SoundGetSubSound. */
        public IntPtr                      inclusionlist;          /* [in] Optional. Specify 0 to ignore. In a multi-sample format such as .FSB/.DLS/.SF2 it may be desirable to specify only a subset of sounds to be loaded out of the whole file.  This is an array of subsound indicies to load into memory when created. */
        public int                         inclusionlistnum;       /* [in] Optional. Specify 0 to ignore. This is the number of integers contained within the */
        public SOUND_PCMREADCALLBACK       pcmreadcallback;        /* [in] Optional. Specify 0 to ignore. Callback to 'piggyback' on FMOD's read functions and accept or even write PCM data while FMOD is opening the sound.  Used for user sounds created with OPENUSER or for capturing decoded data as FMOD reads it. */
        public SOUND_PCMSETPOSCALLBACK     pcmsetposcallback;      /* [in] Optional. Specify 0 to ignore. Callback for when the user calls a seeking function such as Channel::setPosition within a multi-sample sound, and for when it is opened.*/
        public SOUND_NONBLOCKCALLBACK      nonblockcallback;       /* [in] Optional. Specify 0 to ignore. Callback for successful completion, or error while loading a sound that used the FMOD_NONBLOCKING flag.*/
        public string                      dlsname;                /* [in] Optional. Specify 0 to ignore. Filename for a DLS or SF2 sample set when loading a MIDI file.   If not specified, on windows it will attempt to open /windows/system32/drivers/gm.dls, otherwise the MIDI will fail to open.  */
        public string                      encryptionkey;          /* [in] Optional. Specify 0 to ignore. Key for encrypted FSB file.  Without this key an encrypted FSB file will not load. */
        public int                         maxpolyphony;           /* [in] Optional. Specify 0 to ingore. For sequenced formats with dynamic channel allocation such as .MID and .IT, this specifies the maximum voice count allowed while playing.  .IT defaults to 64.  .MID defaults to 32. */
        public IntPtr                      userdata;               /* [in] Optional. Specify 0 to ignore. This is user data to be attached to the sound during creation.  Access via Sound::getUserData. */
        public SOUND_TYPE                  suggestedsoundtype;     /* [in] Optional. Specify 0 or FMOD_SOUND_TYPE_UNKNOWN to ignore.  Instead of scanning all codec types, use this to speed up loading by making it jump straight to this codec. */
        public FILE_OPENCALLBACK           useropen;               /* [in] Optional. Specify 0 to ignore. Callback for opening this file. */
        public FILE_CLOSECALLBACK          userclose;              /* [in] Optional. Specify 0 to ignore. Callback for closing this file. */
        public FILE_READCALLBACK           userread;               /* [in] Optional. Specify 0 to ignore. Callback for reading from this file. */
        public FILE_SEEKCALLBACK           userseek;               /* [in] Optional. Specify 0 to ignore. Callback for seeking within this file. */
        public SPEAKERMAPTYPE              speakermap;             /* [in] Optional. Specify 0 to ignore. Use this to differ the way fmod maps multichannel sounds to speakers.  See FMOD_SPEAKERMAPTYPE for more. */
        public IntPtr                      initialsoundgroup;      /* [in] Optional. Specify 0 to ignore. Specify a sound group if required, to put sound in as it is created. */
        public uint                        initialseekposition;    /* [in] Optional. Specify 0 to ignore. For streams. Specify an initial position to seek the stream to. */
        public TIMEUNIT                    initialseekpostype;     /* [in] Optional. Specify 0 to ignore. For streams. Specify the time unit for the position set in initialseekposition. */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure defining a reverb environment.&lt;br&gt;
        &lt;br&gt;
        For more indepth descriptions of the reverb properties under win32, please see the EAX2 and EAX3
        documentation at http://developer.creative.com/ under the 'downloads' section.&lt;br&gt;
        If they do not have the EAX3 documentation, then most information can be attained from
        the EAX2 documentation, as EAX3 only adds some more parameters and functionality on top of 
        EAX2.

        [REMARKS]
        Note the default reverb properties are the same as the FMOD_PRESET_GENERIC preset.&lt;br&gt;
        Note that integer values that typically range from -10,000 to 1000 are represented in 
        decibels, and are of a logarithmic scale, not linear, wheras float values are always linear.&lt;br&gt;
        &lt;br&gt;
        The numerical values listed below are the maximum, minimum and default values for each variable respectively.&lt;br&gt;
        &lt;br&gt;
        &lt;b&gt;SUPPORTED&lt;/b&gt; next to each parameter means the platform the parameter can be set on.  Some platforms support all parameters and some don't.&lt;br&gt;
        EAX   means hardware reverb on FMOD_OUTPUTTYPE_DSOUND on windows only (must use FMOD_HARDWARE), on soundcards that support EAX 1 to 4.&lt;br&gt;
        EAX4  means hardware reverb on FMOD_OUTPUTTYPE_DSOUND on windows only (must use FMOD_HARDWARE), on soundcards that support EAX 4.&lt;br&gt;
        I3DL2 means hardware reverb on FMOD_OUTPUTTYPE_DSOUND on windows only (must use FMOD_HARDWARE), on soundcards that support I3DL2 non EAX native reverb.&lt;br&gt;
        GC    means Nintendo Gamecube hardware reverb (must use FMOD_HARDWARE).&lt;br&gt;
        WII   means Nintendo Wii hardware reverb (must use FMOD_HARDWARE).&lt;br&gt;
        Xbox1 means the original Xbox hardware reverb (must use FMOD_HARDWARE).&lt;br&gt;
        PS2   means Playstation 2 hardware reverb (must use FMOD_HARDWARE).&lt;br&gt;
        SFX   means FMOD SFX software reverb.  This works on any platform that uses FMOD_SOFTWARE for loading sounds.&lt;br&gt;
        &lt;br&gt;
        Members marked with [in] mean the user sets the value before passing it to the function.&lt;br&gt;
        Members marked with [out] mean FMOD sets the value to be used after the function exits.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::setReverbProperties
        System::getReverbProperties
        FMOD_REVERB_PRESETS
        FMOD_REVERB_FLAGS
    ]
    */
    public class REVERB_PROPERTIES
    {                                   /*          MIN     MAX    DEFAULT   DESCRIPTION */
        public int   Instance;          /* [in]     0     , 2     , 0      , EAX4 only. Environment Instance. 3 seperate reverbs simultaneously are possible. This specifies which one to set. (win32 only) */
        public uint  Environment;       /* [in/out] 0     , 25    , 0      , sets all listener properties (win32/ps2) */
        public float EnvSize;           /* [in/out] 1.0   , 100.0 , 7.5    , environment size in meters (win32 only) */
        public float EnvDiffusion;      /* [in/out] 0.0   , 1.0   , 1.0    , environment diffusion (win32/xbox) */
        public int   Room;              /* [in/out] -10000, 0     , -1000  , room effect level (at mid frequencies) (win32/xbox) */
        public int   RoomHF;            /* [in/out] -10000, 0     , -100   , relative room effect level at high frequencies (win32/xbox) */
        public int   RoomLF;            /* [in/out] -10000, 0     , 0      , relative room effect level at low frequencies (win32 only) */
        public float DecayTime;         /* [in/out] 0.1   , 20.0  , 1.49   , reverberation decay time at mid frequencies (win32/xbox) */
        public float DecayHFRatio;      /* [in/out] 0.1   , 2.0   , 0.83   , high-frequency to mid-frequency decay time ratio (win32/xbox) */
        public float DecayLFRatio;      /* [in/out] 0.1   , 2.0   , 1.0    , low-frequency to mid-frequency decay time ratio (win32 only) */
        public int   Reflections;       /* [in/out] -10000, 1000  , -2602  , early reflections level relative to room effect (win32/xbox) */
        public float ReflectionsDelay;  /* [in/out] 0.0   , 0.3   , 0.007  , initial reflection delay time (win32/xbox) */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=3)]
        public float[] ReflectionsPan;  /* [in/out]       ,       , [0,0,0], early reflections panning vector (win32 only) */
        public int   Reverb;            /* [in/out] -10000, 2000  , 200    , late reverberation level relative to room effect (win32/xbox) */
        public float ReverbDelay;       /* [in/out] 0.0   , 0.1   , 0.011  , late reverberation delay time relative to initial reflection (win32/xbox) */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=3)]
        public float[] ReverbPan;       /* [in/out]       ,       , [0,0,0], late reverberation panning vector (win32 only) */
        public float EchoTime;          /* [in/out] .075  , 0.25  , 0.25   , echo time (win32 only) */
        public float EchoDepth;         /* [in/out] 0.0   , 1.0   , 0.0    , echo depth (win32 only) */
        public float ModulationTime;    /* [in/out] 0.04  , 4.0   , 0.25   , modulation time (win32 only) */
        public float ModulationDepth;   /* [in/out] 0.0   , 1.0   , 0.0    , modulation depth (win32 only) */
        public float AirAbsorptionHF;   /* [in/out] -100  , 0.0   , -5.0   , change in level per meter at high frequencies (win32 only) */
        public float HFReference;       /* [in/out] 1000.0, 20000 , 5000.0 , reference high frequency (hz) (win32/xbox) */
        public float LFReference;       /* [in/out] 20.0  , 1000.0, 250.0  , reference low frequency (hz) (win32 only) */
        public float RoomRolloffFactor; /* [in/out] 0.0   , 10.0  , 0.0    , like rolloffscale in System::set3DSettings but for reverb room size effect (win32/Xbox) */
        public float Diffusion;         /* [in/out] 0.0   , 100.0 , 100.0  , Value that controls the echo density in the late reverberation decay. (xbox only) */
        public float Density;           /* [in/out] 0.0   , 100.0 , 100.0  , Value that controls the modal density in the late reverberation decay (xbox only) */
        public uint  Flags;             /* [in/out] REVERB_FLAGS - modifies the behavior of above properties (win32/ps2) */

        #region wrapperinternal
        public REVERB_PROPERTIES(int instance, uint environment, float envSize, float envDiffusion, int room, int roomHF, int roomLF,
            float decayTime, float decayHFRatio, float decayLFRatio, int reflections, float reflectionsDelay,
            float reflectionsPanx, float reflectionsPany, float reflectionsPanz, int reverb, float reverbDelay,
            float reverbPanx, float reverbPany, float reverbPanz, float echoTime, float echoDepth, float modulationTime,
            float modulationDepth, float airAbsorptionHF, float hfReference, float lfReference, float roomRolloffFactor,
            float diffusion, float density, uint flags)
        {
            ReflectionsPan      = new float[3];
            ReverbPan           = new float[3];

            Instance            = instance;
            Environment         = environment;
            EnvSize             = envSize;
            EnvDiffusion        = envDiffusion;
            Room                = room;
            RoomHF              = roomHF;
            RoomLF              = roomLF;
            DecayTime           = decayTime;
            DecayHFRatio        = decayHFRatio;
            DecayLFRatio        = decayLFRatio;
            Reflections         = reflections;
            ReflectionsDelay    = reflectionsDelay;
            ReflectionsPan[0]   = reflectionsPanx;
            ReflectionsPan[1]   = reflectionsPany;
            ReflectionsPan[2]   = reflectionsPanz;
            Reverb              = reverb;
            ReverbDelay          = reverbDelay;
            ReverbPan[0]        = reverbPanx;
            ReverbPan[1]        = reverbPany;
            ReverbPan[2]        = reverbPanz;
            EchoTime            = echoTime;
            EchoDepth           = echoDepth;
            ModulationTime      = modulationTime;
            ModulationDepth     = modulationDepth;
            AirAbsorptionHF     = airAbsorptionHF;
            HFReference         = hfReference;
            LFReference         = lfReference;
            RoomRolloffFactor   = roomRolloffFactor;
            Diffusion           = diffusion;
            Density             = density;
            Flags               = flags;
        }
        #endregion
    }


    /*
    [DEFINE] 
    [
        [NAME] 
        REVERB_FLAGS

        [DESCRIPTION]
        Values for the Flags member of the REVERB_PROPERTIES structure.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        REVERB_PROPERTIES
    ]
    */
    public class REVERB_FLAGS
    {
        public const uint DECAYTIMESCALE        = 0x00000001;   /* 'EnvSize' affects reverberation decay time */
        public const uint REFLECTIONSSCALE      = 0x00000002;   /* 'EnvSize' affects reflection level */
        public const uint REFLECTIONSDELAYSCALE = 0x00000004;   /* 'EnvSize' affects initial reflection delay time */
        public const uint REVERBSCALE           = 0x00000008;   /* 'EnvSize' affects reflections level */
        public const uint REVERBDELAYSCALE      = 0x00000010;   /* 'EnvSize' affects late reverberation delay time */
        public const uint DECAYHFLIMIT          = 0x00000020;   /* AirAbsorptionHF affects DecayHFRatio */
        public const uint ECHOTIMESCALE         = 0x00000040;   /* 'EnvSize' affects echo time */
        public const uint MODULATIONTIMESCALE   = 0x00000080;   /* 'EnvSize' affects modulation time */
        public const uint DEFAULT               = (DECAYTIMESCALE | 
            REFLECTIONSSCALE | 
            REFLECTIONSDELAYSCALE | 
            REVERBSCALE | 
            REVERBDELAYSCALE | 
            DECAYHFLIMIT);
    }


    /*
    [DEFINE] 
    [
    [NAME] 
    FMOD_REVERB_PRESETS

    [DESCRIPTION]   
    A set of predefined environment PARAMETERS, created by Creative Labs
    These are used to initialize an FMOD_REVERB_PROPERTIES structure statically.
    ie 
    FMOD_REVERB_PROPERTIES prop = FMOD_PRESET_GENERIC;

    [PLATFORMS]
    Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

    [SEE_ALSO]
    System::setReverbProperties
    ]
    */
    class PRESET
    {
        /*                                                                           Instance  Env   Size    Diffus  Room   RoomHF  RmLF DecTm   DecHF  DecLF   Refl  RefDel  RefPan           Revb  RevDel  ReverbPan       EchoTm  EchDp  ModTm  ModDp  AirAbs  HFRef    LFRef  RRlOff Diffus  Densty  FLAGS */
        public REVERB_PROPERTIES OFF()                 { return new REVERB_PROPERTIES(0,       0,    7.5f,   1.00f, -10000, -10000, 0,   1.00f,  1.00f, 1.0f,  -2602, 0.007f, 0.0f,0.0f,0.0f,   200, 0.011f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f,   0.0f,   0.0f, 0x3f );}
        public REVERB_PROPERTIES GENERIC()             { return new REVERB_PROPERTIES(0,       0,    7.5f,   1.00f, -1000,  -100,   0,   1.49f,  0.83f, 1.0f,  -2602, 0.007f, 0.0f,0.0f,0.0f,   200, 0.011f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES PADDEDCELL()          { return new REVERB_PROPERTIES(0,       1,    1.4f,   1.00f, -1000,  -6000,  0,   0.17f,  0.10f, 1.0f,  -1204, 0.001f, 0.0f,0.0f,0.0f,   207, 0.002f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES ROOM()                { return new REVERB_PROPERTIES(0,       2,    1.9f,   1.00f, -1000,  -454,   0,   0.40f,  0.83f, 1.0f,  -1646, 0.002f, 0.0f,0.0f,0.0f,    53, 0.003f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES BATHROOM()            { return new REVERB_PROPERTIES(0,       3,    1.4f,   1.00f, -1000,  -1200,  0,   1.49f,  0.54f, 1.0f,   -370, 0.007f, 0.0f,0.0f,0.0f,  1030, 0.011f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f,  60.0f, 0x3f );}
        public REVERB_PROPERTIES LIVINGROOM()          { return new REVERB_PROPERTIES(0,       4,    2.5f,   1.00f, -1000,  -6000,  0,   0.50f,  0.10f, 1.0f,  -1376, 0.003f, 0.0f,0.0f,0.0f, -1104, 0.004f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES STONEROOM()           { return new REVERB_PROPERTIES(0,       5,    11.6f,  1.00f, -1000,  -300,   0,   2.31f,  0.64f, 1.0f,   -711, 0.012f, 0.0f,0.0f,0.0f,    83, 0.017f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES AUDITORIUM()          { return new REVERB_PROPERTIES(0,       6,    21.6f,  1.00f, -1000,  -476,   0,   4.32f,  0.59f, 1.0f,   -789, 0.020f, 0.0f,0.0f,0.0f,  -289, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES CONCERTHALL()         { return new REVERB_PROPERTIES(0,       7,    19.6f,  1.00f, -1000,  -500,   0,   3.92f,  0.70f, 1.0f,  -1230, 0.020f, 0.0f,0.0f,0.0f,    -2, 0.029f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES CAVE()                { return new REVERB_PROPERTIES(0,       8,    14.6f,  1.00f, -1000,  0,      0,   2.91f,  1.30f, 1.0f,   -602, 0.015f, 0.0f,0.0f,0.0f,  -302, 0.022f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x1f );}
        public REVERB_PROPERTIES ARENA()               { return new REVERB_PROPERTIES(0,       9,    36.2f,  1.00f, -1000,  -698,   0,   7.24f,  0.33f, 1.0f,  -1166, 0.020f, 0.0f,0.0f,0.0f,    16, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES HANGAR()              { return new REVERB_PROPERTIES(0,       10,   50.3f,  1.00f, -1000,  -1000,  0,   10.05f, 0.23f, 1.0f,   -602, 0.020f, 0.0f,0.0f,0.0f,   198, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES CARPETTEDHALLWAY()    { return new REVERB_PROPERTIES(0,       11,   1.9f,   1.00f, -1000,  -4000,  0,   0.30f,  0.10f, 1.0f,  -1831, 0.002f, 0.0f,0.0f,0.0f, -1630, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES HALLWAY()             { return new REVERB_PROPERTIES(0,       12,   1.8f,   1.00f, -1000,  -300,   0,   1.49f,  0.59f, 1.0f,  -1219, 0.007f, 0.0f,0.0f,0.0f,   441, 0.011f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES STONECORRIDOR()       { return new REVERB_PROPERTIES(0,       13,   13.5f,  1.00f, -1000,  -237,   0,   2.70f,  0.79f, 1.0f,  -1214, 0.013f, 0.0f,0.0f,0.0f,   395, 0.020f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES ALLEY()               { return new REVERB_PROPERTIES(0,       14,   7.5f,   0.30f, -1000,  -270,   0,   1.49f,  0.86f, 1.0f,  -1204, 0.007f, 0.0f,0.0f,0.0f,    -4, 0.011f, 0.0f,0.0f,0.0f, 0.125f, 0.95f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES FOREST()              { return new REVERB_PROPERTIES(0,       15,   38.0f,  0.30f, -1000,  -3300,  0,   1.49f,  0.54f, 1.0f,  -2560, 0.162f, 0.0f,0.0f,0.0f,  -229, 0.088f, 0.0f,0.0f,0.0f, 0.125f, 1.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f,  79.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES CITY()                { return new REVERB_PROPERTIES(0,       16,   7.5f,   0.50f, -1000,  -800,   0,   1.49f,  0.67f, 1.0f,  -2273, 0.007f, 0.0f,0.0f,0.0f, -1691, 0.011f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f,  50.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES MOUNTAINS()           { return new REVERB_PROPERTIES(0,       17,   100.0f, 0.27f, -1000,  -2500,  0,   1.49f,  0.21f, 1.0f,  -2780, 0.300f, 0.0f,0.0f,0.0f, -1434, 0.100f, 0.0f,0.0f,0.0f, 0.250f, 1.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f,  27.0f, 100.0f, 0x1f );}
        public REVERB_PROPERTIES QUARRY()              { return new REVERB_PROPERTIES(0,       18,   17.5f,  1.00f, -1000,  -1000,  0,   1.49f,  0.83f, 1.0f, -10000, 0.061f, 0.0f,0.0f,0.0f,   500, 0.025f, 0.0f,0.0f,0.0f, 0.125f, 0.70f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES PLAIN()               { return new REVERB_PROPERTIES(0,       19,   42.5f,  0.21f, -1000,  -2000,  0,   1.49f,  0.50f, 1.0f,  -2466, 0.179f, 0.0f,0.0f,0.0f, -1926, 0.100f, 0.0f,0.0f,0.0f, 0.250f, 1.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f,  21.0f, 100.0f, 0x3f );}
        public REVERB_PROPERTIES PARKINGLOT()          { return new REVERB_PROPERTIES(0,       20,   8.3f,   1.00f, -1000,  0,      0,   1.65f,  1.50f, 1.0f,  -1363, 0.008f, 0.0f,0.0f,0.0f, -1153, 0.012f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x1f );}
        public REVERB_PROPERTIES SEWERPIPE()           { return new REVERB_PROPERTIES(0,       21,   1.7f,   0.80f, -1000,  -1000,  0,   2.81f,  0.14f, 1.0f,    429, 0.014f, 0.0f,0.0f,0.0f,  1023, 0.021f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 0.000f, -5.0f, 5000.0f, 250.0f, 0.0f,  80.0f,  60.0f, 0x3f );}
        public REVERB_PROPERTIES UNDERWATER()          { return new REVERB_PROPERTIES(0,       22,   1.8f,   1.00f, -1000,  -4000,  0,   1.49f,  0.10f, 1.0f,   -449, 0.007f, 0.0f,0.0f,0.0f,  1700, 0.011f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 1.18f, 0.348f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x3f );}

        /* Non I3DL2 presets */

        public REVERB_PROPERTIES DRUGGED()             { return new REVERB_PROPERTIES(0,       23,   1.9f,   0.50f, -1000,  0,      0,   8.39f,  1.39f, 1.0f,  -115,  0.002f, 0.0f,0.0f,0.0f,   985, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 0.25f, 1.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x1f );}
        public REVERB_PROPERTIES DIZZY()               { return new REVERB_PROPERTIES(0,       24,   1.8f,   0.60f, -1000,  -400,   0,   17.23f, 0.56f, 1.0f,  -1713, 0.020f, 0.0f,0.0f,0.0f,  -613, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 1.00f, 0.81f, 0.310f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x1f );}
        public REVERB_PROPERTIES PSYCHOTIC()           { return new REVERB_PROPERTIES(0,       25,   1.0f,   0.50f, -1000,  -151,   0,   7.56f,  0.91f, 1.0f,  -626,  0.020f, 0.0f,0.0f,0.0f,   774, 0.030f, 0.0f,0.0f,0.0f, 0.250f, 0.00f, 4.00f, 1.000f, -5.0f, 5000.0f, 250.0f, 0.0f, 100.0f, 100.0f, 0x1f );}

        /* PlayStation 2 Only presets */

        public REVERB_PROPERTIES PS2_ROOM()            { return new REVERB_PROPERTIES(0,       1,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_STUDIO_A()        { return new REVERB_PROPERTIES(0,       2,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_STUDIO_B()        { return new REVERB_PROPERTIES(0,       3,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_STUDIO_C()        { return new REVERB_PROPERTIES(0,       4,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_HALL()            { return new REVERB_PROPERTIES(0,       5,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_SPACE()           { return new REVERB_PROPERTIES(0,       6,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_ECHO()            { return new REVERB_PROPERTIES(0,       7,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_DELAY()           { return new REVERB_PROPERTIES(0,       8,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
        public REVERB_PROPERTIES PS2_PIPE()            { return new REVERB_PROPERTIES(0,       9,    0,     0,         0,  0,      0,   0.0f,   0.0f,  0.0f,     0,  0.000f,  0.0f,0.0f,0.0f ,     0, 0.000f,  0.0f,0.0f,0.0f , 0.000f, 0.00f, 0.00f, 0.000f,  0.0f, 0000.0f,   0.0f, 0.0f,   0.0f,   0.0f, 0x31f );}
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure defining the properties for a reverb source, related to a FMOD channel.

        For more indepth descriptions of the reverb properties under win32, please see the EAX3
        documentation at http://developer.creative.com/ under the 'downloads' section.
        If they do not have the EAX3 documentation, then most information can be attained from
        the EAX2 documentation, as EAX3 only adds some more parameters and functionality on top of 
        EAX2.

        Note the default reverb properties are the same as the PRESET_GENERIC preset.
        Note that integer values that typically range from -10,000 to 1000 are represented in 
        decibels, and are of a logarithmic scale, not linear, wheras FLOAT values are typically linear.
        PORTABILITY: Each member has the platform it supports in braces ie (win32/xbox).  
        Some reverb parameters are only supported in win32 and some only on xbox. If all parameters are set then
        the reverb should product a similar effect on either platform.
        Linux and FMODCE do not support the reverb api.

        The numerical values listed below are the maximum, minimum and default values for each variable respectively.

        [REMARKS]
        For EAX4 support with multiple reverb environments, set FMOD_REVERB_CHANNELFLAGS_ENVIRONMENT0,
        FMOD_REVERB_CHANNELFLAGS_ENVIRONMENT1 or/and FMOD_REVERB_CHANNELFLAGS_ENVIRONMENT2 in the flags member 
        of FMOD_REVERB_CHANNELPROPERTIES to specify which environment instance(s) to target. 
        Only up to 2 environments to target can be specified at once. Specifying three will result in an error.
        If the sound card does not support EAX4, the environment flag is ignored.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        Channel::setReverbProperties
        Channel::getReverbProperties
        REVERB_CHANNELFLAGS
    ]
    */
    public struct REVERB_CHANNELPROPERTIES  
    {                                      /*          MIN     MAX    DEFAULT  DESCRIPTION */
        public int   Direct;               /* [in/out] -10000, 1000,  0,       direct path level (at low and mid frequencies) (win32/xbox) */
        public int   DirectHF;             /* [in/out] -10000, 0,     0,       relative direct path level at high frequencies (win32/xbox) */
        public int   Room;                 /* [in/out] -10000, 1000,  0,       room effect level (at low and mid frequencies) (win32/xbox) */
        public int   RoomHF;               /* [in/out] -10000, 0,     0,       relative room effect level at high frequencies (win32/xbox) */
        public int   Obstruction;          /* [in/out] -10000, 0,     0,       main obstruction control (attenuation at high frequencies)  (win32/xbox) */
        public float ObstructionLFRatio;   /* [in/out] 0.0,    1.0,   0.0,     obstruction low-frequency level re. main control (win32/xbox) */
        public int   Occlusion;            /* [in/out] -10000, 0,     0,       main occlusion control (attenuation at high frequencies) (win32/xbox) */
        public float OcclusionLFRatio;     /* [in/out] 0.0,    1.0,   0.25,    occlusion low-frequency level re. main control (win32/xbox) */
        public float OcclusionRoomRatio;   /* [in/out] 0.0,    10.0,  1.5,     relative occlusion control for room effect (win32) */
        public float OcclusionDirectRatio; /* [in/out] 0.0,    10.0,  1.0,     relative occlusion control for direct path (win32) */
        public int   Exclusion;            /* [in/out] -10000, 0,     0,       main exlusion control (attenuation at high frequencies) (win32) */
        public float ExclusionLFRatio;     /* [in/out] 0.0,    1.0,   1.0,     exclusion low-frequency level re. main control (win32) */
        public int   OutsideVolumeHF;      /* [in/out] -10000, 0,     0,       outside sound cone level at high frequencies (win32) */
        public float DopplerFactor;        /* [in/out] 0.0,    10.0,  0.0,     like DS3D flDopplerFactor but per source (win32) */
        public float RolloffFactor;        /* [in/out] 0.0,    10.0,  0.0,     like DS3D flRolloffFactor but per source (win32) */
        public float RoomRolloffFactor;    /* [in/out] 0.0,    10.0,  0.0,     like DS3D flRolloffFactor but for room effect (win32/xbox) */
        public float AirAbsorptionFactor;  /* [in/out] 0.0,    10.0,  1.0,     multiplies AirAbsorptionHF member of REVERB_PROPERTIES (win32) */
        public uint  Flags;                /* [in/out] REVERB_CHANNELFLAGS - modifies the behavior of properties (win32) */
    }


    /*
    [DEFINE] 
    [
        [NAME] 
        REVERB_CHANNELFLAGS

        [DESCRIPTION]
        Values for the Flags member of the REVERB_CHANNELPROPERTIES structure.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        REVERB_CHANNELPROPERTIES
    ]
    */
    public class REVERB_CHANNELFLAGS
    {
        public const uint DIRECTHFAUTO = 0x00000001; /* Automatic setting of 'Direct'  due to distance from listener */
        public const uint ROOMAUTO     = 0x00000002; /* Automatic setting of 'Room'  due to distance from listener */
        public const uint ROOMHFAUTO   = 0x00000004; /* Automatic setting of 'RoomHF' due to distance from listener */
        public const uint ENVIRONMENT0 = 0x00000008; /* EAX4 only. Specify channel to target reverb instance 0. */
        public const uint ENVIRONMENT1 = 0x00000010; /* EAX4 only. Specify channel to target reverb instance 1. */
        public const uint ENVIRONMENT2 = 0x00000020; /* EAX4 only. Specify channel to target reverb instance 2. */
        public const uint ENVIRONMENT3 = 0x00000040; /* EAX5. Specify channel to target reverb instance 3. */
        public const uint DEFAULT      = (DIRECTHFAUTO | ROOMAUTO | ROOMHFAUTO | ENVIRONMENT0);
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Settings for advanced features like configuring memory and cpu usage for the FMOD_CREATECOMPRESSEDSAMPLE feature.
   
        [REMARKS]
        maxMPEGcodecs / maxADPCMcodecs / maxXMAcodecs will determine the maximum cpu usage of playing realtime samples.  Use this to lower potential excess cpu usage and also control memory usage.&lt;br&gt;
   
        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3
   
        [SEE_ALSO]
        System::setAdvancedSettings
        System::getAdvancedSettings
    ]
    */
    public class ADVANCEDSETTINGS
    {                       
        public int     cbsize;                   /* Size of structure.  Use sizeof(FMOD_ADVANCEDSETTINGS) */
        public int     maxMPEGcodecs;            /* For use with FMOD_CREATECOMPRESSEDSAMPLE only.  Mpeg  codecs consume 48,696 per instance and this number will determine how many mpeg channels can be played simultaneously.  Default = 16. */
        public int     maxADPCMcodecs;           /* For use with FMOD_CREATECOMPRESSEDSAMPLE only.  ADPCM codecs consume 1k per instance and this number will determine how many ADPCM channels can be played simultaneously.  Default = 32. */
        public int     maxXMAcodecs;             /* For use with FMOD_CREATECOMPRESSEDSAMPLE only.  XMA   codecs consume 8k per instance and this number will determine how many XMA channels can be played simultaneously.  Default = 32.  */
        public int     maxPCMcodecs;             /* [in/out] Optional. Specify 0 to ignore. For use with PS3 only.                          PCM   codecs consume 12,672 bytes per instance and this number will determine how many streams and PCM voices can be played simultaneously. Default = 16 */
        public int     ASIONumChannels;          /* [in/out] */
        public IntPtr  ASIOChannelList;          /* [in/out] */
        public IntPtr  ASIOSpeakerList;          /* [in/out] Optional. Specify 0 to ignore. Pointer to a list of speakers that the ASIO channels map to.  This can be called after System::init to remap ASIO output. */
        public int     max3DReverbDSPs;          /* [in/out] The max number of 3d reverb DSP's in the system. */
        public float   HRTFMinAngle;             /* [in/out] For use with FMOD_INIT_SOFTWARE_HRTF.  The angle (0-360) of a 3D sound from the listener's forward vector at which the HRTF function begins to have an effect.  Default = 180.0. */
        public float   HRTFMaxAngle;             /* [in/out] For use with FMOD_INIT_SOFTWARE_HRTF.  The angle (0-360) of a 3D sound from the listener's forward vector at which the HRTF function begins to have maximum effect.  Default = 360.0.  */
        public float   HRTFFreq;                 /* [in/out] For use with FMOD_INIT_SOFTWARE_HRTF.  The cutoff frequency of the HRTF's lowpass filter function when at maximum effect. (i.e. at HRTFMaxAngle).  Default = 4000.0. */
        public float   vol0virtualvol;           /* [in/out] For use with FMOD_INIT_VOL0_BECOMES_VIRTUAL.  If this flag is used, and the volume is 0.0, then the sound will become virtual.  Use this value to raise the threshold to a different point where a sound goes virtual. */
        public int     eventqueuesize;           /* [in/out] Optional. Specify 0 to ignore. For use with FMOD Event system only.  Specifies the number of slots available for simultaneous non blocking loads.  Default = 32. */
        public uint    defaultDecodeBufferSize;  /* [in/out] Optional. Specify 0 to ignore. For streams. This determines the default size of the double buffer (in milliseconds) that a stream uses.  Default = 400ms */
    }


    /*
    [ENUM] 
    [
        [NAME] 
        FMOD_MISC_VALUES

        [DESCRIPTION]
        Miscellaneous values for FMOD functions.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::playSound
        System::playDSP
        System::getChannel
    ]
    */
    public enum CHANNELINDEX
    {
        FREE   = -1,     /* For a channel index, FMOD chooses a free voice using the priority system. */
        REUSE  = -2      /* For a channel index, re-use the channel handle that was passed in. */
    }


    /*
        FMOD System factory functions.  Use this to create an FMOD System Instance.  below you will see System_Init/Close to get started.
    */
    public class Factory
    {        
        public static RESULT System_Create(ref System system)
        {
            RESULT result      = RESULT.OK;
            IntPtr      systemraw   = new IntPtr();
            System      systemnew   = null;

            result = FMOD_System_Create(ref systemraw);
            if (result != RESULT.OK)
            {
                return result;
            }

            systemnew = new System();
            systemnew.setRaw(systemraw);
            system = systemnew;

            return result;
        }


        #region importfunctions
  
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Create                      (ref IntPtr system);

        #endregion
    }

    
    public class Memory
    {        
        public static RESULT GetStats(ref int currentalloced, ref int maxalloced)
        {
            return FMOD_Memory_GetStats(ref currentalloced, ref maxalloced);
        }


        #region importfunctions
  
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Memory_GetStats(ref int currentalloced, ref int maxalloced);

        #endregion
    }
        

    /*
        'System' API
    */
    public class System
    {
        public RESULT release                ()
        {
            return FMOD_System_Release(systemraw);
        }


        // Pre-init functions.
        public RESULT setOutput              (OUTPUTTYPE output)
        {
            return FMOD_System_SetOutput(systemraw, output);
        }
        public RESULT getOutput              (ref OUTPUTTYPE output)
        {
            return FMOD_System_GetOutput(systemraw, ref output);
        }
        public RESULT getNumDrivers          (ref int numdrivers)
        {
            return FMOD_System_GetNumDrivers(systemraw, ref numdrivers);
        }
        public RESULT getDriverInfo          (int id, StringBuilder name, int namelen, ref GUID guid)
        {
            return FMOD_System_GetDriverInfo(systemraw, id, name, namelen, ref guid);
        }
        public RESULT getDriverCaps          (int id, ref CAPS caps, ref int minfrequency, ref int maxfrequency, ref SPEAKERMODE controlpanelspeakermode)
        {
            return FMOD_System_GetDriverCaps(systemraw, id, ref caps, ref minfrequency, ref maxfrequency, ref controlpanelspeakermode);
        }
        public RESULT setDriver              (int driver)
        {
            return FMOD_System_SetDriver(systemraw, driver);
        }
        public RESULT getDriver              (ref int driver)
        {
            return FMOD_System_GetDriver(systemraw, ref driver);
        }
        public RESULT setHardwareChannels    (int min2d, int max2d, int min3d, int max3d)
        {
            return FMOD_System_SetHardwareChannels(systemraw, min2d, max2d, min3d, max3d);
        }
        public RESULT setSoftwareChannels    (int numsoftwarechannels)
        {
            return FMOD_System_SetSoftwareChannels(systemraw, numsoftwarechannels);
        }
        public RESULT getSoftwareChannels    (ref int numsoftwarechannels)
        {
            return FMOD_System_GetSoftwareChannels(systemraw, ref numsoftwarechannels);
        }
        public RESULT setSoftwareFormat      (int samplerate, SOUND_FORMAT format, int numoutputchannels, int maxinputchannels, DSP_RESAMPLER resamplemethod)
        {
            return FMOD_System_SetSoftwareFormat(systemraw, samplerate, format, numoutputchannels, maxinputchannels, resamplemethod);
        }
        public RESULT getSoftwareFormat      (ref int samplerate, ref SOUND_FORMAT format, ref int numoutputchannels, ref int maxinputchannels, ref DSP_RESAMPLER resamplemethod, ref int bits)
        {
            return FMOD_System_GetSoftwareFormat(systemraw, ref samplerate, ref format, ref numoutputchannels, ref maxinputchannels, ref resamplemethod, ref bits);
        }
        public RESULT setDSPBufferSize       (uint bufferlength, int numbuffers)
        {
            return FMOD_System_SetDSPBufferSize(systemraw, bufferlength, numbuffers);
        }
        public RESULT getDSPBufferSize       (ref uint bufferlength, ref int numbuffers)
        {
            return FMOD_System_GetDSPBufferSize(systemraw, ref bufferlength, ref numbuffers);
        }
        public RESULT setFileSystem          (FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek, int buffersize)
        {
            return FMOD_System_SetFileSystem(systemraw, useropen, userclose, userread, userseek, buffersize);
        }
        public RESULT attachFileSystem       (FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek)
        {
            return FMOD_System_AttachFileSystem(systemraw, useropen, userclose, userread, userseek);
        }
        public RESULT setAdvancedSettings    (ref ADVANCEDSETTINGS settings)
        {
            return FMOD_System_SetAdvancedSettings(systemraw, ref settings);
        }
        public RESULT getAdvancedSettings    (ref ADVANCEDSETTINGS settings)
        {
            return FMOD_System_GetAdvancedSettings(systemraw, ref settings);
        }
        public RESULT setSpeakerMode         (SPEAKERMODE speakermode)
        {
            return FMOD_System_SetSpeakerMode(systemraw, speakermode);
        }
        public RESULT getSpeakerMode         (ref SPEAKERMODE speakermode)
        {
            return FMOD_System_GetSpeakerMode(systemraw, ref speakermode);
        }
        
                         
        // Plug-in support
        public RESULT setPluginPath          (string path)
        {
            return FMOD_System_SetPluginPath(systemraw, path);
        }
        public RESULT loadPlugin             (string filename, ref uint handle, uint priority)
        {
            return FMOD_System_LoadPlugin(systemraw, filename, ref handle, priority);
        }
        public RESULT unloadPlugin           (uint handle)
        {
            return FMOD_System_UnloadPlugin(systemraw, handle);
        }
        public RESULT getNumPlugins          (PLUGINTYPE plugintype, ref int numplugins)
        {
            return FMOD_System_GetNumPlugins(systemraw, plugintype, ref numplugins);
        }
        public RESULT getPluginHandle        (PLUGINTYPE plugintype, int index, ref uint handle)
        {
            return FMOD_System_GetPluginHandle(systemraw, plugintype, index, ref handle);
        }
        public RESULT getPluginInfo          (uint handle, ref PLUGINTYPE plugintype, StringBuilder name, int namelen, ref uint version)
        {
            return FMOD_System_GetPluginInfo(systemraw, handle, ref plugintype, name, namelen, ref version);
        }

        public RESULT setOutputByPlugin      (uint handle)
        {
            return FMOD_System_SetOutputByPlugin(systemraw, handle);
        }
        public RESULT getOutputByPlugin      (ref uint handle)
        {
            return FMOD_System_GetOutputByPlugin(systemraw, ref handle);
        }
        public RESULT createDSPByPlugin      (uint handle, ref IntPtr dsp)
        {
            return FMOD_System_CreateDSPByPlugin(systemraw, handle, ref dsp);
        }
        public RESULT createCodec            (IntPtr codecdescription, uint priority)
        {
            return FMOD_System_CreateCodec(systemraw, codecdescription, priority);
        }


        // Init/Close 
        public RESULT init                   (int maxchannels, INITFLAG flags, IntPtr extradata)
        {
            return FMOD_System_Init(systemraw, maxchannels, flags, extradata);
        }
        public RESULT close                  ()
        {
            return FMOD_System_Close(systemraw);
        }


        // General post-init system functions
        public RESULT update                 ()
        {
            return FMOD_System_Update(systemraw);
        }

        public RESULT set3DSettings          (float dopplerscale, float distancefactor, float rolloffscale)
        {
            return FMOD_System_Set3DSettings(systemraw, dopplerscale, distancefactor, rolloffscale);
        }
        public RESULT get3DSettings          (ref float dopplerscale, ref float distancefactor, ref float rolloffscale)
        {
            return FMOD_System_Get3DSettings(systemraw, ref dopplerscale, ref distancefactor, ref rolloffscale);
        }
        public RESULT set3DNumListeners      (int numlisteners)
        {
            return FMOD_System_Set3DNumListeners(systemraw, numlisteners);
        }
        public RESULT get3DNumListeners      (ref int numlisteners)
        {
            return FMOD_System_Get3DNumListeners(systemraw, ref numlisteners);
        }
        public RESULT set3DListenerAttributes(int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up)
        {
            return FMOD_System_Set3DListenerAttributes(systemraw, listener, ref pos, ref vel, ref forward, ref up);
        }
        public RESULT get3DListenerAttributes(int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up)
        {
            return FMOD_System_Get3DListenerAttributes(systemraw, listener, ref pos, ref vel, ref forward, ref up);
        }

        public RESULT set3DRolloffCallback   (CB_3D_ROLLOFFCALLBACK callback)
        {
            return  FMOD_System_Set3DRolloffCallback   (systemraw, callback);
        }
        public RESULT set3DSpeakerPosition     (SPEAKER speaker, float x, float y, bool active)
        {
            return FMOD_System_Set3DSpeakerPosition(systemraw, speaker, x, y, (active ? 1 : 0));
        }
        public RESULT get3DSpeakerPosition     (SPEAKER speaker, ref float x, ref float y, ref bool active)
        {
            RESULT result;
            
            int isactive = 0;

            result = FMOD_System_Get3DSpeakerPosition(systemraw, speaker, ref x, ref y, ref isactive);

            active = (isactive != 0);

            return result;
        }

        public RESULT setStreamBufferSize    (uint filebuffersize, TIMEUNIT filebuffersizetype)
        {
            return FMOD_System_SetStreamBufferSize(systemraw, filebuffersize, filebuffersizetype);
        }
        public RESULT getStreamBufferSize    (ref uint filebuffersize, ref TIMEUNIT filebuffersizetype)
        {
            return FMOD_System_GetStreamBufferSize(systemraw, ref filebuffersize, ref filebuffersizetype);
        }


        // System information functions.
        public RESULT getVersion             (ref uint version)
        {
            return FMOD_System_GetVersion(systemraw, ref version);
        }
        public RESULT getOutputHandle        (ref IntPtr handle)
        {
            return FMOD_System_GetOutputHandle(systemraw, ref handle);
        }
        public RESULT getChannelsPlaying     (ref int channels)
        {
            return FMOD_System_GetChannelsPlaying(systemraw, ref channels);
        }
        public RESULT getHardwareChannels    (ref int num2d, ref int num3d, ref int total)
        {
            return FMOD_System_GetHardwareChannels(systemraw, ref num2d, ref num3d, ref total);
        }
        public RESULT getCPUUsage            (ref float dsp, ref float stream, ref float update, ref float total)
        {
            return FMOD_System_GetCPUUsage(systemraw, ref dsp, ref stream, ref update, ref total);
        }
        public RESULT getSoundRam            (ref int currentalloced, ref int maxalloced, ref int total)
        {
            return FMOD_System_GetSoundRAM(systemraw, ref currentalloced, ref maxalloced, ref total);
        }
        public RESULT getNumCDROMDrives      (ref int numdrives)
        {
            return FMOD_System_GetNumCDROMDrives(systemraw, ref numdrives);
        }
        public RESULT getCDROMDriveName      (int drive, StringBuilder drivename, int drivenamelen, StringBuilder scsiname, int scsinamelen, StringBuilder devicename, int devicenamelen)
        {
            return FMOD_System_GetCDROMDriveName(systemraw, drive, drivename, drivenamelen, scsiname, scsinamelen, devicename, devicenamelen);
        }
        public RESULT getSpectrum            (float[] spectrumarray, int numvalues, int channeloffset, DSP_FFT_WINDOW windowtype)
        {
            return FMOD_System_GetSpectrum(systemraw, spectrumarray, numvalues, channeloffset, windowtype);
        }
        public RESULT getWaveData            (float[] wavearray, int numvalues, int channeloffset)
        {
            return FMOD_System_GetWaveData(systemraw, wavearray, numvalues, channeloffset);
        }


        // Sound/DSP/Channel creation and retrieval. 
        public RESULT createSound            (string name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref Sound sound)
        {
            RESULT result           = RESULT.OK;
            IntPtr      soundraw    = new IntPtr();
            Sound       soundnew    = null;

            try
            {
                result = FMOD_System_CreateSound(systemraw, name_or_data, mode, ref exinfo, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;
        }
        public RESULT createSound            (byte[] data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref Sound sound)
        {
            RESULT result           = RESULT.OK;
            IntPtr      soundraw    = new IntPtr();
            Sound       soundnew    = null;

            try
            {
                result = FMOD_System_CreateSound(systemraw, data, mode, ref exinfo, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;
        }
        public RESULT createSound            (string name_or_data, MODE mode, ref Sound sound)
        {
            RESULT result           = RESULT.OK;
            IntPtr      soundraw    = new IntPtr();
            Sound       soundnew    = null;

            try
            {
                result = FMOD_System_CreateSound(systemraw, name_or_data, mode, 0, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;
        }
        public RESULT createStream            (string name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref Sound sound)
        {
            RESULT result           = RESULT.OK;
            IntPtr      soundraw    = new IntPtr();
            Sound       soundnew    = null;

            try
            {
                result = FMOD_System_CreateStream(systemraw, name_or_data, mode, ref exinfo, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;
        }
        public RESULT createStream            (byte[] data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref Sound sound)
        {
            RESULT result           = RESULT.OK;
            IntPtr      soundraw    = new IntPtr();
            Sound       soundnew    = null;

            try
            {
                result = FMOD_System_CreateStream(systemraw, data, mode, ref exinfo, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;
        }
        public RESULT createStream            (string name_or_data, MODE mode, ref Sound sound)
        {
            RESULT result           = RESULT.OK;
            IntPtr      soundraw    = new IntPtr();
            Sound       soundnew    = null;

            try
            {
                result = FMOD_System_CreateStream(systemraw, name_or_data, mode, 0, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;
        }
        public RESULT createDSP              (ref DSP_DESCRIPTION description, ref DSP dsp)
        {
            RESULT result = RESULT.OK;
            IntPtr dspraw = new IntPtr();
            DSP    dspnew = null;

            try
            {
                result = FMOD_System_CreateDSP(systemraw, ref description, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dsp == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                dsp = dspnew;
            }
            else
            {
                dsp.setRaw(dspraw);
            }
                             
            return result;  
        }
        public RESULT createDSPByType          (DSP_TYPE type, ref DSP dsp)
        {
            RESULT result = RESULT.OK;
            IntPtr dspraw = new IntPtr();
            DSP    dspnew = null;

            try
            {
                result = FMOD_System_CreateDSPByType(systemraw, type, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dsp == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                dsp = dspnew;
            }
            else
            {
                dsp.setRaw(dspraw);
            }
                             
            return result;  
        }
        public RESULT createDSPByIndex       (int index, ref DSP dsp)
        {
            RESULT result = RESULT.OK;
            IntPtr dspraw = new IntPtr();
            DSP    dspnew = null;

            try
            {
                result = FMOD_System_CreateDSPByIndex(systemraw, index, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dsp == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                dsp = dspnew;
            }
            else
            {
                dsp.setRaw(dspraw);
            }
                             
            return result;  
        }
                       
        public RESULT createChannelGroup     (string name, ref ChannelGroup channelgroup)
        {
            RESULT result = RESULT.OK;
            IntPtr channelgroupraw = new IntPtr();
            ChannelGroup    channelgroupnew = null;

            try
            {
                result = FMOD_System_CreateChannelGroup(systemraw, name, ref channelgroupraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channelgroup == null)
            {
                channelgroupnew = new ChannelGroup();
                channelgroupnew.setRaw(channelgroupraw);
                channelgroup = channelgroupnew;
            }
            else
            {
                channelgroup.setRaw(channelgroupraw);
            }
                             
            return result; 
        }
        public RESULT playSound              (CHANNELINDEX channelid, Sound sound, bool paused, ref Channel channel)
        {
            RESULT result      = RESULT.OK;
            IntPtr      channelraw;
            Channel     channelnew  = null;

            if (channel != null)
            {
                channelraw = channel.getRaw();
            }
            else
            {
                channelraw  = new IntPtr();
            }

            try
            {
                result = FMOD_System_PlaySound(systemraw, channelid, sound.getRaw(), (paused ? 1 : 0), ref channelraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channel == null)
            {
                channelnew = new Channel();
                channelnew.setRaw(channelraw);
                channel = channelnew;
            }
            else
            {
                channel.setRaw(channelraw);
            }
                             
            return result;                                                                    
        }
        public RESULT playDSP                (CHANNELINDEX channelid, DSP dsp, bool paused, ref Channel channel)
        {
            RESULT result           = RESULT.OK;
            IntPtr      channelraw;
            Channel     channelnew  = null;

            if (channel != null)
            {
                channelraw = channel.getRaw();
            }
            else
            {
                channelraw  = new IntPtr();
            }

            try
            {
                result = FMOD_System_PlayDSP(systemraw, channelid, dsp.getRaw(), (paused ? 1 : 0), ref channelraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channel == null)
            {
                channelnew = new Channel();
                channelnew.setRaw(channelraw);
                channel = channelnew;
            }
            else
            {
                channel.setRaw(channelraw);
            }
                             
            return result;  
        }
        public RESULT getChannel             (int channelid, ref Channel channel)
        {
            RESULT result      = RESULT.OK;
            IntPtr      channelraw  = new IntPtr();
            Channel     channelnew  = null;

            try
            {
                result = FMOD_System_GetChannel(systemraw, channelid, ref channelraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channel == null)
            {
                channelnew = new Channel();
                channelnew.setRaw(channelraw);
                channel = channelnew;
            }
            else
            {
                channel.setRaw(channelraw);
            }

            return result;
        }
     
        public RESULT getMasterChannelGroup  (ref ChannelGroup channelgroup)
        {
            RESULT result = RESULT.OK;
            IntPtr channelgroupraw = new IntPtr();
            ChannelGroup    channelgroupnew = null;

            try
            {
                result = FMOD_System_GetMasterChannelGroup(systemraw, ref channelgroupraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channelgroup == null)
            {
                channelgroupnew = new ChannelGroup();
                channelgroupnew.setRaw(channelgroupraw);
                channelgroup = channelgroupnew;
            }
            else
            {
                channelgroup.setRaw(channelgroupraw);
            }
                             
            return result; 
        }

        public RESULT getMasterSoundGroup    (ref SoundGroup soundgroup)
        {
            RESULT result = RESULT.OK;
            IntPtr soundgroupraw = new IntPtr();
            SoundGroup    soundgroupnew = null;

            try
            {
                result = FMOD_System_GetMasterSoundGroup(systemraw, ref soundgroupraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (soundgroup == null)
            {
                soundgroupnew = new SoundGroup();
                soundgroupnew.setRaw(soundgroupraw);
                soundgroup = soundgroupnew;
            }
            else
            {
                soundgroup.setRaw(soundgroupraw);
            }
                             
            return result; 
        }

        // Reverb api
        public RESULT setReverbProperties    (ref REVERB_PROPERTIES prop)
        {
            return FMOD_System_SetReverbProperties(systemraw, ref prop);
        }
        public RESULT getReverbProperties    (ref REVERB_PROPERTIES prop)
        {
            return FMOD_System_GetReverbProperties(systemraw, ref prop);
        }
                                        
        public RESULT setReverbAmbientProperties (ref REVERB_PROPERTIES prop)
        {
            return FMOD_System_SetReverbAmbientProperties(systemraw, ref prop);
        }
        public RESULT getReverbAmbientProperties (ref REVERB_PROPERTIES prop)
        {
            return FMOD_System_GetReverbAmbientProperties(systemraw, ref prop);
        }

        // System level DSP access.
        public RESULT getDSPHead             (ref DSP dsp)
        {
            RESULT result   = RESULT.OK;
            IntPtr dspraw   = new IntPtr();
            DSP    dspnew   = null;

            try
            {
                result = FMOD_System_GetDSPHead(systemraw, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dsp == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                dsp = dspnew;
            }
            else
            {
                dsp.setRaw(dspraw);
            }

            return result;
        }
        public RESULT addDSP                 (DSP dsp, ref DSPConnection dspconnection)
        {
            RESULT result = RESULT.OK;
            IntPtr dspconnectionraw = new IntPtr();
            DSPConnection dspconnectionnew = null;

            try
            {
                result = FMOD_System_AddDSP(systemraw, dsp.getRaw(), ref dspconnectionraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            { 
                return result;
            }

            if (dspconnection == null)
            {
                dspconnectionnew = new DSPConnection();
                dspconnectionnew.setRaw(dspconnectionraw);
                dspconnection = dspconnectionnew;
            }
            else
            {
                dspconnection.setRaw(dspconnectionraw);
            }

            return result;
        }
        public RESULT lockDSP            ()
        {
            return FMOD_System_LockDSP(systemraw);
        }
        public RESULT unlockDSP          ()
        {
            return FMOD_System_UnlockDSP(systemraw);
        }
                                            
        
        // Recording api
        public RESULT setRecordDriver        (int driver)
        {
            return FMOD_System_SetRecordDriver(systemraw, driver);
        }
        public RESULT getRecordDriver        (ref int driver)
        {
            return FMOD_System_GetRecordDriver(systemraw, ref driver);
        }
        public RESULT getRecordNumDrivers    (ref int numdrivers)
        {
            return FMOD_System_GetRecordNumDrivers(systemraw, ref numdrivers);
        }
        public RESULT getRecordDriverInfo    (int id, StringBuilder name, int namelen, ref GUID guid)
        {
            return FMOD_System_GetRecordDriverInfo(systemraw, id, name, namelen, ref guid);
        }
 
        public RESULT getRecordPosition      (ref uint position)
        {
            return FMOD_System_GetRecordPosition(systemraw, ref position);
        }
        public RESULT recordStart            (Sound sound, bool loop)
        {
            return FMOD_System_RecordStart(systemraw, sound.getRaw(), loop);
        }
        public RESULT recordStop             ()
        {
            return FMOD_System_RecordStop(systemraw);
        }
        public RESULT isRecording            (ref bool recording)
        {
            return FMOD_System_IsRecording(systemraw, ref recording);
        }
         
      
        // Geometry api 
        public RESULT createGeometry         (int maxpolygons, int maxvertices, ref Geometry geometryf)
        {
            RESULT result           = RESULT.OK;
            IntPtr      geometryraw    = new IntPtr();
            Geometry    geometrynew    = null;

            try
            {
                result = FMOD_System_CreateGeometry(systemraw, maxpolygons, maxvertices, ref geometryraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (geometryf == null)
            {
                geometrynew = new Geometry();
                geometrynew.setRaw(geometryraw);
                geometryf = geometrynew;
            }
            else
            {
                geometryf.setRaw(geometryraw);
            }

            return result;
        }
        public RESULT setGeometrySettings    (float maxworldsize)
        {
            return FMOD_System_SetGeometrySettings(systemraw, maxworldsize);
        }
        public RESULT getGeometrySettings    (ref float maxworldsize)
        {
            return FMOD_System_GetGeometrySettings(systemraw, ref maxworldsize);
        }
        public RESULT loadGeometry(IntPtr data, int datasize, ref Geometry geometry)
        {
            RESULT result           = RESULT.OK;
            IntPtr      geometryraw    = new IntPtr();
            Geometry    geometrynew    = null;

            try
            {
                result = FMOD_System_LoadGeometry(systemraw, data, datasize, ref geometryraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (geometry == null)
            {
                geometrynew = new Geometry();
                geometrynew.setRaw(geometryraw);
                geometry = geometrynew;
            }
            else
            {
                geometry.setRaw(geometryraw);
            }

            return result;
        }

  
        // Network functions
        public RESULT setNetworkProxy               (string proxy)
        {
            return FMOD_System_SetNetworkProxy(systemraw, proxy);
        }
        public RESULT getProxy               (StringBuilder proxy, int proxylen)
        {
            return FMOD_System_GetNetworkProxy(systemraw, proxy, proxylen);
        }
        public RESULT setNetworkTimeout      (int timeout)
        {
            return FMOD_System_SetNetworkTimeout(systemraw, timeout);
        }
        public RESULT getNetworkTimeout(ref int timeout)
        {
            return FMOD_System_GetNetworkTimeout(systemraw, ref timeout);
        }
                                     
        // Userdata set/get                         
        public RESULT setUserData            (IntPtr userdata)
        {
            return FMOD_System_SetUserData(systemraw, userdata);
        }
        public RESULT getUserData            (ref IntPtr userdata)
        {
            return FMOD_System_GetUserData(systemraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_System_GetMemoryInfo(systemraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }


        #region importfunctions

        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Release                (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetOutput              (IntPtr system, OUTPUTTYPE output);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetOutput              (IntPtr system, ref OUTPUTTYPE output);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetNumDrivers          (IntPtr system, ref int numdrivers);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetDriverInfo          (IntPtr system, int id, StringBuilder name, int namelen, ref GUID guid);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetDriverCaps          (IntPtr system, int id, ref CAPS caps, ref int minfrequency, ref int maxfrequency, ref SPEAKERMODE controlpanelspeakermode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetDriver              (IntPtr system, int driver);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetDriver              (IntPtr system, ref int driver);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetHardwareChannels    (IntPtr system, int min2d, int max2d, int min3d, int max3d);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetHardwareChannels    (IntPtr system, ref int num2d, ref int num3d, ref int total);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetSoftwareChannels    (IntPtr system, int numsoftwarechannels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetSoftwareChannels    (IntPtr system, ref int numsoftwarechannels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetSoftwareFormat      (IntPtr system, int samplerate, SOUND_FORMAT format, int numoutputchannels, int maxinputchannels, DSP_RESAMPLER resamplemethod);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetSoftwareFormat      (IntPtr system, ref int samplerate, ref SOUND_FORMAT format, ref int numoutputchannels, ref int maxinputchannels, ref DSP_RESAMPLER resamplemethod, ref int bits);        
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetDSPBufferSize       (IntPtr system, uint bufferlength, int numbuffers);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetDSPBufferSize       (IntPtr system, ref uint bufferlength, ref int numbuffers);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetFileSystem          (IntPtr system, FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek, int buffersize);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_AttachFileSystem       (IntPtr system, FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetPluginPath          (IntPtr system, string path);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_LoadPlugin             (IntPtr system, string filename, ref uint handle, uint priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_UnloadPlugin           (IntPtr system, uint handle);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetNumPlugins          (IntPtr system, PLUGINTYPE plugintype, ref int numplugins);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetPluginHandle        (IntPtr system, PLUGINTYPE plugintype, int index, ref uint handle);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetPluginInfo          (IntPtr system, uint handle, ref PLUGINTYPE plugintype, StringBuilder name, int namelen, ref uint version);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSPByPlugin      (IntPtr system, uint handle, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateCodec            (IntPtr system, IntPtr codecdescription, uint priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetOutputByPlugin      (IntPtr system, uint handle);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetOutputByPlugin      (IntPtr system, ref uint handle);        
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Init                   (IntPtr system, int maxchannels, INITFLAG flags, IntPtr extradata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Close                  (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Update                 (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_UpdateFinished         (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetAdvancedSettings    (IntPtr system, ref ADVANCEDSETTINGS settings);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetAdvancedSettings    (IntPtr system, ref ADVANCEDSETTINGS settings);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetSpeakerMode         (IntPtr system, SPEAKERMODE speakermode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetSpeakerMode         (IntPtr system, ref SPEAKERMODE speakermode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DRolloffCallback   (IntPtr system, CB_3D_ROLLOFFCALLBACK callback);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DSpeakerPosition     (IntPtr system, SPEAKER speaker, float x, float y, int active);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DSpeakerPosition     (IntPtr system, SPEAKER speaker, ref float x, ref float y, ref int active);
        [DllImport (VERSION.dll)]                       
        private static extern RESULT FMOD_System_Set3DSettings          (IntPtr system, float dopplerscale, float distancefactor, float rolloffscale);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DSettings          (IntPtr system, ref float dopplerscale, ref float distancefactor, ref float rolloffscale);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DNumListeners      (IntPtr system, int numlisteners);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DNumListeners      (IntPtr system, ref int numlisteners);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DListenerAttributes(IntPtr system, int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DListenerAttributes(IntPtr system, int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetFileBufferSize      (IntPtr system, int sizebytes);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetFileBufferSize      (IntPtr system, ref int sizebytes);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetStreamBufferSize    (IntPtr system, uint filebuffersize, TIMEUNIT filebuffersizetype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetStreamBufferSize    (IntPtr system, ref uint filebuffersize, ref TIMEUNIT filebuffersizetype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetVersion             (IntPtr system, ref uint version);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetOutputHandle        (IntPtr system, ref IntPtr handle);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetChannelsPlaying     (IntPtr system, ref int channels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetCPUUsage            (IntPtr system, ref float dsp, ref float stream, ref float update, ref float total);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetSoundRAM            (IntPtr system, ref int currentalloced, ref int maxalloced, ref int total);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetNumCDROMDrives      (IntPtr system, ref int numdrives);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetCDROMDriveName      (IntPtr system, int drive, StringBuilder drivename, int drivenamelen, StringBuilder scsiname, int scsinamelen, StringBuilder devicename, int devicenamelen);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetSpectrum            (IntPtr system, [MarshalAs(UnmanagedType.LPArray)]float[] spectrumarray, int numvalues, int channeloffset, DSP_FFT_WINDOW windowtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetWaveData            (IntPtr system, [MarshalAs(UnmanagedType.LPArray)]float[] wavearray, int numvalues, int channeloffset);
        [DllImport (VERSION.dll, CharSet = CharSet.Unicode)]   
        private static extern RESULT FMOD_System_CreateSound            (IntPtr system, string name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll, CharSet = CharSet.Unicode)]  
        private static extern RESULT FMOD_System_CreateStream           (IntPtr system, string name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll)]   
        private static extern RESULT FMOD_System_CreateSound            (IntPtr system, string name_or_data, MODE mode, int exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateStream           (IntPtr system, string name_or_data, MODE mode, int exinfo, ref IntPtr sound);   
        [DllImport (VERSION.dll)]   
        private static extern RESULT FMOD_System_CreateSound            (IntPtr system, byte[] name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateStream           (IntPtr system, byte[] name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll)]   
        private static extern RESULT FMOD_System_CreateSound            (IntPtr system, byte[] name_or_data, MODE mode, int exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateStream           (IntPtr system, byte[] name_or_data, MODE mode, int exinfo, ref IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSP              (IntPtr system, ref DSP_DESCRIPTION description, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSPByType        (IntPtr system, DSP_TYPE type, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSPByIndex       (IntPtr system, int index, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateChannelGroup     (IntPtr system, string name, ref IntPtr channelgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateSoundGroup       (IntPtr system, StringBuilder name, ref SoundGroup soundgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateReverb           (IntPtr system, ref IntPtr reverb);
        [DllImport (VERSION.dll)]                 
        private static extern RESULT FMOD_System_PlaySound              (IntPtr system, CHANNELINDEX channelid, IntPtr sound, int paused, ref IntPtr channel);
        [DllImport (VERSION.dll)]
        public static extern RESULT FMOD_System_PlayDSP                 (IntPtr system, CHANNELINDEX channelid, IntPtr dsp, int paused, ref IntPtr channel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetChannel             (IntPtr system, int channelid, ref IntPtr channel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetMasterChannelGroup  (IntPtr system, ref IntPtr channelgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetMasterSoundGroup    (IntPtr system, ref IntPtr soundgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetReverbProperties    (IntPtr system, ref REVERB_PROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetReverbProperties    (IntPtr system, ref REVERB_PROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetReverbAmbientProperties(IntPtr system, ref REVERB_PROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetReverbAmbientProperties(IntPtr system, ref REVERB_PROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetDSPHead             (IntPtr system, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_AddDSP                 (IntPtr system, IntPtr dsp, ref IntPtr dspconnection);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_LockDSP                (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_UnlockDSP              (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetRecordDriver        (IntPtr system, int driver);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordDriver        (IntPtr system, ref int driver);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordNumDrivers    (IntPtr system, ref int numdrivers);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordDriverInfo    (IntPtr system, int id, StringBuilder name, int namelen, ref GUID guid);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordPosition      (IntPtr system, ref uint position);
        [DllImport (VERSION.dll)]  
        private static extern RESULT FMOD_System_RecordStart            (IntPtr system, IntPtr sound, bool loop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_RecordStop             (IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_IsRecording            (IntPtr system, ref bool recording);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_CreateGeometry         (IntPtr system, int maxPolygons, int maxVertices, ref IntPtr geometryf);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetGeometrySettings    (IntPtr system, float maxWorldSize);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetGeometrySettings    (IntPtr system, ref float maxWorldSize);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_LoadGeometry           (IntPtr system, IntPtr data, int dataSize, ref IntPtr geometry);
        [DllImport (VERSION.dll)]               
        private static extern RESULT FMOD_System_SetNetworkProxy        (IntPtr system, string proxy);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetNetworkProxy        (IntPtr system, StringBuilder proxy, int proxylen);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetNetworkTimeout      (IntPtr system, int timeout);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetNetworkTimeout      (IntPtr system, ref int timeout);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_SetUserData            (IntPtr system, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetUserData            (IntPtr system, ref IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_System_GetMemoryInfo          (IntPtr system, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);

        #endregion

        #region wrapperinternal
        
        private IntPtr systemraw;

        public void setRaw(IntPtr system)
        {
            systemraw = new IntPtr();

            systemraw = system;
        }

        public IntPtr getRaw()
        {
            return systemraw;
        }

        #endregion
    }
    

    /*
        'Sound' API
    */
    public class Sound
    {
        public RESULT release                 ()
        {
            return FMOD_Sound_Release(soundraw);
        }
        public RESULT getSystemObject         (ref System system)
        {
            RESULT result   = RESULT.OK;
            IntPtr systemraw   = new IntPtr();
            System systemnew   = null;

            try
            {
                result = FMOD_Sound_GetSystemObject(soundraw, ref systemraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (system == null)
            {
                systemnew = new System();
                systemnew.setRaw(systemraw);
                system = systemnew;
            }
            else
            {
                system.setRaw(systemraw);
            }
            return result;  
        }
                     

        public RESULT @lock                   (uint offset, uint length, ref IntPtr ptr1, ref IntPtr ptr2, ref uint len1, ref uint len2)
        {
            return FMOD_Sound_Lock(soundraw, offset, length, ref ptr1, ref ptr2, ref len1, ref len2);
        }
        public RESULT unlock                  (IntPtr ptr1,  IntPtr ptr2, uint len1, uint len2)
        {
            return FMOD_Sound_Unlock(soundraw, ptr1, ptr2, len1, len2);
        }
        public RESULT setDefaults             (float frequency, float volume, float pan, int priority)
        {
            return FMOD_Sound_SetDefaults(soundraw, frequency, volume, pan, priority);
        }
        public RESULT getDefaults             (ref float frequency, ref float volume, ref float pan, ref int priority)
        {
            return FMOD_Sound_GetDefaults(soundraw, ref frequency, ref volume, ref pan, ref priority);
        }
        public RESULT setVariations           (float frequencyvar, float volumevar, float panvar)
        {
            return FMOD_Sound_SetVariations(soundraw, frequencyvar, volumevar, panvar);
        }
        public RESULT getVariations           (ref float frequencyvar, ref float volumevar, ref float panvar)
        {
            return FMOD_Sound_GetVariations(soundraw, ref frequencyvar, ref volumevar, ref panvar); 
        }
        public RESULT set3DMinMaxDistance     (float min, float max)
        {
            return FMOD_Sound_Set3DMinMaxDistance(soundraw, min, max);
        }
        public RESULT get3DMinMaxDistance     (ref float min, ref float max)
        {
            return FMOD_Sound_Get3DMinMaxDistance(soundraw, ref min, ref max);
        }
        public RESULT set3DConeSettings       (float insideconeangle, float outsideconeangle, float outsidevolume)
        {
            return FMOD_Sound_Set3DConeSettings(soundraw, insideconeangle, outsideconeangle, outsidevolume);
        }
        public RESULT get3DConeSettings       (ref float insideconeangle, ref float outsideconeangle, ref float outsidevolume)
        {
            return FMOD_Sound_Get3DConeSettings(soundraw, ref insideconeangle, ref outsideconeangle, ref outsidevolume);
        }
        public RESULT set3DCustomRolloff      (ref VECTOR points, int numpoints)
        {
            return FMOD_Sound_Set3DCustomRolloff(soundraw, ref points, numpoints);
        }
        public RESULT get3DCustomRolloff      (ref IntPtr points, ref int numpoints)
        {
            return FMOD_Sound_Get3DCustomRolloff(soundraw, ref points, ref numpoints);
        }
        public RESULT setSubSound             (int index, Sound subsound)
        {
            IntPtr subsoundraw = subsound.getRaw();

            return FMOD_Sound_SetSubSound(soundraw, index, subsoundraw);
        }
        public RESULT getSubSound             (int index, ref Sound subsound)
        {
            RESULT result       = RESULT.OK;
            IntPtr subsoundraw  = new IntPtr();
            Sound  subsoundnew  = null;

            try
            {
                result = FMOD_Sound_GetSubSound(soundraw, index, ref subsoundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (subsound == null)
            {
                subsoundnew = new Sound();
                subsoundnew.setRaw(subsoundraw);
                subsound = subsoundnew;
            }
            else
            {
                subsound.setRaw(subsoundraw);
            }

            return result;
        }
        public RESULT setSubSoundSentence     (int[] subsoundlist, int numsubsounds)
        {
            return FMOD_Sound_SetSubSoundSentence(soundraw, subsoundlist, numsubsounds);
        }
        public RESULT getName                 (StringBuilder name, int namelen)
        {
            return FMOD_Sound_GetName(soundraw, name, namelen);
        }
        public RESULT getLength               (ref uint length, TIMEUNIT lengthtype)
        {
            return FMOD_Sound_GetLength(soundraw, ref length, lengthtype);
        }
        public RESULT getFormat               (ref SOUND_TYPE type, ref SOUND_FORMAT format, ref int channels, ref int bits)
        {
            return FMOD_Sound_GetFormat(soundraw, ref type, ref format, ref channels, ref bits);
        }
        public RESULT getNumSubSounds         (ref int numsubsounds)
        {
            return FMOD_Sound_GetNumSubSounds(soundraw, ref numsubsounds);
        }
        public RESULT getNumTags              (ref int numtags, ref int numtagsupdated)
        {
            return FMOD_Sound_GetNumTags(soundraw, ref numtags, ref numtagsupdated);
        }
        public RESULT getTag                  (string name, int index, ref TAG tag)
        {
            IntPtr ptr    = Marshal.AllocCoTaskMem(Marshal.SizeOf(tag));
            RESULT result = FMOD_Sound_GetTag(soundraw, name, index, ptr);
            if(result == RESULT.OK)
            {
                tag = (TAG)Marshal.PtrToStructure(ptr, typeof(TAG));
            }
            return result; 
        }
        public RESULT getOpenState            (ref OPENSTATE openstate, ref uint percentbuffered, ref bool starving)
        {
            return FMOD_Sound_GetOpenState(soundraw, ref openstate, ref percentbuffered, ref starving);
        }
        public RESULT readData                (IntPtr buffer, uint lenbytes, ref uint read)
        {
            return FMOD_Sound_ReadData(soundraw, buffer, lenbytes, ref read);
        }
        public RESULT seekData                (uint pcm)
        {
            return FMOD_Sound_SeekData(soundraw, pcm);
        }


        public RESULT setSoundGroup           (SoundGroup soundgroup)
        {
            return FMOD_Sound_SetSoundGroup(soundraw, soundgroup.getRaw());
        }
        public RESULT getSoundGroup           (ref SoundGroup soundgroup)
        {
            RESULT result = RESULT.OK;
            IntPtr soundgroupraw = new IntPtr();
            SoundGroup    soundgroupnew = null;

            try
            {
                result = FMOD_Sound_GetSoundGroup(soundraw, ref soundgroupraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (soundgroup == null)
            {
                soundgroupnew = new SoundGroup();
                soundgroupnew.setRaw(soundgroupraw);
                soundgroup = soundgroupnew;
            }
            else
            {
                soundgroup.setRaw(soundgroupraw);
            }
                             
            return result; 
        }


        public RESULT getNumSyncPoints        (ref int numsyncpoints)
        {
            return FMOD_Sound_GetNumSyncPoints(soundraw, ref numsyncpoints);
        }
        public RESULT getSyncPoint            (int index, ref IntPtr point)
        {
            return FMOD_Sound_GetSyncPoint(soundraw, index, ref point);
        }
        public RESULT getSyncPointInfo        (IntPtr point, StringBuilder name, int namelen, ref uint offset, TIMEUNIT offsettype)
        {
            return FMOD_Sound_GetSyncPointInfo(soundraw, point, name, namelen, ref offset, offsettype);
        }
        public RESULT addSyncPoint            (int offset, TIMEUNIT offsettype, string name, ref IntPtr point)
        {
            return FMOD_Sound_AddSyncPoint(soundraw, offset, offsettype, name, ref point);
        }
        public RESULT deleteSyncPoint         (IntPtr point)
        {
            return FMOD_Sound_DeleteSyncPoint(soundraw, point);
        }


        public RESULT setMode                 (MODE mode)
        {
            return FMOD_Sound_SetMode(soundraw, mode);
        }
        public RESULT getMode                 (ref MODE mode)
        {
            return FMOD_Sound_GetMode(soundraw, ref mode);
        }
        public RESULT setLoopCount            (int loopcount)
        {
            return FMOD_Sound_SetLoopCount(soundraw, loopcount);
        }
        public RESULT getLoopCount            (ref int loopcount)
        {
            return FMOD_Sound_GetLoopCount(soundraw, ref loopcount);
        }
        public RESULT setLoopPoints           (uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Sound_SetLoopPoints(soundraw, loopstart, loopstarttype, loopend, loopendtype);
        }
        public RESULT getLoopPoints           (ref uint loopstart, TIMEUNIT loopstarttype, ref uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Sound_GetLoopPoints(soundraw, ref loopstart, loopstarttype, ref loopend, loopendtype);
        }

        public RESULT getMusicNumChannels       (ref int numchannels)
        {
            return FMOD_Sound_GetMusicNumChannels(soundraw, ref numchannels);
        }
        public RESULT setMusicChannelVolume     (int channel, float volume)
        {
            return FMOD_Sound_SetMusicChannelVolume(soundraw, channel, volume);
        }
        public RESULT getMusicChannelVolume     (int channel, ref float volume)
        {
            return FMOD_Sound_GetMusicChannelVolume(soundraw, channel, ref volume);
        }

        public RESULT setUserData             (IntPtr userdata)
        {
            return FMOD_Sound_SetUserData(soundraw, userdata);
        }
        public RESULT getUserData             (ref IntPtr userdata)
        {
            return FMOD_Sound_GetUserData(soundraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_Sound_GetMemoryInfo(soundraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }


        #region importfunctions

        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_Release                 (IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSystemObject         (IntPtr sound, ref IntPtr system);
        [DllImport (VERSION.dll)]                   
        private static extern RESULT FMOD_Sound_Lock                   (IntPtr sound, uint offset, uint length, ref IntPtr ptr1, ref IntPtr ptr2, ref uint len1, ref uint len2);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_Unlock                  (IntPtr sound, IntPtr ptr1,  IntPtr ptr2, uint len1, uint len2);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetDefaults             (IntPtr sound, float frequency, float volume, float pan, int priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetDefaults             (IntPtr sound, ref float frequency, ref float volume, ref float pan, ref int priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetVariations           (IntPtr sound, float frequencyvar, float volumevar, float panvar);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetVariations           (IntPtr sound, ref float frequencyvar, ref float volumevar, ref float panvar);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_Set3DMinMaxDistance     (IntPtr sound, float min, float max);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_Get3DMinMaxDistance     (IntPtr sound, ref float min, ref float max);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Set3DConeSettings       (IntPtr sound, float insideconeangle, float outsideconeangle, float outsidevolume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Get3DConeSettings       (IntPtr sound, ref float insideconeangle, ref float outsideconeangle, ref float outsidevolume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Set3DCustomRolloff      (IntPtr sound, ref VECTOR points, int numpoints);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Get3DCustomRolloff      (IntPtr sound, ref IntPtr points, ref int numpoints);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetSubSound             (IntPtr sound, int index, IntPtr subsound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSubSound             (IntPtr sound, int index, ref IntPtr subsound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetSubSoundSentence     (IntPtr sound, int[] subsoundlist, int numsubsounds);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetName                 (IntPtr sound, StringBuilder name, int namelen);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetLength               (IntPtr sound, ref uint length, TIMEUNIT lengthtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetFormat               (IntPtr sound, ref SOUND_TYPE type, ref SOUND_FORMAT format, ref int channels, ref int bits);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetNumSubSounds         (IntPtr sound, ref int numsubsounds);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetNumTags              (IntPtr sound, ref int numtags, ref int numtagsupdated);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetTag                  (IntPtr sound, string name, int index, IntPtr tag);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetOpenState            (IntPtr sound, ref OPENSTATE openstate, ref uint percentbuffered, ref bool starving);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_ReadData                (IntPtr sound, IntPtr buffer, uint lenbytes, ref uint read);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SeekData                (IntPtr sound, uint pcm);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetSoundGroup           (IntPtr sound, IntPtr soundgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSoundGroup           (IntPtr sound, ref IntPtr soundgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetNumSyncPoints        (IntPtr sound, ref int numsyncpoints);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSyncPoint            (IntPtr sound, int index, ref IntPtr point);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSyncPointInfo        (IntPtr sound, IntPtr point, StringBuilder name, int namelen, ref uint offset, TIMEUNIT offsettype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_AddSyncPoint            (IntPtr sound, int offset, TIMEUNIT offsettype, string name, ref IntPtr point);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_DeleteSyncPoint         (IntPtr sound, IntPtr point);
        [DllImport (VERSION.dll)]                   
        private static extern RESULT FMOD_Sound_SetMode                 (IntPtr sound, MODE mode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMode                 (IntPtr sound, ref MODE mode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetLoopCount            (IntPtr sound, int loopcount);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetLoopCount            (IntPtr sound, ref int loopcount);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetLoopPoints           (IntPtr sound, uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetLoopPoints           (IntPtr sound, ref uint loopstart, TIMEUNIT loopstarttype, ref uint loopend, TIMEUNIT loopendtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMusicNumChannels     (IntPtr sound, ref int numchannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetMusicChannelVolume   (IntPtr sound, int channel, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMusicChannelVolume   (IntPtr sound, int channel, ref float volume);
        [DllImport(VERSION.dll)]           
        private static extern RESULT FMOD_Sound_SetUserData             (IntPtr sound, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetUserData             (IntPtr sound, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMemoryInfo           (IntPtr sound, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion

        #region wrapperinternal

        private IntPtr soundraw;

        public void setRaw(IntPtr sound)
        {
            soundraw = new IntPtr();
            soundraw = sound;
        }

        public IntPtr getRaw()
        {
            return soundraw;
        }

        #endregion
    }


    /*
        'Channel' API
    */
    public class Channel
    {
        public RESULT getSystemObject       (ref System system)
        {
            RESULT result   = RESULT.OK;
            IntPtr systemraw   = new IntPtr();
            System systemnew   = null;

            try
            {
                result = FMOD_Channel_GetSystemObject(channelraw, ref systemraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (system == null)
            {
                systemnew = new System();
                systemnew.setRaw(systemraw);
                system = systemnew;
            }
            else
            {
                system.setRaw(systemraw);
            }

            return result;  
        }


        public RESULT stop                  ()
        {
            return FMOD_Channel_Stop(channelraw);
        }
        public RESULT setPaused             (bool paused)
        {
            return FMOD_Channel_SetPaused(channelraw, (paused ? 1 : 0));
        }
        public RESULT getPaused             (ref bool paused)
        {
            RESULT result;
            int p = 0;

            result = FMOD_Channel_GetPaused(channelraw, ref p);

            paused = (p != 0);

            return result;
        }
        public RESULT setVolume             (float volume)
        {
            return FMOD_Channel_SetVolume(channelraw, volume);
        }
        public RESULT getVolume             (ref float volume)
        {
            return FMOD_Channel_GetVolume(channelraw, ref volume);
        }
        public RESULT setFrequency          (float frequency)
        {
            return FMOD_Channel_SetFrequency(channelraw, frequency);
        }
        public RESULT getFrequency          (ref float frequency)
        {
            return FMOD_Channel_GetFrequency(channelraw, ref frequency);
        }
        public RESULT setPan                (float pan)
        {
            return FMOD_Channel_SetPan(channelraw, pan);
        }
        public RESULT getPan                (ref float pan)
        {
            return FMOD_Channel_GetPan(channelraw, ref pan);
        }
        public RESULT setDelay              (DELAYTYPE delaytype, uint delayhi, uint delaylo)
        {
            return FMOD_Channel_SetDelay(channelraw, delaytype, delayhi, delaylo);
        }
        public RESULT getDelay              (DELAYTYPE delaytype, ref uint delayhi, ref uint delaylo)
        {
            return FMOD_Channel_GetDelay(channelraw, delaytype, ref delayhi, ref delaylo);
        }
        public RESULT setSpeakerMix         (float frontleft, float frontright, float center, float lfe, float backleft, float backright, float sideleft, float sideright)
        {
            return FMOD_Channel_SetSpeakerMix(channelraw, frontleft, frontright, center, lfe, backleft, backright, sideleft, sideright);
        }
        public RESULT getSpeakerMix         (ref float frontleft, ref float frontright, ref float center, ref float lfe, ref float backleft, ref float backright, ref float sideleft, ref float sideright)
        {
            return FMOD_Channel_GetSpeakerMix(channelraw, ref frontleft, ref frontright, ref center, ref lfe, ref backleft, ref backright, ref sideleft, ref sideright);
        }
        public RESULT setSpeakerLevels      (SPEAKER speaker, float[] levels, int numlevels)
        {
            return FMOD_Channel_SetSpeakerLevels(channelraw, speaker, levels, numlevels);
        }
        public RESULT getSpeakerLevels      (SPEAKER speaker, float[] levels, int numlevels)
        {
            return FMOD_Channel_GetSpeakerLevels(channelraw, speaker, levels, numlevels);
        }
        public RESULT setInputChannelMix    (ref float levels, int numlevels)
        {
            return FMOD_Channel_SetInputChannelMix(channelraw, ref levels, numlevels);
        }
        public RESULT getInputChannelMix    (ref float levels, int numlevels)
        {
            return FMOD_Channel_GetInputChannelMix(channelraw, ref levels, numlevels);
        }
        public RESULT setMute               (bool mute)
        {
            return FMOD_Channel_SetMute(channelraw, (mute ? 1 : 0));
        }
        public RESULT getMute               (ref bool mute)
        {
            RESULT result;
            int m = 0;

            result = FMOD_Channel_GetMute(channelraw, ref m);

            mute = (m != 0);

            return result;
        }
        public RESULT setPriority           (int priority)
        {
            return FMOD_Channel_SetPriority(channelraw, priority);
        }
        public RESULT getPriority           (ref int priority)
        {
            return FMOD_Channel_GetPriority(channelraw, ref priority);
        }
        public RESULT setPosition           (uint position, TIMEUNIT postype)
        {
            return FMOD_Channel_SetPosition(channelraw, position, postype);
        }
        public RESULT getPosition           (ref uint position, TIMEUNIT postype)
        {
            return FMOD_Channel_GetPosition(channelraw, ref position, postype);
        }
        
        public RESULT setReverbProperties   (ref REVERB_CHANNELPROPERTIES prop)
        {
            return FMOD_Channel_SetReverbProperties(channelraw, ref prop);
        }
        public RESULT getReverbProperties   (ref REVERB_CHANNELPROPERTIES prop)
        {
            return FMOD_Channel_GetReverbProperties(channelraw, ref prop);
        }
        public RESULT setChannelGroup       (ChannelGroup channelgroup)
        {
            return FMOD_Channel_SetChannelGroup(channelraw, channelgroup.getRaw());
        }
        public RESULT getChannelGroup        (ref ChannelGroup channelgroup)
        {
            RESULT result = RESULT.OK;
            IntPtr channelgroupraw = new IntPtr();
            ChannelGroup    channelgroupnew = null;

            try
            {
                result = FMOD_Channel_GetChannelGroup(channelraw, ref channelgroupraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channelgroup == null)
            {
                channelgroupnew = new ChannelGroup();
                channelgroupnew.setRaw(channelgroupraw);
                channelgroup = channelgroupnew;
            }
            else
            {
                channelgroup.setRaw(channelgroupraw);
            }
                             
            return result; 
        }

        public RESULT setCallback           (CHANNEL_CALLBACK callback)
        {
            return FMOD_Channel_SetCallback(channelraw, callback);
        }


        public RESULT set3DAttributes       (ref VECTOR pos, ref VECTOR vel)
        {
            return FMOD_Channel_Set3DAttributes(channelraw, ref pos, ref vel);
        }
        public RESULT get3DAttributes       (ref VECTOR pos, ref VECTOR vel)
        {
            return FMOD_Channel_Get3DAttributes(channelraw, ref pos, ref vel);
        }
        public RESULT set3DMinMaxDistance   (float mindistance, float maxdistance)
        {
            return FMOD_Channel_Set3DMinMaxDistance(channelraw, mindistance, maxdistance);
        }
        public RESULT get3DMinMaxDistance   (ref float mindistance, ref float maxdistance)
        {
            return FMOD_Channel_Get3DMinMaxDistance(channelraw, ref mindistance, ref maxdistance);
        }
        public RESULT set3DConeSettings     (float insideconeangle, float outsideconeangle, float outsidevolume)
        {
            return FMOD_Channel_Set3DConeSettings(channelraw, insideconeangle, outsideconeangle, outsidevolume);
        }
        public RESULT get3DConeSettings     (ref float insideconeangle, ref float outsideconeangle, ref float outsidevolume)
        {
            return FMOD_Channel_Get3DConeSettings(channelraw, ref insideconeangle, ref outsideconeangle, ref outsidevolume);
        }
        public RESULT set3DConeOrientation  (ref VECTOR orientation)
        {
            return FMOD_Channel_Set3DConeOrientation(channelraw, ref orientation);
        }
        public RESULT get3DConeOrientation  (ref VECTOR orientation)
        {
            return FMOD_Channel_Get3DConeOrientation(channelraw, ref orientation);
        }
        public RESULT set3DCustomRolloff    (ref VECTOR points, int numpoints)
        {
            return FMOD_Channel_Set3DCustomRolloff(channelraw, ref points, numpoints);
        }
        public RESULT get3DCustomRolloff    (ref IntPtr points, ref int numpoints)
        {
            return FMOD_Channel_Get3DCustomRolloff(channelraw, ref points, ref numpoints);
        }
        public RESULT set3DOcclusion        (float directOcclusion, float reverbOcclusion)
        {
            return FMOD_Channel_Set3DOcclusion(channelraw, directOcclusion, reverbOcclusion);
        }
        public RESULT get3DOcclusion        (ref float directOcclusion, ref float reverbOcclusion)
        {
            return FMOD_Channel_Get3DOcclusion(channelraw, ref directOcclusion, ref reverbOcclusion);
        }
        public RESULT set3DSpread           (float angle)
        {
            return FMOD_Channel_Set3DSpread(channelraw, angle);
        }
        public RESULT get3DSpread           (ref float angle)
        {
            return FMOD_Channel_Get3DSpread(channelraw, ref angle);
        }
        public RESULT set3DPanLevel         (float level)
        {
            return FMOD_Channel_Set3DPanLevel(channelraw, level);
        }
        public RESULT get3DPanLevel         (ref float level)
        {
            return FMOD_Channel_Get3DPanLevel(channelraw, ref level);
        }
        public RESULT set3DDopplerLevel     (float level)
        {
            return FMOD_Channel_Set3DDopplerLevel(channelraw, level);
        }
        public RESULT get3DDopplerLevel     (ref float level)
        {
            return FMOD_Channel_Get3DDopplerLevel(channelraw, ref level);
        }

        public RESULT isPlaying             (ref bool isplaying)
        {
            return FMOD_Channel_IsPlaying(channelraw, ref isplaying);
        }
        public RESULT isVirtual             (ref bool isvirtual)
        {
            return FMOD_Channel_IsVirtual(channelraw, ref isvirtual);
        }
        public RESULT getAudibility         (ref float audibility)
        {
            return FMOD_Channel_GetAudibility(channelraw, ref audibility);
        }
        public RESULT getCurrentSound       (ref Sound sound)
        {
            RESULT result      = RESULT.OK;
            IntPtr soundraw    = new IntPtr();
            Sound  soundnew    = null;

            try
            {
                result = FMOD_Channel_GetCurrentSound(channelraw, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result;  
        }
        public RESULT getSpectrum           (float[] spectrumarray, int numvalues, int channeloffset, DSP_FFT_WINDOW windowtype)
        {
            return FMOD_Channel_GetSpectrum(channelraw, spectrumarray, numvalues, channeloffset, windowtype);
        }
        public RESULT getWaveData           (float[] wavearray, int numvalues, int channeloffset)
        {
            return FMOD_Channel_GetWaveData(channelraw, wavearray, numvalues, channeloffset);
        }
        public RESULT getIndex              (ref int index)
        {
            return FMOD_Channel_GetIndex(channelraw, ref index);
        }

        public RESULT getDSPHead            (ref DSP dsp)
        {
            RESULT result      = RESULT.OK;
            IntPtr dspraw      = new IntPtr();
            DSP    dspnew      = null;

            try
            {
                result = FMOD_Channel_GetDSPHead(channelraw, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            dspnew = new DSP();
            dspnew.setRaw(dspraw);
            dsp = dspnew;

            return result; 
        }
        public RESULT addDSP                (DSP dsp, ref DSPConnection dspconnection)
        {
            RESULT result = RESULT.OK;
            IntPtr dspconnectionraw = new IntPtr();
            DSPConnection dspconnectionnew = null;

            try
            {
                result = FMOD_Channel_AddDSP(channelraw, dsp.getRaw(), ref dspconnectionraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dspconnection == null)
            {
                dspconnectionnew = new DSPConnection();
                dspconnectionnew.setRaw(dspconnectionraw);
                dspconnection = dspconnectionnew;
            }
            else
            {
                dspconnection.setRaw(dspconnectionraw);
            }

            return result;
        }
         
            
        public RESULT setMode               (MODE mode)
        {
            return FMOD_Channel_SetMode(channelraw, mode);
        }
        public RESULT getMode               (ref MODE mode)
        {
            return FMOD_Channel_GetMode(channelraw, ref mode);
        }
        public RESULT setLoopCount          (int loopcount)
        {
            return FMOD_Channel_SetLoopCount(channelraw, loopcount);
        }
        public RESULT getLoopCount          (ref int loopcount)
        {
            return FMOD_Channel_GetLoopCount(channelraw, ref loopcount);
        }
        public RESULT setLoopPoints         (uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Channel_SetLoopPoints(channelraw, loopstart, loopstarttype, loopend, loopendtype);
        }
        public RESULT getLoopPoints         (ref uint loopstart, TIMEUNIT loopstarttype, ref uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Channel_GetLoopPoints(channelraw, ref loopstart, loopstarttype, ref loopend, loopendtype);
        }


        public RESULT setUserData           (IntPtr userdata)
        {
            return FMOD_Channel_SetUserData(channelraw, userdata);
        }
        public RESULT getUserData           (ref IntPtr userdata)
        {
            return FMOD_Channel_GetUserData(channelraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_Channel_GetMemoryInfo(channelraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }

        #region importfunctions

        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetSystemObject       (IntPtr channel, ref IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Stop                  (IntPtr channel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetPaused             (IntPtr channel, int paused);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetPaused             (IntPtr channel, ref int paused);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetVolume             (IntPtr channel, float volume);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetVolume             (IntPtr channel, ref float volume);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetFrequency          (IntPtr channel, float frequency);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetFrequency          (IntPtr channel, ref float frequency);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetPan                (IntPtr channel, float pan);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetPan                (IntPtr channel, ref float pan);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetDelay              (IntPtr channel, DELAYTYPE delaytype, uint delayhi, uint delaylo);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetDelay              (IntPtr channel, DELAYTYPE delaytype, ref uint delayhi, ref uint delaylo);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetSpeakerMix         (IntPtr channel, float frontleft, float frontright, float center, float lfe, float backleft, float backright, float sideleft, float sideright);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetSpeakerMix         (IntPtr channel, ref float frontleft, ref float frontright, ref float center, ref float lfe, ref float backleft, ref float backright, ref float sideleft, ref float sideright);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetSpeakerLevels      (IntPtr channel, SPEAKER speaker, float[] levels, int numlevels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetSpeakerLevels      (IntPtr channel, SPEAKER speaker, [MarshalAs(UnmanagedType.LPArray)]float[] levels, int numlevels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetInputChannelMix    (IntPtr channel, ref float levels, int numlevels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetInputChannelMix    (IntPtr channel, ref float levels, int numlevels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetMute               (IntPtr channel, int mute);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetMute               (IntPtr channel, ref int mute);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetPriority           (IntPtr channel, int priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetPriority           (IntPtr channel, ref int priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Set3DAttributes       (IntPtr channel, ref VECTOR pos, ref VECTOR vel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Get3DAttributes       (IntPtr channel, ref VECTOR pos, ref VECTOR vel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Set3DMinMaxDistance   (IntPtr channel, float mindistance, float maxdistance);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Get3DMinMaxDistance   (IntPtr channel, ref float mindistance, ref float maxdistance);
        [DllImport (VERSION.dll)]        
        private static extern RESULT FMOD_Channel_Set3DConeSettings     (IntPtr channel, float insideconeangle, float outsideconeangle, float outsidevolume);
        [DllImport (VERSION.dll)] 
        private static extern RESULT FMOD_Channel_Get3DConeSettings     (IntPtr channel, ref float insideconeangle, ref float outsideconeangle, ref float outsidevolume);
        [DllImport (VERSION.dll)] 
        private static extern RESULT FMOD_Channel_Set3DConeOrientation  (IntPtr channel, ref VECTOR orientation);
        [DllImport (VERSION.dll)] 
        private static extern RESULT FMOD_Channel_Get3DConeOrientation  (IntPtr channel, ref VECTOR orientation);
        [DllImport (VERSION.dll)] 
        private static extern RESULT FMOD_Channel_Set3DCustomRolloff    (IntPtr channel, ref VECTOR points, int numpoints);
        [DllImport (VERSION.dll)] 
        private static extern RESULT FMOD_Channel_Get3DCustomRolloff    (IntPtr channel, ref IntPtr points, ref int numpoints);
        [DllImport (VERSION.dll)] 
        private static extern RESULT FMOD_Channel_Set3DOcclusion        (IntPtr channel, float directOcclusion, float reverbOcclusion);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Get3DOcclusion        (IntPtr channel, ref float directOcclusion, ref float reverbOcclusion);
        [DllImport (VERSION.dll)]          
        private static extern RESULT FMOD_Channel_Set3DSpread           (IntPtr channel, float angle);
        [DllImport (VERSION.dll)]    
        private static extern RESULT FMOD_Channel_Get3DSpread           (IntPtr channel, ref float angle);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Set3DPanLevel         (IntPtr channel, float level);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Get3DPanLevel         (IntPtr channel, ref float level);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Set3DDopplerLevel     (IntPtr channel, float level);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_Get3DDopplerLevel     (IntPtr channel, ref float level);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetReverbProperties   (IntPtr channel, ref REVERB_CHANNELPROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetReverbProperties   (IntPtr channel, ref REVERB_CHANNELPROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetChannelGroup       (IntPtr channel, IntPtr channelgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetChannelGroup       (IntPtr channel, ref IntPtr channelgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_IsPlaying             (IntPtr channel, ref bool isplaying);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_IsVirtual             (IntPtr channel, ref bool isvirtual);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetAudibility         (IntPtr channel, ref float audibility);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetCurrentSound       (IntPtr channel, ref IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetSpectrum           (IntPtr channel, [MarshalAs(UnmanagedType.LPArray)] float[] spectrumarray, int numvalues, int channeloffset, DSP_FFT_WINDOW windowtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetWaveData           (IntPtr channel, [MarshalAs(UnmanagedType.LPArray)] float[] wavearray, int numvalues, int channeloffset);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetIndex              (IntPtr channel, ref int index);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetCallback           (IntPtr channel, CHANNEL_CALLBACK callback);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetPosition           (IntPtr channel, uint position, TIMEUNIT postype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetPosition           (IntPtr channel, ref uint position, TIMEUNIT postype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetDSPHead            (IntPtr channel, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_AddDSP                (IntPtr channel, IntPtr dsp, ref IntPtr dspconnection);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetMode               (IntPtr channel, MODE mode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetMode               (IntPtr channel, ref MODE mode);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetLoopCount          (IntPtr channel, int loopcount);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetLoopCount          (IntPtr channel, ref int loopcount);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetLoopPoints         (IntPtr channel, uint  loopstart, TIMEUNIT loopstarttype, uint  loopend, TIMEUNIT loopendtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetLoopPoints         (IntPtr channel, ref uint loopstart, TIMEUNIT loopstarttype, ref uint loopend, TIMEUNIT loopendtype);
        [DllImport (VERSION.dll)]                                        
        private static extern RESULT FMOD_Channel_SetUserData           (IntPtr channel, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetUserData           (IntPtr channel, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetMemoryInfo         (IntPtr channel, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion
        
        #region wrapperinternal

        private IntPtr channelraw;

        public void setRaw(IntPtr channel)
        {
            channelraw = new IntPtr();

            channelraw = channel;
        }

        public IntPtr getRaw()
        {
            return channelraw;
        }

        #endregion
    }


    /*
        'ChannelGroup' API
    */
    public class ChannelGroup
    {
        public RESULT release                ()
        {
            return FMOD_ChannelGroup_Release(channelgroupraw);
        }
        public RESULT getSystemObject        (ref System system)
        {
            RESULT result = RESULT.OK;
            IntPtr systemraw = new IntPtr();
            System systemnew = null;

            try
            {
                result = FMOD_ChannelGroup_GetSystemObject(channelgroupraw, ref systemraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (system == null)
            {
                systemnew = new System();
                systemnew.setRaw(systemraw);
                system = systemnew;
            }
            else
            {
                system.setRaw(systemraw);
            }
                             
            return result; 
        }


        // Channelgroup scale values.  (scales the current volume or pitch of all channels and channel groups, DOESN'T overwrite)
        public RESULT setVolume              (float volume)
        {
            return FMOD_ChannelGroup_SetVolume(channelgroupraw, volume);
        }
        public RESULT getVolume              (ref float volume)
        {
            return FMOD_ChannelGroup_GetVolume(channelgroupraw, ref volume);
        }
        public RESULT setPitch               (float pitch)
        {
            return FMOD_ChannelGroup_SetPitch(channelgroupraw, pitch);
        }
        public RESULT getPitch               (ref float pitch)
        {
            return FMOD_ChannelGroup_GetPitch(channelgroupraw, ref pitch);
        }

        public RESULT setPaused              (bool paused)
        {
            return FMOD_ChannelGroup_SetPaused(channelgroupraw, (paused ? 1 : 0));
        }
        public RESULT getPaused              (ref bool paused)
        {
            RESULT result;
            int p = 0;

            result = FMOD_ChannelGroup_GetPaused(channelgroupraw, ref p);

            paused = (p != 0);

            return result;
        }
        public RESULT setMute                (bool mute)
        {
            return FMOD_ChannelGroup_SetMute(channelgroupraw, (mute ? 1 : 0));
        }
        public RESULT getMute                (ref bool mute)
        {
            RESULT result;
            int m = 0;

            result = FMOD_ChannelGroup_GetMute(channelgroupraw, ref m);
            
            mute = (m != 0);

            return result;
        }


        // Channelgroup override values.  (recursively overwrites whatever settings the channels had)
        public RESULT stop                   ()
        {
            return FMOD_ChannelGroup_Stop(channelgroupraw);
        }
        public RESULT overrideVolume         (float volume)
        {
            return FMOD_ChannelGroup_OverrideVolume(channelgroupraw, volume);
        }
        public RESULT overrideFrequency      (float frequency)
        {
            return FMOD_ChannelGroup_OverrideFrequency(channelgroupraw, frequency);
        }
        public RESULT overridePan            (float pan)
        {
            return FMOD_ChannelGroup_OverridePan(channelgroupraw, pan);
        }
        public RESULT overrideReverbProperties (ref REVERB_CHANNELPROPERTIES prop)
        {
            return FMOD_ChannelGroup_OverrideReverbProperties(channelgroupraw, ref prop);
        }
        public RESULT override3DAttributes   (ref VECTOR pos, ref VECTOR vel)
        {
            return FMOD_ChannelGroup_Override3DAttributes(channelgroupraw, ref pos, ref vel);
        }
        public RESULT overrideSpeakerMix     (float frontleft, float frontright, float center, float lfe, float backleft, float backright, float sideleft, float sideright)
        {
            return FMOD_ChannelGroup_OverrideSpeakerMix(channelgroupraw, frontleft, frontright, center, lfe, backleft, backright, sideleft, sideright);
        }


        // Nested channel groups.
        public RESULT addGroup               (ChannelGroup group)
        {
            return FMOD_ChannelGroup_AddGroup(channelgroupraw, group.getRaw());
        }
        public RESULT getNumGroups           (ref int numgroups)
        {
            return FMOD_ChannelGroup_GetNumGroups(channelgroupraw, ref numgroups);
        }
        public RESULT getGroup               (int index, ref ChannelGroup group)
        {
            RESULT result = RESULT.OK;
            IntPtr channelraw = new IntPtr();
            ChannelGroup    channelnew = null;

            try
            {
                result = FMOD_ChannelGroup_GetGroup(channelgroupraw, index, ref channelraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (group == null)
            {
                channelnew = new ChannelGroup();
                channelnew.setRaw(channelraw);
                group = channelnew;
            }
            else
            {
                group.setRaw(channelraw);
            }
                             
            return result;
        }
        public RESULT getParentGroup         (ref ChannelGroup group)
        {
            RESULT result = RESULT.OK;
            IntPtr channelraw = new IntPtr();
            ChannelGroup    channelnew = null;

            try
            {
                result = FMOD_ChannelGroup_GetParentGroup(channelgroupraw, ref channelraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (group == null)
            {
                channelnew = new ChannelGroup();
                channelnew.setRaw(channelraw);
                group = channelnew;
            }
            else
            {
                group.setRaw(channelraw);
            }
                             
            return result;
        }


        // DSP functionality only for channel groups playing sounds created with FMOD_SOFTWARE.
        public RESULT getDSPHead             (ref DSP dsp)
        {
            RESULT result = RESULT.OK;
            IntPtr dspraw = new IntPtr();
            DSP    dspnew = null;

            try
            {
                result = FMOD_ChannelGroup_GetDSPHead(channelgroupraw, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dsp == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                dsp = dspnew;
            }
            else
            {
                dsp.setRaw(dspraw);
            }
                             
            return result; 
        }

        public RESULT addDSP                 (DSP dsp, ref DSPConnection dspconnection)
        {
            RESULT result = RESULT.OK;
            IntPtr dspconnectionraw = new IntPtr();
            DSPConnection dspconnectionnew = null;

            try
            {
                result = FMOD_ChannelGroup_AddDSP(channelgroupraw, dsp.getRaw(), ref dspconnectionraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dspconnection == null)
            {
                dspconnectionnew = new DSPConnection();
                dspconnectionnew.setRaw(dspconnectionraw);
                dspconnection = dspconnectionnew;
            }
            else
            {
                dspconnection.setRaw(dspconnectionraw);
            }

            return result;
        }


        // Information only functions.
        public RESULT getName                (StringBuilder name, int namelen)
        {
            return FMOD_ChannelGroup_GetName(channelgroupraw, name, namelen);
        }
        public RESULT getNumChannels         (ref int numchannels)
        {
            return FMOD_ChannelGroup_GetNumChannels(channelgroupraw, ref numchannels);
        }
        public RESULT getChannel             (int index, ref Channel channel)
        {
            RESULT result = RESULT.OK;
            IntPtr channelraw = new IntPtr();
            Channel    channelnew = null;

            try
            {
                result = FMOD_ChannelGroup_GetChannel(channelgroupraw, index, ref channelraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (channel == null)
            {
                channelnew = new Channel();
                channelnew.setRaw(channelraw);
                channel = channelnew;
            }
            else
            {
                channel.setRaw(channelraw);
            }
                             
            return result;
        }
        public RESULT getSpectrum            (float[] spectrumarray, int numvalues, int channeloffset, DSP_FFT_WINDOW windowtype)
        {
            return FMOD_ChannelGroup_GetSpectrum(channelgroupraw, spectrumarray, numvalues, channeloffset, windowtype);
        }
        public RESULT getWaveData            (float[] wavearray, int numvalues, int channeloffset)
        {
            return FMOD_ChannelGroup_GetWaveData(channelgroupraw, wavearray, numvalues, channeloffset);
        }


        // Userdata set/get.
        public RESULT setUserData            (IntPtr userdata)
        {
            return FMOD_ChannelGroup_SetUserData(channelgroupraw, userdata);
        }
        public RESULT getUserData            (ref IntPtr userdata)
        {
            return FMOD_ChannelGroup_GetUserData(channelgroupraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_ChannelGroup_GetMemoryInfo(channelgroupraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }

        #region importfunctions


        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Release          (IntPtr channelgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetSystemObject  (IntPtr channelgroup, ref IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetVolume        (IntPtr channelgroup, float volume);
        [DllImport (VERSION.dll)]        
        private static extern RESULT FMOD_ChannelGroup_GetVolume        (IntPtr channelgroup, ref float volume);
        [DllImport (VERSION.dll)]       
        private static extern RESULT FMOD_ChannelGroup_SetPitch         (IntPtr channelgroup, float pitch);
        [DllImport (VERSION.dll)]       
        private static extern RESULT FMOD_ChannelGroup_GetPitch         (IntPtr channelgroup, ref float pitch);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetPaused        (IntPtr channelgroup, int paused);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetPaused        (IntPtr channelgroup, ref int paused);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetMute          (IntPtr channelgroup, int mute);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetMute          (IntPtr channelgroup, ref int mute);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Stop             (IntPtr channelgroup);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverridePaused   (IntPtr channelgroup, bool paused);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverrideVolume   (IntPtr channelgroup, float volume);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverrideFrequency(IntPtr channelgroup, float frequency);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverridePan      (IntPtr channelgroup, float pan);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverrideMute     (IntPtr channelgroup, bool mute);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverrideReverbProperties(IntPtr channelgroup, ref REVERB_CHANNELPROPERTIES prop);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Override3DAttributes  (IntPtr channelgroup, ref VECTOR pos, ref VECTOR vel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverrideSpeakerMix(IntPtr channelgroup, float frontleft, float frontright, float center, float lfe, float backleft, float backright, float sideleft, float sideright);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_AddGroup         (IntPtr channelgroup, IntPtr group);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetNumGroups     (IntPtr channelgroup, ref int numgroups);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetGroup         (IntPtr channelgroup, int index, ref IntPtr group);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetParentGroup   (IntPtr channelgroup, ref IntPtr group);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetDSPHead       (IntPtr channelgroup, ref IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_AddDSP           (IntPtr channelgroup, IntPtr dsp, ref IntPtr dspconnection);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetName          (IntPtr channelgroup, StringBuilder name, int namelen);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetNumChannels   (IntPtr channelgroup, ref int numchannels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetChannel       (IntPtr channelgroup, int index, ref IntPtr channel);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetSpectrum      (IntPtr channelgroup, [MarshalAs(UnmanagedType.LPArray)] float[] spectrumarray, int numvalues, int channeloffset, DSP_FFT_WINDOW windowtype);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetWaveData      (IntPtr channelgroup, [MarshalAs(UnmanagedType.LPArray)] float[] wavearray, int numvalues, int channeloffset);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetUserData      (IntPtr channelgroup, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetUserData      (IntPtr channelgroup, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetMemoryInfo    (IntPtr channelgroup, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion

        #region wrapperinternal

        private IntPtr channelgroupraw;

        public void setRaw(IntPtr channelgroup)
        {
            channelgroupraw = new IntPtr();

            channelgroupraw = channelgroup;
        }

        public IntPtr getRaw()
        {
            return channelgroupraw;
        }

        #endregion
    }


    /*
        'SoundGroup' API
    */
    public class SoundGroup
    {
        public RESULT release                ()
        {
            return FMOD_SoundGroup_Release(soundgroupraw);
        }

        public RESULT getSystemObject        (ref System system)
        {
            RESULT result         = RESULT.OK;
            IntPtr systemraw      = new IntPtr();
            System systemnew      = null;

            try
            {
                result = FMOD_SoundGroup_GetSystemObject(soundgroupraw, ref systemraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (system == null)
            {
                systemnew = new System();
                systemnew.setRaw(systemraw);
                system = systemnew;
            }
            else
            {
                system.setRaw(systemraw);
            }

            return result; 
        }

        // SoundGroup control functions.
        public RESULT setMaxAudible          (int maxaudible)
        {
            return FMOD_SoundGroup_SetMaxAudible(soundgroupraw, maxaudible);
        }

        public RESULT getMaxAudible          (ref int maxaudible)
        {
            return FMOD_SoundGroup_GetMaxAudible(soundgroupraw, ref maxaudible);
        }

        public RESULT setMaxAudibleBehavior  (SOUNDGROUP_BEHAVIOR behavior)
        {
            return FMOD_SoundGroup_SetMaxAudibleBehavior(soundgroupraw, behavior);
        }
        public RESULT getMaxAudibleBehavior  (ref SOUNDGROUP_BEHAVIOR behavior)
        {
            return FMOD_SoundGroup_GetMaxAudibleBehavior(soundgroupraw, ref behavior);
        }
        public RESULT setMuteFadeSpeed       (float speed)
        {
            return FMOD_SoundGroup_SetMuteFadeSpeed(soundgroupraw, speed);
        }
        public RESULT getMuteFadeSpeed       (ref float speed)
        {
            return FMOD_SoundGroup_GetMuteFadeSpeed(soundgroupraw, ref speed);
        }

        // Information only functions.
        public RESULT getName                (StringBuilder name, int namelen)
        {
            return FMOD_SoundGroup_GetName(soundgroupraw, name, namelen);
        }
        public RESULT getNumSounds           (ref int numsounds)
        {
            return FMOD_SoundGroup_GetNumSounds(soundgroupraw, ref numsounds);
        }
        public RESULT getSound               (int index, ref Sound sound)
        {
            RESULT result         = RESULT.OK;
            IntPtr soundraw      = new IntPtr();
            Sound soundnew      = null;

            try
            {
                result = FMOD_SoundGroup_GetSound(soundgroupraw, index, ref soundraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (sound == null)
            {
                soundnew = new Sound();
                soundnew.setRaw(soundraw);
                sound = soundnew;
            }
            else
            {
                sound.setRaw(soundraw);
            }

            return result; 
        }
        public RESULT getNumPlaying          (ref int numplaying)
        {
            return FMOD_SoundGroup_GetNumPlaying(soundgroupraw, ref numplaying);
        }

        // Userdata set/get.
        public RESULT setUserData            (IntPtr userdata)
        {
            return FMOD_SoundGroup_SetUserData(soundgroupraw, userdata);
        }
        public RESULT getUserData            (ref IntPtr userdata)
        {
            return FMOD_SoundGroup_GetUserData(soundgroupraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_SoundGroup_GetMemoryInfo(soundgroupraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }

        #region importfunctions
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_Release            (IntPtr soundgroupraw);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetSystemObject    (IntPtr soundgroupraw, ref IntPtr system);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetMaxAudible      (IntPtr soundgroupraw, int maxaudible);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMaxAudible      (IntPtr soundgroupraw, ref int maxaudible);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetMaxAudibleBehavior(IntPtr soundgroupraw, SOUNDGROUP_BEHAVIOR behavior);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMaxAudibleBehavior(IntPtr soundgroupraw, ref SOUNDGROUP_BEHAVIOR behavior);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetMuteFadeSpeed   (IntPtr soundgroupraw, float speed);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMuteFadeSpeed   (IntPtr soundgroupraw, ref float speed);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetName            (IntPtr soundgroupraw, StringBuilder name, int namelen);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetNumSounds       (IntPtr soundgroupraw, ref int numsounds);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetSound           (IntPtr soundgroupraw, int index, ref IntPtr sound);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetNumPlaying      (IntPtr soundgroupraw, ref int numplaying);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetUserData        (IntPtr soundgroupraw, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetUserData        (IntPtr soundgroupraw, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMemoryInfo      (IntPtr soundgroupraw, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion

        #region wrapperinternal

        private IntPtr soundgroupraw;

        public void setRaw(IntPtr soundgroup)
        {
            soundgroupraw = new IntPtr();

            soundgroupraw = soundgroup;
        }

        public IntPtr getRaw()
        {
            return soundgroupraw;
        }

        #endregion
    }


    /*
        'DSP' API
    */
    public class DSP
    {
        public RESULT release                   ()
        {
            return FMOD_DSP_Release(dspraw);
        }
        public RESULT getSystemObject           (ref System system)
        {
            RESULT result         = RESULT.OK;
            IntPtr systemraw      = new IntPtr();
            System systemnew      = null;

            try
            {
                result = FMOD_DSP_GetSystemObject(dspraw, ref systemraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (system == null)
            {
                systemnew = new System();
                systemnew.setRaw(dspraw);
                system = systemnew;
            }
            else
            {
                system.setRaw(systemraw);
            }

            return result;             
        }
                     

        public RESULT addInput                  (DSP target, ref DSPConnection dspconnection)
        {
            RESULT result = RESULT.OK;
            IntPtr dspconnectionraw = new IntPtr();
            DSPConnection dspconnectionnew = null;

            try
            {
                result = FMOD_DSP_AddInput(dspraw, target.getRaw(), ref dspconnectionraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (dspconnection == null)
            {
                dspconnectionnew = new DSPConnection();
                dspconnectionnew.setRaw(dspconnectionraw);
                dspconnection = dspconnectionnew;
            }
            else
            {
                dspconnection.setRaw(dspconnectionraw);
            }

            return result;  
        }
        public RESULT disconnectFrom            (DSP target)
        {
            return FMOD_DSP_DisconnectFrom(dspraw, target.getRaw());
        }
        public RESULT disconnectAll             (bool inputs, bool outputs)
        {
            return FMOD_DSP_DisconnectAll(dspraw, (inputs ? 1 : 0), (outputs ? 1 : 0));
        }
        public RESULT remove                    ()
        {
            return FMOD_DSP_Remove(dspraw);
        }
        public RESULT getNumInputs              (ref int numinputs)
        {
            return FMOD_DSP_GetNumInputs(dspraw, ref numinputs);
        }
        public RESULT getNumOutputs             (ref int numoutputs)
        {
            return FMOD_DSP_GetNumOutputs(dspraw, ref numoutputs);
        }
        public RESULT getInput                  (int index, ref DSP input, ref DSPConnection inputconnection)
        {
            RESULT result      = RESULT.OK;
            IntPtr dsprawnew   = new IntPtr();
            DSP    dspnew      = null;
            IntPtr dspconnectionraw = new IntPtr();
            DSPConnection dspconnectionnew = null;

            try
            {
                result = FMOD_DSP_GetInput(dspraw, index, ref dsprawnew, ref dspconnectionraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (input == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dsprawnew);
                input = dspnew;
            }
            else
            {
                input.setRaw(dsprawnew);
            }

            if (inputconnection == null)
            {
                dspconnectionnew = new DSPConnection();
                dspconnectionnew.setRaw(dspconnectionraw);
                inputconnection = dspconnectionnew;
            }
            else
            {
                inputconnection.setRaw(dspconnectionraw);
            }

            return result; 
        }
        public RESULT getOutput                 (int index, ref DSP output, ref DSPConnection outputconnection)
        {
            RESULT result      = RESULT.OK;
            IntPtr dsprawnew   = new IntPtr();
            DSP    dspnew      = null;
            IntPtr dspconnectionraw = new IntPtr();
            DSPConnection dspconnectionnew = null;

            try
            {
                result = FMOD_DSP_GetOutput(dspraw, index, ref dsprawnew, ref dspconnectionraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (output == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dsprawnew);
                output = dspnew;
            }
            else
            {
                output.setRaw(dsprawnew);
            }

            if (outputconnection == null)
            {
                dspconnectionnew = new DSPConnection();
                dspconnectionnew.setRaw(dspconnectionraw);
                outputconnection = dspconnectionnew;
            }
            else
            {
                outputconnection.setRaw(dspconnectionraw);
            }

            return result; 
        }

        public RESULT setActive                 (bool active)
        {
            return FMOD_DSP_SetActive(dspraw, (active ? 1 : 0));
        }
        public RESULT getActive                 (ref bool active)
        {
            RESULT result;
            int a = 0;

            result = FMOD_DSP_GetActive(dspraw, ref a);

            active = (a != 0);

            return result;
        }
        public RESULT setBypass                 (bool bypass)
        {
            return FMOD_DSP_SetBypass(dspraw, (bypass? 1 : 0));
        }
        public RESULT getBypass                 (ref bool bypass)
        {
            RESULT result;
            int b = 0;

            result = FMOD_DSP_GetBypass(dspraw, ref b);

            bypass = (b != 0);

            return result;
        }
        public RESULT reset                     ()
        {
            return FMOD_DSP_Reset(dspraw);
        }

                     
        public RESULT setParameter              (int index, float val)
        {
            return FMOD_DSP_SetParameter(dspraw, index, val);
        }
        public RESULT getParameter              (int index, ref float val, StringBuilder valuestr, int valuestrlen)
        {
            return FMOD_DSP_GetParameter(dspraw, index, ref val, valuestr, valuestrlen);
        }
        public RESULT getNumParameters          (ref int numparams)
        {
            return FMOD_DSP_GetNumParameters(dspraw, ref numparams);
        }
        public RESULT getParameterInfo          (int index, StringBuilder name, StringBuilder label, StringBuilder description, int descriptionlen, ref float min, ref float max)
        {
            return FMOD_DSP_GetParameterInfo(dspraw, index, name, label, description, descriptionlen, ref min, ref max);
        }
        public RESULT showConfigDialog          (IntPtr hwnd, bool show)
        {
            return FMOD_DSP_ShowConfigDialog          (dspraw, hwnd, show);
        }


        public RESULT getInfo                   (StringBuilder name, ref uint version, ref int channels, ref int configwidth, ref int configheight)
        {
            return FMOD_DSP_GetInfo(dspraw, name, ref version, ref channels, ref configwidth, ref configheight);
        }
        public RESULT getType                   (ref DSP_TYPE type)
        {
            return FMOD_DSP_GetType(dspraw, ref type);
        }
        public RESULT setDefaults               (float frequency, float volume, float pan, int priority)
        {
            return FMOD_DSP_SetDefaults(dspraw, frequency, volume, pan, priority);
        }
        public RESULT getDefaults               (ref float frequency, ref float volume, ref float pan, ref int priority)
        {
            return FMOD_DSP_GetDefaults(dspraw, ref frequency, ref volume, ref pan, ref priority);
        }


        public RESULT setUserData               (IntPtr userdata)
        {
            return FMOD_DSP_SetUserData(dspraw, userdata);
        }
        public RESULT getUserData               (ref IntPtr userdata)
        {
            return FMOD_DSP_GetUserData(dspraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_DSP_GetMemoryInfo(dspraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }

        #region importfunctions

        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_Release                   (IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetSystemObject           (IntPtr dsp, ref IntPtr system);
        [DllImport (VERSION.dll)]                   
        private static extern RESULT FMOD_DSP_AddInput                  (IntPtr dsp, IntPtr target, ref IntPtr dspconnection);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_DisconnectFrom            (IntPtr dsp, IntPtr target);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_DisconnectAll             (IntPtr dsp, int inputs, int outputs);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_Remove                    (IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetNumInputs              (IntPtr dsp, ref int numinputs);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetNumOutputs             (IntPtr dsp, ref int numoutputs);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetInput                  (IntPtr dsp, int index, ref IntPtr input, ref IntPtr inputconnection);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetOutput                 (IntPtr dsp, int index, ref IntPtr output, ref IntPtr outputconnection);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetActive                 (IntPtr dsp, int active);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetActive                 (IntPtr dsp, ref int active);    
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetBypass                 (IntPtr dsp, int bypass);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetBypass                 (IntPtr dsp, ref int bypass);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_Reset                     (IntPtr dsp);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetParameter              (IntPtr dsp, int index, float val);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameter              (IntPtr dsp, int index, ref float val, StringBuilder valuestr, int valuestrlen);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetNumParameters          (IntPtr dsp, ref int numparams);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameterInfo          (IntPtr dsp, int index, StringBuilder name, StringBuilder label, StringBuilder description, int descriptionlen, ref float min, ref float max);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_ShowConfigDialog          (IntPtr dsp, IntPtr hwnd, bool show);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetInfo                   (IntPtr dsp, StringBuilder name, ref uint version, ref int channels, ref int configwidth, ref int configheight);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetType                   (IntPtr dsp, ref DSP_TYPE type);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetDefaults               (IntPtr dsp, float frequency, float volume, float pan, int priority);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetDefaults               (IntPtr dsp, ref float frequency, ref float volume, ref float pan, ref int priority);
        [DllImport (VERSION.dll)]                   
        private static extern RESULT FMOD_DSP_SetUserData               (IntPtr dsp, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetUserData               (IntPtr dsp, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetMemoryInfo             (IntPtr dsp, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion

        #region wrapperinternal

        private IntPtr dspraw;

        public void setRaw(IntPtr dsp)
        {
            dspraw = new IntPtr();

            dspraw = dsp;
        }

        public IntPtr getRaw()
        {
            return dspraw;
        }

        #endregion
    }


    /*
        'DSPConnection' API
    */
    public class DSPConnection
    {
        public RESULT getInput              (ref DSP input)
        {
            RESULT result = RESULT.OK;
            IntPtr dspraw = new IntPtr();
            DSP    dspnew = null;

            try
            {
                result = FMOD_DSPConnection_GetInput(dspconnectionraw, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (input == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                input = dspnew;
            }
            else
            {
                input.setRaw(dspraw);
            }

            return result;
        }
        public RESULT getOutput             (ref DSP output)
        {
            RESULT result = RESULT.OK;
            IntPtr dspraw = new IntPtr();
            DSP dspnew = null;

            try
            {
                result = FMOD_DSPConnection_GetOutput(dspconnectionraw, ref dspraw);
            }
            catch
            {
                result = RESULT.ERR_INVALID_PARAM;
            }
            if (result != RESULT.OK)
            {
                return result;
            }

            if (output == null)
            {
                dspnew = new DSP();
                dspnew.setRaw(dspraw);
                output = dspnew;
            }
            else
            {
                output.setRaw(dspraw);
            }

            return result;
        }
        public RESULT setMix                (float volume)
        {
            return FMOD_DSPConnection_SetMix(dspconnectionraw, volume);
        }
        public RESULT getMix                (ref float volume)
        {
            return FMOD_DSPConnection_GetMix(dspconnectionraw, ref volume);
        }
        public RESULT setLevels             (SPEAKER speaker, float[] levels, int numlevels)
        {
            return FMOD_DSPConnection_SetLevels(dspconnectionraw, speaker, levels, numlevels);
        }
        public RESULT getLevels             (SPEAKER speaker, float[] levels, int numlevels)
        {
            return FMOD_DSPConnection_GetLevels(dspconnectionraw, speaker, levels, numlevels);
        }
        public RESULT setUserData(IntPtr userdata)
        {
            return FMOD_DSPConnection_SetUserData(dspconnectionraw, userdata);
        }
        public RESULT getUserData(ref IntPtr userdata)
        {
            return FMOD_DSPConnection_GetUserData(dspconnectionraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_DSPConnection_GetMemoryInfo(dspconnectionraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }

        #region importfunctions

        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetInput        (IntPtr dspconnection, ref IntPtr input);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetOutput       (IntPtr dspconnection, ref IntPtr output);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_SetMix          (IntPtr dspconnection, float volume);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetMix          (IntPtr dspconnection, ref float volume);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_SetLevels       (IntPtr dspconnection, SPEAKER speaker, float[] levels, int numlevels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetLevels       (IntPtr dspconnection, SPEAKER speaker, float[] levels, int numlevels);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_SetUserData     (IntPtr dspconnection, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetUserData     (IntPtr dspconnection, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetMemoryInfo   (IntPtr dspconnection, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion

        #region wrapperinternal

        private IntPtr dspconnectionraw;

        public void setRaw(IntPtr dspconnection)
        {
            dspconnectionraw = new IntPtr();

            dspconnectionraw = dspconnection;
        }

        public IntPtr getRaw()
        {
            return dspconnectionraw;
        }

        #endregion
    }

    /*
        'Geometry' API
    */
    public class Geometry
    {
        public RESULT release               ()
        {
            return FMOD_Geometry_Release(geometryraw);
        }       
        public RESULT addPolygon            (float directOcclusion, float reverbOcclusion, bool doubleSided, int numVertices, ref VECTOR vertices, ref int polygonIndex)
        {
            return FMOD_Geometry_AddPolygon(geometryraw, directOcclusion, reverbOcclusion, doubleSided, numVertices, ref vertices, ref polygonIndex);
        }


        public RESULT getNumPolygons        (ref int numPolygons)
        {
            return FMOD_Geometry_GetNumPolygons(geometryraw, ref numPolygons);
        }
        public RESULT getMaxPolygons        (ref int maxPolygons, ref int maxVertices)
        {
            return FMOD_Geometry_GetMaxPolygons(geometryraw, ref maxPolygons, ref maxVertices);
        }
        public RESULT getPolygonNumVertices (int polygonIndex, ref int numVertices)
        {
            return FMOD_Geometry_GetPolygonNumVertices(geometryraw, polygonIndex, ref numVertices);
        }
        public RESULT setPolygonVertex      (int polygonIndex, int vertexIndex, ref VECTOR vertex)
        {
            return FMOD_Geometry_SetPolygonVertex(geometryraw, polygonIndex, vertexIndex, ref vertex);
        }
        public RESULT getPolygonVertex      (int polygonIndex, int vertexIndex, ref VECTOR vertex)
        {
            return FMOD_Geometry_GetPolygonVertex(geometryraw, polygonIndex, vertexIndex, ref vertex);
        }
        public RESULT setPolygonAttributes  (int polygonIndex, float directOcclusion, float reverbOcclusion, bool doubleSided)
        {
            return FMOD_Geometry_SetPolygonAttributes(geometryraw, polygonIndex, directOcclusion, reverbOcclusion, doubleSided);
        }
        public RESULT getPolygonAttributes  (int polygonIndex, ref float directOcclusion, ref float reverbOcclusion, ref bool doubleSided)
        {
            return FMOD_Geometry_GetPolygonAttributes(geometryraw, polygonIndex, ref directOcclusion, ref reverbOcclusion, ref doubleSided);
        }

        public RESULT setActive             (bool active)
        {
            return FMOD_Geometry_SetActive  (geometryraw, active);
        }
        public RESULT getActive             (ref bool active)
        {
            return FMOD_Geometry_GetActive  (geometryraw, ref active);
        }
        public RESULT setRotation           (ref VECTOR forward, ref VECTOR up)
        {
            return FMOD_Geometry_SetRotation(geometryraw, ref forward, ref up);
        }
        public RESULT getRotation           (ref VECTOR forward, ref VECTOR up)
        {
            return FMOD_Geometry_GetRotation(geometryraw, ref forward, ref up);
        }
        public RESULT setPosition           (ref VECTOR position)
        {
            return FMOD_Geometry_SetPosition(geometryraw, ref position);
        }
        public RESULT getPosition           (ref VECTOR position)
        {
            return FMOD_Geometry_GetPosition(geometryraw, ref position);
        }
        public RESULT setScale              (ref VECTOR scale)
        {
            return FMOD_Geometry_SetScale(geometryraw, ref scale);
        }
        public RESULT getScale              (ref VECTOR scale)
        {
            return FMOD_Geometry_GetScale(geometryraw, ref scale);
        }
        public RESULT save                  (IntPtr data, ref int datasize)
        {
            return FMOD_Geometry_Save(geometryraw, data, ref datasize);
        }


        public RESULT setUserData               (IntPtr userdata)
        {
            return FMOD_Geometry_SetUserData(geometryraw, userdata);
        }
        public RESULT getUserData               (ref IntPtr userdata)
        {
            return FMOD_Geometry_GetUserData(geometryraw, ref userdata);
        }

        public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
        {
            return FMOD_Geometry_GetMemoryInfo(geometryraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
        }

        #region importfunctions

        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_Release   (IntPtr geometry);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_AddPolygon           (IntPtr geometry, float directOcclusion, float reverbOcclusion, bool doubleSided, int numVertices, ref VECTOR vertices, ref int polygonIndex);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetNumPolygons       (IntPtr geometry, ref int numPolygons);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetMaxPolygons       (IntPtr geometry, ref int maxPolygons, ref int maxVertices);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPolygonNumVertices(IntPtr geometry, int polygonIndex, ref int numVertices);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetPolygonVertex     (IntPtr geometry, int polygonIndex, int vertexIndex, ref VECTOR vertex);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPolygonVertex     (IntPtr geometry, int polygonIndex, int vertexIndex, ref VECTOR vertex);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetPolygonAttributes (IntPtr geometry, int polygonIndex, float directOcclusion, float reverbOcclusion, bool doubleSided);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPolygonAttributes (IntPtr geometry, int polygonIndex, ref float directOcclusion, ref float reverbOcclusion, ref bool doubleSided);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_Flush                (IntPtr geometry);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetActive                    (IntPtr gemoetry, bool active);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetActive                    (IntPtr gemoetry, ref bool active);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetRotation          (IntPtr geometry, ref VECTOR forward, ref VECTOR up);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetRotation          (IntPtr geometry, ref VECTOR forward, ref VECTOR up);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetPosition          (IntPtr geometry, ref VECTOR position);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPosition          (IntPtr geometry, ref VECTOR position);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetScale             (IntPtr geometry, ref VECTOR scale);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetScale             (IntPtr geometry, ref VECTOR scale);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_Save                 (IntPtr geometry, IntPtr data, ref int datasize);
        [DllImport (VERSION.dll)]                   
        private static extern RESULT FMOD_Geometry_SetUserData          (IntPtr geometry, IntPtr userdata);
        [DllImport (VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetUserData          (IntPtr geometry, ref IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetMemoryInfo        (IntPtr geometry, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
        #endregion

        #region wrapperinternal

        private IntPtr geometryraw;

        public void setRaw(IntPtr geometry)
        {
            geometryraw = new IntPtr();

            geometryraw = geometry;
        }

        public IntPtr getRaw()
        {
            return geometryraw;
        }

        #endregion

        /*
            'Reverb' API
        */
        public class Reverb
        { 

            public RESULT release                ()
            {
                return FMOD_Reverb_Release(reverbraw);
            }

            // Reverb manipulation.
            public RESULT set3DAttributes        (ref VECTOR position, float mindistance, float maxdistance)
            {
                return FMOD_Reverb_Set3DAttributes(reverbraw, ref position, mindistance, maxdistance);
            }
            public RESULT get3DAttributes        (ref VECTOR position, ref float mindistance, ref float maxdistance)
            {
                return FMOD_Reverb_Get3DAttributes(reverbraw, ref position, ref mindistance, ref maxdistance);
            }
            public RESULT setProperties          (ref REVERB_PROPERTIES properties)
            {
                return FMOD_Reverb_SetProperties(reverbraw, ref properties);
            }
            public RESULT getProperties          (ref REVERB_PROPERTIES properties)
            {
                return FMOD_Reverb_GetProperties(reverbraw, ref properties);
            }
            public RESULT setActive              (int active)
            {
                return FMOD_Reverb_SetActive(reverbraw, active);
            }
            public RESULT getActive              (ref int active)
            {
                return FMOD_Reverb_GetActive(reverbraw, ref active);
            }

            // Userdata set/get.
            public RESULT setUserData            (IntPtr userdata)
            {
                return FMOD_Reverb_SetUserData(reverbraw, userdata);
            }
            public RESULT getUserData            (ref IntPtr userdata)
            {
                return FMOD_Reverb_GetUserData(reverbraw, ref userdata);
            }

            public RESULT getMemoryInfo(uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array)
            {
                return FMOD_Reverb_GetMemoryInfo(reverbraw, memorybits, event_memorybits, ref memoryused, memoryused_array);
            }

            #region importfunctions

            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_Release                (IntPtr reverb);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_Set3DAttributes        (IntPtr reverb, ref VECTOR position, float mindistance, float maxdistance);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_Get3DAttributes        (IntPtr reverb, ref VECTOR position, ref float mindistance, ref float maxdistance);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_SetProperties          (IntPtr reverb, ref REVERB_PROPERTIES properties);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_GetProperties          (IntPtr reverb, ref REVERB_PROPERTIES properties);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_SetActive              (IntPtr reverb, int active);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_GetActive              (IntPtr reverb, ref int active);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_SetUserData            (IntPtr reverb, IntPtr userdata);
            [DllImport (VERSION.dll)]
            private static extern RESULT FMOD_Reverb_GetUserData            (IntPtr reverb, ref IntPtr userdata);
            [DllImport(VERSION.dll)]
            private static extern RESULT FMOD_Reverb_GetMemoryInfo          (IntPtr reverb, uint memorybits, uint event_memorybits, ref uint memoryused, IntPtr memoryused_array);
            #endregion

            #region wrapperinternal

            private IntPtr reverbraw;

            public void setRaw(IntPtr rev)
            {
                reverbraw = new IntPtr();

                reverbraw = rev;
            }

            public IntPtr getRaw()
            {
                return reverbraw;
            }

            #endregion
        }
    }
}


/* NEXT FILE */
/*$ preserve start $*/
/* ========================================================================================== */
/* FMOD Ex - DSP header file. Copyright (c), Firelight Technologies Pty, Ltd. 2004-2008.      */
/*                                                                                            */
/* Use this header if you are interested in delving deeper into the FMOD software mixing /    */
/* DSP engine.  In this header you can find parameter structures for FMOD system reigstered   */
/* DSP effects and generators.                                                                */
/*                                                                                            */
/* ========================================================================================== */

namespace FMOD
{
/*$ preserve end $*/

    /* 
        DSP callbacks
    */
    public delegate RESULT DSP_CREATECALLBACK         (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_RELEASECALLBACK        (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_RESETCALLBACK          (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_READCALLBACK           (ref DSP_STATE dsp_state, IntPtr inbuffer, IntPtr outbuffer, uint length, int inchannels, int outchannels);
    public delegate RESULT DSP_SETPOSITIONCALLBACK    (ref DSP_STATE dsp_state, uint seeklen);
    public delegate RESULT DSP_SETPARAMCALLBACK       (ref DSP_STATE dsp_state, int index, float val);
    public delegate RESULT DSP_GETPARAMCALLBACK       (ref DSP_STATE dsp_state, int index, ref float val, StringBuilder valuestr);
    public delegate RESULT DSP_DIALOGCALLBACK         (ref DSP_STATE dsp_state, IntPtr hwnd, bool show);


    /*
    [ENUM]
    [
        [DESCRIPTION]   
        These definitions can be used for creating FMOD defined special effects or DSP units.

        [REMARKS]
        To get them to be active, first create the unit, then add it somewhere into the DSP network, either at the front of the network near the soundcard unit to affect the global output (by using System::getDSPHead), or on a single channel (using Channel::getDSPHead).

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::createDSPByType
    ]
    */
    public enum DSP_TYPE
    {
        UNKNOWN,            /* This unit was created via a non FMOD plugin so has an unknown purpose */
        MIXER,              /* This unit does nothing but take inputs and mix them together then feed the result to the soundcard unit. */
        OSCILLATOR,         /* This unit generates sine/square/saw/triangle or noise tones. */
        LOWPASS,            /* This unit filters sound using a high quality, resonant lowpass filter algorithm but consumes more CPU time. */
        ITLOWPASS,          /* This unit filters sound using a resonant lowpass filter algorithm that is used in Impulse Tracker, but with limited cutoff range (0 to 8060hz). */
        HIGHPASS,           /* This unit filters sound using a resonant highpass filter algorithm. */
        ECHO,               /* This unit produces an echo on the sound and fades out at the desired rate. */
        FLANGE,             /* This unit produces a flange effect on the sound. */
        DISTORTION,         /* This unit distorts the sound. */
        NORMALIZE,          /* This unit normalizes or amplifies the sound to a certain level. */
        PARAMEQ,            /* This unit attenuates or amplifies a selected frequency range. */
        PITCHSHIFT,         /* This unit bends the pitch of a sound without changing the speed of playback. */
        CHORUS,             /* This unit produces a chorus effect on the sound. */
        REVERB,             /* This unit produces a reverb effect on the sound. */
        VSTPLUGIN,          /* This unit allows the use of Steinberg VST plugins */
        WINAMPPLUGIN,       /* This unit allows the use of Nullsoft Winamp plugins */
        ITECHO,             /* This unit produces an echo on the sound and fades out at the desired rate as is used in Impulse Tracker. */
        COMPRESSOR,         /* This unit implements dynamic compression (linked multichannel, wideband) */
        SFXREVERB,          /* This unit implements SFX reverb */
        LOWPASS_SIMPLE      /* This unit filters sound using a simple lowpass with no resonance, but has flexible cutoff and is fast. */
    }


    /*
    [STRUCTURE]
    [
        [DESCRIPTION]   

        [REMARKS]
        Members marked with [in] mean the user sets the value before passing it to the function.&lt;br&gt;
        Members marked with [out] mean FMOD sets the value to be used after the function exits.&lt;br&gt;
        &lt;br&gt;
        The step parameter tells the gui or application that the parameter has a certain granularity.&lt;br&gt;
        For example in the example of cutoff frequency with a range from 100.0 to 22050.0 you might only want the selection to be in 10hz increments.  For this you would simply use 10.0 as the step value.&lt;br&gt;
        For a boolean, you can use min = 0.0, max = 1.0, step = 1.0.  This way the only possible values are 0.0 and 1.0.&lt;br&gt;
        Some applications may detect min = 0.0, max = 1.0, step = 1.0 and replace a graphical slider bar with a checkbox instead.&lt;br&gt;
        A step value of 1.0 would simulate integer values only.&lt;br&gt;
        A step value of 0.0 would mean the full floating point range is accessable.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]    
        System::createDSP
        System::getDSP
    ]
    */
    public struct DSP_PARAMETERDESC
    {
        public float         min;             /* [in] Minimum value of the parameter (ie 100.0). */
        public float         max;             /* [in] Maximum value of the parameter (ie 22050.0). */
        public float         defaultval;      /* [in] Default value of parameter. */
        public string        name;            /* [in] Name of the parameter to be displayed (ie "Cutoff frequency"). */
        public string        label;           /* [in] Short string to be put next to value to denote the unit type (ie "hz"). */
        public string        description;     /* [in] Description of the parameter to be displayed as a help item / tooltip for this parameter. */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Strcture to define the parameters for a DSP unit.

        [REMARKS]
        Members marked with [in] mean the user sets the value before passing it to the function.&lt;br&gt;
        Members marked with [out] mean FMOD sets the value to be used after the function exits.&lt;br&gt;
        &lt;br&gt;
        There are 2 different ways to change a parameter in this architecture.&lt;br&gt;
        One is to use DSP::setParameter / DSP::getParameter.  This is platform independant and is dynamic, so new unknown plugins can have their parameters enumerated and used.&lt;br&gt;
        The other is to use DSP::showConfigDialog.  This is platform specific and requires a GUI, and will display a dialog box to configure the plugin.&lt;br&gt;
        
        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        System::createDSP
        System::getDSP
    ]
    */
    public struct DSP_DESCRIPTION
    {
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=32)]
        public char[]                      name;               /* [in] Name of the unit to be displayed in the network. */
        public uint                        version;            /* [in] Plugin writer's version number. */
        public int                         channels;           /* [in] Number of channels.  Use 0 to process whatever number of channels is currently in the network.  &gt;0 would be mostly used if the unit is a unit that only generates sound. */
        public DSP_CREATECALLBACK          create;             /* [in] Create callback.  This is called when DSP unit is created.  Can be null. */
        public DSP_RELEASECALLBACK         release;            /* [in] Release callback.  This is called just before the unit is freed so the user can do any cleanup needed for the unit.  Can be null. */
        public DSP_RESETCALLBACK           reset;              /* [in] Reset callback.  This is called by the user to reset any history buffers that may need resetting for a filter, when it is to be used or re-used for the first time to its initial clean state.  Use to avoid clicks or artifacts. */
        public DSP_READCALLBACK            read;               /* [in] Read callback.  Processing is done here.  Can be null. */
        public DSP_SETPOSITIONCALLBACK     setposition;        /* [in] Setposition callback.  This is called if the unit wants to update its position info but not process data.  Can be null. */

        public int                         numparameters;      /* [in] Number of parameters used in this filter.  The user finds this with DSP::getNumParameters */
        public DSP_PARAMETERDESC[]         paramdesc;          /* [in] Variable number of parameter structures. */
        public DSP_SETPARAMCALLBACK        setparameter;       /* [in] This is called when the user calls DSP::setParameter.  Can be null. */
        public DSP_GETPARAMCALLBACK        getparameter;       /* [in] This is called when the user calls DSP::getParameter.  Can be null. */
        public DSP_DIALOGCALLBACK          config;             /* [in] This is called when the user calls DSP::showConfigDialog.  Can be used to display a dialog to configure the filter.  Can be null. */
        public int                         configwidth;        /* [in] Width of config dialog graphic if there is one.  0 otherwise.*/
        public int                         configheight;       /* [in] Height of config dialog graphic if there is one.  0 otherwise.*/
        public IntPtr                      userdata;           /* [in] Optional. Specify 0 to ignore. This is user data to be attached to the DSP unit during creation.  Access via DSP::getUserData. */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        DSP plugin structure that is passed into each callback.

        [REMARKS]
        Members marked with [in] mean the variable can be written to.  The user can set the value.&lt;br&gt;
        Members marked with [out] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3

        [SEE_ALSO]
        FMOD_DSP_DESCRIPTION
    ]
    */
    public struct DSP_STATE
    {
        public IntPtr   instance;      /* [out] Handle to the DSP hand the user created.  Not to be modified.  C++ users cast to FMOD::DSP to use.  */
        public IntPtr   plugindata;    /* [in] Plugin writer created data the output author wants to attach to this object. */
        public ushort   speakermask;   /* Specifies which speakers the DSP effect is active on */
    };


    /*
        ==============================================================================================================

        FMOD built in effect parameters.  
        Use DSP::setParameter with these enums for the 'index' parameter.

        ==============================================================================================================
    */

    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_OSCILLATOR filter.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE   
    ]
    */
    public enum DSP_OSCILLATOR
    {
        TYPE,   /* Waveform type.  0 = sine.  1 = square. 2 = sawup. 3 = sawdown. 4 = triangle. 5 = noise.  */
        RATE    /* Frequency of the sinewave in hz.  1.0 to 22000.0.  Default = 220.0. */         
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_LOWPASS filter.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_LOWPASS
    {
        CUTOFF,    /* Lowpass cutoff frequency in hz.   1.0 to 22000.0.  Default = 5000.0. */
        RESONANCE  /* Lowpass resonance Q value. 1.0 to 10.0.  Default = 1.0. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_ITLOWPASS filter.
        This is different to the default FMOD_DSP_TYPE_ITLOWPASS filter in that it uses a different quality algorithm and is 
        the filter used to produce the correct sounding playback in .IT files.&lt;br&gt; 
        FMOD Ex's .IT playback uses this filter.&lt;br&gt;

        [REMARKS]
        Note! This filter actually has a limited cutoff frequency below the specified maximum, due to its limited design, 
        so for a more  open range filter use FMOD_DSP_LOWPASS or if you don't mind not having resonance, 
        FMOD_DSP_LOWPASS_SIMPLE.&lt;br&gt;
        The effective maximum cutoff is about 8060hz.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_ITLOWPASS
    {
        CUTOFF,    /* Lowpass cutoff frequency in hz.  1.0 to 22000.0.  Default = 5000.0/ */
        RESONANCE  /* Lowpass resonance Q value.  0.0 to 127.0.  Default = 1.0. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_HIGHPASS filter.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_HIGHPASS
    {
        CUTOFF,    /* Highpass cutoff frequency in hz.  10.0 to output 22000.0.  Default = 5000.0. */
        RESONANCE  /* Highpass resonance Q value.  1.0 to 10.0.  Default = 1.0. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_ECHO filter.

        [REMARKS]
        Note.  Every time the delay is changed, the plugin re-allocates the echo buffer.  This means the echo will dissapear at that time while it refills its new buffer.&lt;br&gt;
        Larger echo delays result in larger amounts of memory allocated.&lt;br&gt;
        &lt;br&gt;
        '&lt;i&gt;maxchannels&lt;/i&gt;' also dictates the amount of memory allocated.  By default, the maxchannels value is 0.  If FMOD is set to stereo, the echo unit will allocate enough memory for 2 channels.  If it is 5.1, it will allocate enough memory for a 6 channel echo, etc.&lt;br&gt;
        If the echo effect is only ever applied to the global mix (ie it was added with System::addDSP), then 0 is the value to set as it will be enough to handle all speaker modes.&lt;br&gt;
        When the echo is added to a channel (ie Channel::addDSP) then the channel count that comes in could be anything from 1 to 8 possibly.  It is only in this case where you might want to increase the channel count above the output's channel count.&lt;br&gt;
        If a channel echo is set to a lower number than the sound's channel count that is coming in, it will not echo the sound.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_ECHO
    {
        DELAY,       /* Echo delay in ms.  10  to 5000.  Default = 500. */
        DECAYRATIO,  /* Echo decay per delay.  0 to 1.  1.0 = No decay, 0.0 = total decay.  Default = 0.5. */
        MAXCHANNELS, /* Maximum channels supported.  0 to 16.  0 = same as fmod's default output polyphony, 1 = mono, 2 = stereo etc.  See remarks for more.  Default = 0.  It is suggested to leave at 0! */
        DRYMIX,      /* Volume of original signal to pass to output.  0.0 to 1.0. Default = 1.0. */
        WETMIX       /* Volume of echo signal to pass to output.  0.0 to 1.0. Default = 1.0. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_FLANGE filter.

        [REMARKS]
        Flange is an effect where the signal is played twice at the same time, and one copy slides back and forth creating a whooshing or flanging effect.&lt;br&gt;
        As there are 2 copies of the same signal, by default each signal is given 50% mix, so that the total is not louder than the original unaffected signal.&lt;br&gt;
        &lt;br&gt;
        Flange depth is a percentage of a 10ms shift from the original signal.  Anything above 10ms is not considered flange because to the ear it begins to 'echo' so 10ms is the highest value possible.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_FLANGE
    {
        DRYMIX,      /* Volume of original signal to pass to output.  0.0 to 1.0. Default = 0.45. */
        WETMIX,      /* Volume of flange signal to pass to output.  0.0 to 1.0. Default = 0.55. */
        DEPTH,       /* Flange depth.  0.01 to 1.0.  Default = 1.0. */
        RATE         /* Flange speed in hz.  0.0 to 20.0.  Default = 0.1. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_DISTORTION filter.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_DISTORTION
    {
        LEVEL    /* Distortion value.  0.0 to 1.0.  Default = 0.5. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_NORMALIZE filter.

        [REMARKS]
        Normalize amplifies the sound based on the maximum peaks within the signal.&lt;br&gt;
        For example if the maximum peaks in the signal were 50% of the bandwidth, it would scale the whole sound by 2.&lt;br&gt;
        The lower threshold value makes the normalizer ignores peaks below a certain point, to avoid over-amplification if a loud signal suddenly came in, and also to avoid amplifying to maximum things like background hiss.&lt;br&gt;
        &lt;br&gt;
        Because FMOD is a realtime audio processor, it doesn't have the luxury of knowing the peak for the whole sound (ie it can't see into the future), so it has to process data as it comes in.&lt;br&gt;
        To avoid very sudden changes in volume level based on small samples of new data, fmod fades towards the desired amplification which makes for smooth gain control.  The fadetime parameter can control this.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_NORMALIZE
    {
        FADETIME,    /* Time to ramp the silence to full in ms.  0.0 to 20000.0. Default = 5000.0. */
        THRESHHOLD,  /* Lower volume range threshold to ignore.  0.0 to 1.0.  Default = 0.1.  Raise higher to stop amplification of very quiet signals. */
        MAXAMP       /* Maximum amplification allowed.  1.0 to 100000.0.  Default = 20.0.  1.0 = no amplifaction, higher values allow more boost. */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_PARAMEQ filter.

        [REMARKS]
        Parametric EQ is a bandpass filter that attenuates or amplifies a selected frequency and its neighbouring frequencies.&lt;br&gt;
        &lt;br&gt;
        To create a multi-band EQ create multiple FMOD_DSP_TYPE_PARAMEQ units and set each unit to different frequencies, for example 1000hz, 2000hz, 4000hz, 8000hz, 16000hz with a range of 1 octave each.&lt;br&gt;
        &lt;br&gt;
        When a frequency has its gain set to 1.0, the sound will be unaffected and represents the original signal exactly.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_PARAMEQ
    {
        CENTER,     /* Frequency center.  20.0 to 22000.0.  Default = 8000.0. */
        BANDWIDTH,  /* Octave range around the center frequency to filter.  0.2 to 5.0.  Default = 1.0. */
        GAIN        /* Frequency Gain.  0.05 to 3.0.  Default = 1.0.  */
    }



    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_PITCHSHIFT filter.

        [REMARKS]
        This pitch shifting unit can be used to change the pitch of a sound without speeding it up or slowing it down.&lt;br&gt;
        It can also be used for time stretching or scaling, for example if the pitch was doubled, and the frequency of the sound was halved, the pitch of the sound would sound correct but it would be twice as slow.&lt;br&gt;
        &lt;br&gt;
        &lt;b&gt;Warning!&lt;/b&gt; This filter is very computationally expensive!  Similar to a vocoder, it requires several overlapping FFT and IFFT's to produce smooth output, and can require around 440mhz for 1 stereo 48khz signal using the default settings.&lt;br&gt;
        Reducing the signal to mono will half the cpu usage, as will the overlap count.&lt;br&gt;
        Reducing this will lower audio quality, but what settings to use are largely dependant on the sound being played.  A noisy polyphonic signal will need higher overlap and fft size compared to a speaking voice for example.&lt;br&gt;
        &lt;br&gt;
        This pitch shifter is based on the pitch shifter code at http://www.dspdimension.com, written by Stephan M. Bernsee.&lt;br&gt;
        The original code is COPYRIGHT 1999-2003 Stephan M. Bernsee &lt;smb@dspdimension.com&gt;.&lt;br&gt;
        &lt;br&gt;
        '&lt;i&gt;maxchannels&lt;/i&gt;' dictates the amount of memory allocated.  By default, the maxchannels value is 0.  If FMOD is set to stereo, the pitch shift unit will allocate enough memory for 2 channels.  If it is 5.1, it will allocate enough memory for a 6 channel pitch shift, etc.&lt;br&gt;
        If the pitch shift effect is only ever applied to the global mix (ie it was added with System::addDSP), then 0 is the value to set as it will be enough to handle all speaker modes.&lt;br&gt;
        When the pitch shift is added to a channel (ie Channel::addDSP) then the channel count that comes in could be anything from 1 to 8 possibly.  It is only in this case where you might want to increase the channel count above the output's channel count.&lt;br&gt;
        If a channel pitch shift is set to a lower number than the sound's channel count that is coming in, it will not pitch shift the sound.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_PITCHSHIFT
    {
        PITCH,       /* Pitch value.  0.5 to 2.0.  Default = 1.0. 0.5 = one octave down, 2.0 = one octave up.  1.0 does not change the pitch. */
        FFTSIZE,     /* FFT window size.  256, 512, 1024, 2048, 4096.  Default = 1024.  Increase this to reduce 'smearing'.  This effect is a warbling sound similar to when an mp3 is encoded at very low bitrates. */
        OVERLAP,     /* Window overlap.  1 to 32.  Default = 4.  Increase this to reduce 'tremolo' effect.  Increasing it by a factor of 2 doubles the CPU usage. */
        MAXCHANNELS  /* Maximum channels supported.  0 to 16.  0 = same as fmod's default output polyphony, 1 = mono, 2 = stereo etc.  See remarks for more.  Default = 0.  It is suggested to leave at 0! */
    }



    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_CHORUS filter.

        [REMARKS]
        Chrous is an effect where the sound is more 'spacious' due to 1 to 3 versions of the sound being played along side the original signal but with the pitch of each copy modulating on a sine wave.&lt;br&gt;
        This is a highly configurable chorus unit.  It supports 3 taps, small and large delay times and also feedback.&lt;br&gt;
        This unit also could be used to do a simple echo, or a flange effect. 

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3, Wii

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_CHORUS
    {
        DRYMIX,   /* Volume of original signal to pass to output.  0.0 to 1.0. Default = 0.5. */
        WETMIX1,  /* Volume of 1st chorus tap.  0.0 to 1.0.  Default = 0.5. */
        WETMIX2,  /* Volume of 2nd chorus tap. This tap is 90 degrees out of phase of the first tap.  0.0 to 1.0.  Default = 0.5. */
        WETMIX3,  /* Volume of 3rd chorus tap. This tap is 90 degrees out of phase of the second tap.  0.0 to 1.0.  Default = 0.5. */
        DELAY,    /* Chorus delay in ms.  0.1 to 100.0.  Default = 40.0 ms. */
        RATE,     /* Chorus modulation rate in hz.  0.0 to 20.0.  Default = 0.8 hz. */
        DEPTH,    /* Chorus modulation depth.  0.0 to 1.0.  Default = 0.03. */
        FEEDBACK  /* Chorus feedback.  Controls how much of the wet signal gets fed back into the chorus buffer.  0.0 to 1.0.  Default = 0.0. */
    }



    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_REVERB filter.

        [REMARKS]

        [PLATFORMS]
        Win32, Win64, Linux, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_REVERB
    {
        ROOMSIZE, /* Roomsize. 0.0 to 1.0.  Default = 0.5 */
        DAMP,     /* Damp.     0.0 to 1.0.  Default = 0.5 */
        WETMIX,   /* Wet mix.  0.0 to 1.0.  Default = 0.33 */
        DRYMIX,   /* Dry mix.  0.0 to 1.0.  Default = 0.0 */
        WIDTH,    /* Width.    0.0 to 1.0.  Default = 1.0 */
        MODE      /* Mode.     0 (normal), 1 (freeze).  Default = 0 */
    }

    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_ITECHO filter.&lt;br&gt;
        This is effectively a software based echo filter that emulates the DirectX DMO echo effect.  Impulse tracker files can support this, and FMOD will produce the effect on ANY platform, not just those that support DirectX effects!&lt;br&gt;

        [REMARKS]
        Note.  Every time the delay is changed, the plugin re-allocates the echo buffer.  This means the echo will dissapear at that time while it refills its new buffer.&lt;br&gt;
        Larger echo delays result in larger amounts of memory allocated.&lt;br&gt;
        &lt;br&gt;
        For stereo signals only!  This will not work on mono or multichannel signals.  This is fine for .IT format purposes, and also if you use System::addDSP with a standard stereo output.&lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable

        [SEE_ALSO]      
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
        System::addDSP
    ]
    */
    public enum DSP_ITECHO
    {
        WETDRYMIX,      /* Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0.0 through 100.0 (all wet). The default value is 50. */
        FEEDBACK,       /* Percentage of output fed back into input, in the range from 0.0 through 100.0. The default value is 50. */
        LEFTDELAY,      /* Delay for left channel, in milliseconds, in the range from 1.0 through 2000.0. The default value is 500 ms. */
        RIGHTDELAY,     /* Delay for right channel, in milliseconds, in the range from 1.0 through 2000.0. The default value is 500 ms. */
        PANDELAY        /* Value that specifies whether to swap left and right delays with each successive echo. The default value is zero, meaning no swap. Possible values are defined as 0.0 (equivalent to FALSE) and 1.0 (equivalent to TRUE). */
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_COMPRESSOR unit.&lt;br&gt;
        This is a simple linked multichannel software limiter that is uniform across the whole spectrum.&lt;br&gt;

        [REMARKS]
        The parameters are as follows:
        Threshold: [-60dB to 0dB, default 0dB]
        Attack Time: [10ms to 200ms, default 50ms]
        Release Time: [20ms to 1000ms, default 50ms]
        Gain Make Up: [0dB to +30dB, default 0dB]
        &lt;br&gt;
        The limiter is not guaranteed to catch every peak above the threshold level,
        because it cannot apply gain reduction instantaneously - the time delay is
        determined by the attack time. However setting the attack time too short will
        distort the sound, so it is a compromise. High level peaks can be avoided by
        using a short attack time - but not too short, and setting the threshold a few
        decibels below the critical level.
        &lt;br&gt;

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3

        [SEE_ALSO]      
        DSP::SetParameter
        DSP::GetParameter
        FMOD_DSP_TYPE
        System::addDSP
    ]
    */
    public enum DSP_COMPRESSOR
    {
        THRESHOLD,  /* Threshold level (dB)in the range from -60 through 0. The default value is 50. */ 
        ATTACK,     /* Gain reduction attack time (milliseconds), in the range from 10 through 200. The default value is 50. */    
        RELEASE,    /* Gain reduction release time (milliseconds), in the range from 20 through 1000. The default value is 50. */     
        GAINMAKEUP /* Make-up gain applied after limiting, in the range from 0.0 through 100.0. The default value is 50. */   
    }


    /*
    [ENUM]
    [  
        [DESCRIPTION]   
        Parameter types for the FMOD_DSP_TYPE_SFXREVERB unit.&lt;br&gt;
    
        [REMARKS]
        This is a high quality I3DL2 based reverb which improves greatly on FMOD_DSP_REVERB.&lt;br&gt;
        On top of the I3DL2 property set, "Dry Level" is also included to allow the dry mix to be changed.&lt;br&gt;
        &lt;br&gt;
        Currently FMOD_DSP_SFXREVERB_REFLECTIONSLEVEL, FMOD_DSP_SFXREVERB_REFLECTIONSDELAY and FMOD_DSP_SFXREVERB_REVERBDELAY are not enabled but will come in future versions.&lt;br&gt;
        &lt;br&gt;
        These properties can be set with presets in FMOD_REVERB_PRESETS.

        [PLATFORMS]
        Win32, Win64, Linux, Linux64, Macintosh, Xbox, Xbox360, PlayStation 2, GameCube, PlayStation Portable, PlayStation 3

        [SEE_ALSO]      
        DSP::SetParameter
        DSP::GetParameter
        FMOD_DSP_TYPE
        System::addDSP
        FMOD_REVERB_PRESETS
    ]
    */
    public enum DSP_SFXREVERB
    {
        DRYLEVEL,            /* Dry Level      : Mix level of dry signal in output in mB.  Ranges from -10000.0 to 0.0.  Default is 0.0. */
        ROOM,                /* Room           : Room effect level at low frequencies in mB.  Ranges from -10000.0 to 0.0.  Default is 0.0. */
        ROOMHF,              /* Room HF        : Room effect high-frequency level re. low frequency level in mB.  Ranges from -10000.0 to 0.0.  Default is 0.0. */
        ROOMROLLOFFFACTOR,   /* Room Rolloff   : Like DS3D flRolloffFactor but for room effect.  Ranges from 0.0 to 10.0. Default is 10.0 */
        DECAYTIME,           /* Decay Time     : Reverberation decay time at low-frequencies in seconds.  Ranges from 0.1 to 20.0. Default is 1.0. */
        DECAYHFRATIO,        /* Decay HF Ratio : High-frequency to low-frequency decay time ratio.  Ranges from 0.1 to 2.0. Default is 0.5. */
        REFLECTIONSLEVEL,    /* Reflections    : Early reflections level relative to room effect in mB.  Ranges from -10000.0 to 1000.0.  Default is -10000.0. */
        REFLECTIONSDELAY,    /* Reflect Delay  : Delay time of first reflection in seconds.  Ranges from 0.0 to 0.3.  Default is 0.02. */
        REVERBLEVEL,         /* Reverb         : Late reverberation level relative to room effect in mB.  Ranges from -10000.0 to 2000.0.  Default is 0.0. */
        REVERBDELAY,         /* Reverb Delay   : Late reverberation delay time relative to first reflection in seconds.  Ranges from 0.0 to 0.1.  Default is 0.04. */
        DIFFUSION,           /* Diffusion      : Reverberation diffusion (echo density) in percent.  Ranges from 0.0 to 100.0.  Default is 100.0. */
        DENSITY,             /* Density        : Reverberation density (modal density) in percent.  Ranges from 0.0 to 100.0.  Default is 100.0. */
        HFREFERENCE          /* HF Reference   : Reference high frequency in Hz.  Ranges from 20.0 to 20000.0. Default is 5000.0. */
    }
/*$ preserve start $*/
}
/*$ preserve end $*/


/* NEXT FILE */
/* ============================================================================================= = */
/* FMOD Ex - Error string header file. Copyright (c), Firelight Technologies Pty, Ltd. 2004-2008.  */
/*                                                                                                 */
/* Use this header if you want to store or display a string version / english explanation of       */
/* the FMOD error codes.                                                                           */
/*                                                                                                 */
/* =============================================================================================== */

namespace FMOD
{
    public class Error
    {
        public static string String(FMOD.RESULT errcode)
        {
            switch (errcode)
            {
                case FMOD.RESULT.OK:                         return "No errors.";
                case FMOD.RESULT.ERR_ALREADYLOCKED:          return "Tried to call lock a second time before unlock was called. ";
                case FMOD.RESULT.ERR_BADCOMMAND:             return "Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock on a streaming sound). ";
                case FMOD.RESULT.ERR_CDDA_DRIVERS:           return "Neither NTSCSI nor ASPI could be initialised. ";
                case FMOD.RESULT.ERR_CDDA_INIT:              return "An error occurred while initialising the CDDA subsystem. ";
                case FMOD.RESULT.ERR_CDDA_INVALID_DEVICE:    return "Couldn't find the specified device. ";
                case FMOD.RESULT.ERR_CDDA_NOAUDIO:           return "No audio tracks on the specified disc. ";
                case FMOD.RESULT.ERR_CDDA_NODEVICES:         return "No CD/DVD devices were found. ";
                case FMOD.RESULT.ERR_CDDA_NODISC:            return "No disc present in the specified drive. ";
                case FMOD.RESULT.ERR_CDDA_READ:              return "A CDDA read error occurred. ";
                case FMOD.RESULT.ERR_CHANNEL_ALLOC:          return "Error trying to allocate a channel. ";
                case FMOD.RESULT.ERR_CHANNEL_STOLEN:         return "The specified channel has been reused to play another sound. ";
                case FMOD.RESULT.ERR_COM:                    return "A Win32 COM related error occured. COM failed to initialize or a QueryInterface failed meaning a Windows codec or driver was not installed properly. ";
                case FMOD.RESULT.ERR_DMA:                    return "DMA Failure.  See debug output for more information. ";
                case FMOD.RESULT.ERR_DSP_CONNECTION:         return "DSP connection error.  Connection possibly caused a cyclic dependancy. ";
                case FMOD.RESULT.ERR_DSP_FORMAT:             return "DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format. ";
                case FMOD.RESULT.ERR_DSP_NOTFOUND:           return "DSP connection error.  Couldn't find the DSP unit specified. ";
                case FMOD.RESULT.ERR_DSP_RUNNING:            return "DSP error.  Cannot perform this operation while the network is in the middle of running.  This will most likely happen if a connection or disconnection is attempted in a DSP callback. ";
                case FMOD.RESULT.ERR_DSP_TOOMANYCONNECTIONS: return "DSP connection error.  The unit being connected to or disconnected should only have 1 input or output. ";
                case FMOD.RESULT.ERR_FILE_BAD:               return "Error loading file. ";
                case FMOD.RESULT.ERR_FILE_COULDNOTSEEK:      return "Couldn't perform seek operation.  This is a limitation of the medium (ie netstreams) or the file format. ";
                case FMOD.RESULT.ERR_FILE_DISKEJECTED:       return "Media was ejected while reading. ";
                case FMOD.RESULT.ERR_FILE_EOF:               return "End of file unexpectedly reached while trying to read essential data (truncated data?). ";
                case FMOD.RESULT.ERR_FILE_NOTFOUND:          return "File not found. ";
                case FMOD.RESULT.ERR_FILE_UNWANTED:          return "Unwanted file access occured. ";
                case FMOD.RESULT.ERR_FORMAT:                 return "Unsupported file or audio format. ";
                case FMOD.RESULT.ERR_HTTP:                   return "A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere. ";
                case FMOD.RESULT.ERR_HTTP_ACCESS:            return "The specified resource requires authentication or is forbidden. ";
                case FMOD.RESULT.ERR_HTTP_PROXY_AUTH:        return "Proxy authentication is required to access the specified resource. ";
                case FMOD.RESULT.ERR_HTTP_SERVER_ERROR:      return "A HTTP server error occurred. ";
                case FMOD.RESULT.ERR_HTTP_TIMEOUT:           return "The HTTP request timed out. ";
                case FMOD.RESULT.ERR_INITIALIZATION:         return "FMOD was not initialized correctly to support this function. ";
                case FMOD.RESULT.ERR_INITIALIZED:            return "Cannot call this command after System::init. ";
                case FMOD.RESULT.ERR_INTERNAL:               return "An error occured that wasn't supposed to.  Contact support. ";
                case FMOD.RESULT.ERR_INVALID_ADDRESS:        return "On Xbox 360, this memory address passed to FMOD must be physical, (ie allocated with XPhysicalAlloc.) ";
                case FMOD.RESULT.ERR_INVALID_FLOAT:          return "Value passed in was a NaN, Inf or denormalized float. ";
                case FMOD.RESULT.ERR_INVALID_HANDLE:         return "An invalid object handle was used. ";
                case FMOD.RESULT.ERR_INVALID_PARAM:          return "An invalid parameter was passed to this function. ";
                case FMOD.RESULT.ERR_INVALID_SPEAKER:        return "An invalid speaker was passed to this function based on the current speaker mode. ";
                case FMOD.RESULT.ERR_INVALID_SYNCPOINT:      return "The syncpoint did not come from this sound handle.";
                case FMOD.RESULT.ERR_INVALID_VECTOR:         return "The vectors passed in are not unit length, or perpendicular. ";
                case FMOD.RESULT.ERR_IRX:                    return "PS2 only.  fmodex.irx failed to initialize.  This is most likely because you forgot to load it. ";
                case FMOD.RESULT.ERR_MAXAUDIBLE:             return "Reached maximum audible playback count for this sound's soundgroup. ";
                case FMOD.RESULT.ERR_MEMORY:                 return "Not enough memory or resources. ";
                case FMOD.RESULT.ERR_MEMORY_CANTPOINT:       return "Can't use FMOD_OPENMEMORY_POINT on non PCM source data, or non mp3/xma/adpcm data if FMOD_CREATECOMPRESSEDSAMPLE was used. ";
                case FMOD.RESULT.ERR_MEMORY_IOP:             return "PS2 only.  Not enough memory or resources on PlayStation 2 IOP ram. ";
                case FMOD.RESULT.ERR_MEMORY_SRAM:            return "Not enough memory or resources on console sound ram. ";
                case FMOD.RESULT.ERR_NEEDS2D:                return "Tried to call a command on a 3d sound when the command was meant for 2d sound. ";
                case FMOD.RESULT.ERR_NEEDS3D:                return "Tried to call a command on a 2d sound when the command was meant for 3d sound. ";
                case FMOD.RESULT.ERR_NEEDSHARDWARE:          return "Tried to use a feature that requires hardware support.  (ie trying to play a VAG compressed sound in software on PS2). ";
                case FMOD.RESULT.ERR_NEEDSSOFTWARE:          return "Tried to use a feature that requires the software engine.  Software engine has either been turned off, or command was executed on a hardware channel which does not support this feature. ";
                case FMOD.RESULT.ERR_NET_CONNECT:            return "Couldn't connect to the specified host. ";
                case FMOD.RESULT.ERR_NET_SOCKET_ERROR:       return "A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere. ";
                case FMOD.RESULT.ERR_NET_URL:                return "The specified URL couldn't be resolved. ";
                case FMOD.RESULT.ERR_NET_WOULD_BLOCK:        return "Operation on a non-blocking socket could not complete immediately. ";
                case FMOD.RESULT.ERR_NOTREADY:               return "Operation could not be performed because specified sound is not ready. ";
                case FMOD.RESULT.ERR_OUTPUT_ALLOCATED:       return "Error initializing output device, but more specifically, the output device is already in use and cannot be reused. ";
                case FMOD.RESULT.ERR_OUTPUT_CREATEBUFFER:    return "Error creating hardware sound buffer. ";
                case FMOD.RESULT.ERR_OUTPUT_DRIVERCALL:      return "A call to a standard soundcard driver failed, which could possibly mean a bug in the driver or resources were missing or exhausted. ";
                case FMOD.RESULT.ERR_OUTPUT_ENUMERATION:     return "Error enumerating the available driver list. List may be inconsistent due to a recent device addition or removal.";
                case FMOD.RESULT.ERR_OUTPUT_FORMAT:          return "Soundcard does not support the minimum features needed for this soundsystem (16bit stereo output). ";
                case FMOD.RESULT.ERR_OUTPUT_INIT:            return "Error initializing output device. ";
                case FMOD.RESULT.ERR_OUTPUT_NOHARDWARE:      return "FMOD_HARDWARE was specified but the sound card does not have the resources nescessary to play it. ";
                case FMOD.RESULT.ERR_OUTPUT_NOSOFTWARE:      return "Attempted to create a software sound but no software channels were specified in System::init. ";
                case FMOD.RESULT.ERR_PAN:                    return "Panning only works with mono or stereo sound sources. ";
                case FMOD.RESULT.ERR_PLUGIN:                 return "An unspecified error has been returned from a 3rd party plugin. ";
                case FMOD.RESULT.ERR_PLUGIN_INSTANCES:       return "The number of allowed instances of a plugin has been exceeded ";
                case FMOD.RESULT.ERR_PLUGIN_MISSING:         return "A requested output, dsp unit type or codec was not available. ";
                case FMOD.RESULT.ERR_PLUGIN_RESOURCE:        return "A resource that the plugin requires cannot be found. (ie the DLS file for MIDI playback) ";
                case FMOD.RESULT.ERR_RECORD:                 return "An error occured trying to initialize the recording device. ";
                case FMOD.RESULT.ERR_REVERB_INSTANCE:        return "Specified Instance in FMOD_REVERB_PROPERTIES couldn't be set. Most likely because another application has locked the EAX4 FX slot. ";
                case FMOD.RESULT.ERR_SUBSOUND_ALLOCATED:     return "This subsound is already being used by another sound, you cannot have more than one parent to a sound.  Null out the other parent's entry first. ";
                case FMOD.RESULT.ERR_SUBSOUND_CANTMOVE:      return "Shared subsounds cannot be replaced or moved from their parent stream, such as when the parent stream is an FSB file.";
                case FMOD.RESULT.ERR_SUBSOUND_MODE:          return "The subsound's mode bits do not match with the parent sound's mode bits.  See documentation for function that it was called with.";
                case FMOD.RESULT.ERR_SUBSOUNDS:              return "The error occured because the sound referenced contains subsounds.  (ie you cannot play the parent sound as a static sample, only its subsounds.) ";
                case FMOD.RESULT.ERR_TAGNOTFOUND:            return "The specified tag could not be found or there are no tags. ";
                case FMOD.RESULT.ERR_TOOMANYCHANNELS:        return "The sound created exceeds the allowable input channel count.  This can be increased using the maxinputchannels parameter in System::setSoftwareFormat. ";
                case FMOD.RESULT.ERR_UNIMPLEMENTED:          return "Something in FMOD hasn't been implemented when it should be! contact support! ";
                case FMOD.RESULT.ERR_UNINITIALIZED:          return "This command failed because System::init or System::setDriver was not called. ";
                case FMOD.RESULT.ERR_UNSUPPORTED:            return "A command issued was not supported by this object.  Possibly a plugin without certain callbacks specified. ";
                case FMOD.RESULT.ERR_UPDATE:                 return "An error caused by System::update occured. ";
                case FMOD.RESULT.ERR_VERSION:                return "The version number of this file format is not supported. ";

                case FMOD.RESULT.ERR_EVENT_FAILED:           return "An Event failed to be retrieved, most likely due to 'just fail' being specified as the max playbacks behavior. ";
                case FMOD.RESULT.ERR_EVENT_INFOONLY:         return "Can't execute this command on an EVENT_INFOONLY event. ";
                case FMOD.RESULT.ERR_EVENT_INTERNAL:         return "An error occured that wasn't supposed to.  See debug log for reason. ";
                case FMOD.RESULT.ERR_EVENT_MAXSTREAMS:       return "Event failed because 'Max streams' was hit when FMOD_INIT_FAIL_ON_MAXSTREAMS was specified. ";
                case FMOD.RESULT.ERR_EVENT_MISMATCH:         return "FSB mis-matches the FEV it was compiled with. ";
                case FMOD.RESULT.ERR_EVENT_NAMECONFLICT:     return "A category with the same name already exists. ";
                case FMOD.RESULT.ERR_EVENT_NOTFOUND:         return "The requested event, event group, event category or event property could not be found. ";
                default :                                    return "Unknown error.";
            }
        }
    }
}
</Text>
  </SourceCode>
  <SourceCode Name="fmodbase.cs" IsCustomObject="true" DependsOn="fmod.cs">
    <Text>// File version 3 (initially distributed with version 2.1 beta 5)
// Last change: Update setCallback interface to new FMOD prototype.

using System;
using System.ComponentModel;

namespace CustomObjects
{
   public enum SoundReplay
   {
      Continue,
      StartNew,
      Restart,
   }

   abstract public class FMODBase
   {
      private static FMOD.System system  = null;
      private FMOD.Channel channel = null;
      private FMOD.Sound sound  = null;
      private static System.Collections.ArrayList soundList = new System.Collections.ArrayList();
      // Must keep a reference to the callback to prevent
      // Garbage collector from causing NullReferenceException
      private static FMOD.CHANNEL_CALLBACK updateCallback = null;

      public FMODBase()
      {
         InitFMOD();
      }

      private static void InitFMOD()
      {
         if (system == null)
         {
            ERRCHECK(FMOD.Factory.System_Create(ref system));
            ERRCHECK(system.init(32, FMOD.INITFLAG.NORMAL, (IntPtr)null));
            Project.GameWindow.OnFrameStart += new GameForm.SimpleNotification(OnFrameStart);
            updateCallback = (FMOD.CHANNEL_CALLBACK)Delegate.CreateDelegate(typeof(FMOD.CHANNEL_CALLBACK), typeof(FMODBase), "Channel_Callback");
         }
      }

      public static void OnFrameStart()
      {
         ERRCHECK(system.update());
      }

      [Description("Play an FMOD sound effect")]
      public static void PlaySound([System.ComponentModel.Editor("CustomObject", "UITypeEditor")] CustomObjects.FMODBase Sound, SoundReplay ReplayOption)
      {
         LoadSound(Sound);
         if (Sound.isPlaying)
         {
            switch(ReplayOption)
            {
               case SoundReplay.Continue:
                  return;
               case SoundReplay.StartNew:
                  break;
               case SoundReplay.Restart:
                  Sound.Stop();
                  break;
            }
         }
         ERRCHECK(system.playSound(FMOD.CHANNELINDEX.FREE, Sound.sound, false, ref Sound.channel));
         ERRCHECK(Sound.channel.setCallback(updateCallback));
         ERRCHECK(Sound.channel.setVolume(Sound.Volume));
      }

      [Description("Pause or resume an FMOD sound effect")]
      public static void PauseSound([System.ComponentModel.Editor("CustomObject", "UITypeEditor")] CustomObjects.FMODBase Sound, bool Pause)
      {
         ERRCHECK(Sound.channel.setPaused(Pause));
      }

      private static FMOD.RESULT Channel_Callback(IntPtr channelraw, FMOD.CHANNEL_CALLBACKTYPE type, IntPtr commanddata1, IntPtr commanddata2)
      {
         try
         {
            for(int i=0; i&lt;soundList.Count; i++)
            {
               FMODBase snd = (FMODBase)soundList[i];
               if ((snd.channel != null) &amp;&amp; (snd.channel.getRaw() == channelraw) &amp;&amp; (type == FMOD.CHANNEL_CALLBACKTYPE.END))
                  snd.channel = null;
            }
            return FMOD.RESULT.OK;
         }
         catch(System.Exception ex)
         {
            return FMOD.RESULT.ERR_UPDATE;
         }
      }

      public bool isPlaying
      {
         get
         {
            if (channel != null)
            {
               bool result = false;
               ERRCHECK(channel.isPlaying(ref result));
               return result;
            }
            return false;
         }
      }

      [Description("Stop a playing FMOD sound effect")]
      public static void StopSound([System.ComponentModel.Editor("CustomObject", "UITypeEditor")] CustomObjects.FMODBase Sound)
      {
         Sound.Stop();
      }

      private void Stop()
      {
         if(isPlaying)
            ERRCHECK(channel.stop());
         channel = null;
      }

      [Description("Release the memory associated with the specified FMOD object")]
      public static void UnloadSound([System.ComponentModel.Editor("CustomObject", "UITypeEditor")] CustomObjects.FMODBase Sound)
      {
         Sound.Unload();
      }

      private void Unload()
      {
         ERRCHECK(sound.release());
         sound = null;
      }

      [Description("Force the specified sound to be loaded into FMOD memory")]
      public static void LoadSound([System.ComponentModel.Editor("CustomObject", "UITypeEditor")] CustomObjects.FMODBase Sound)
      {
         Sound.Load();
      }

      private void Load()
      {
         if (sound == null)
         {
            System.IO.Stream fmodrc = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(this.GetType().Name + ".bin");
            byte[] buf = new byte[fmodrc.Length];
            fmodrc.Read(buf, 0, (int)fmodrc.Length);
            fmodrc.Close();
            FMOD.CREATESOUNDEXINFO sndinf = new FMOD.CREATESOUNDEXINFO();
            sndinf.cbsize = System.Runtime.InteropServices.Marshal.SizeOf(sndinf);
            sndinf.length = (uint)buf.Length;
            sndinf.suggestedsoundtype = SoundType;
            ERRCHECK(system.createSound(buf, FMOD.MODE.OPENMEMORY, ref sndinf, ref sound));
            soundList.Add(this);
         }
      }

      protected FMOD.SOUND_TYPE SoundType
      {
         get
         {
            return FMOD.SOUND_TYPE.UNKNOWN;
         }
      }

      // Override this member to override default volume.
      protected virtual float Volume
      {
         get
         {
            return 1.0f;
         }
      }

      private static void ERRCHECK(FMOD.RESULT result)
      {
         if (result != FMOD.RESULT.OK)
         {
            throw new ApplicationException("FMOD error! " + result + " - " + FMOD.Error.String(result));
         }
      }
   }
}</Text>
  </SourceCode>
  <SourceCode Name="Bing.cs" IsCustomObject="true" DependsOn="fmodbase.cs">
    <Text>namespace CustomObjects
{
   public class Bing : FMODBase
   {
      private static Bing m_instance = null;

      public Bing()
      {
      }

      public static Bing Value
      {
         get
         {
            if (m_instance == null)
               m_instance = new Bing();
            return m_instance;
         }
      }

      protected override float Volume
      {
         get
         {
            return 0.75f;
         }
      }
   }
}
</Text>
    <CustomObjectData>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</CustomObjectData>
  </SourceCode>
  <SourceCode Name="Ahh.cs" IsCustomObject="true" DependsOn="fmodbase.cs">
    <Text>namespace CustomObjects
{
   public class Ahh: FMODBase
   {
      private static Ahh m_instance = null;

      public Ahh()
      {
      }

      public static Ahh Value
      {
         get
         {
            if (m_instance == null)
               m_instance = new Ahh();
            return m_instance;
         }
      }

      protected override float Volume
      {
         get
         {
            return 0.75f;
         }
      }
   }
}
</Text>
    <CustomObjectData>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QikppdZaCCGEUEopJaXWYuwghFBCKaWk1FqMIYQQSiklpdRaizGEEEIppaTUUmsxllJKSSml1FprMdZSSikppdRSa7HFmFJKqbXWWosxxlpTSim11lprscVYa2qttdZijDHGWmtNrbXWWowx1lhrrQUAABw4AAAEGEEnGVUWYaMJFx6AQkNWBABRAACAMYgxxBiCjknIJEQOMigZlAZCSKmjlFEqJZYaM0olphJrBKGjFFLKKJUaS6sZpRJjiaUAALADBwCwAwuh0JCVAEAeAACBkFKMOeccQogxxpxzDiHFGGPOOacYY8w555xTjDHmnHPOMcaccw5CCBljzjkHIYTOOecghBBC55xzEEIIoXPOOQghhNA55xyEEEIoAACowAEAIMBGkc0JRoIKDVkJAKQCAADGMOaccxBKaZRyDkIIpbTUKOUchBBKSS1zDkIppbQWW+YchFJKSa21DkIpKaXUWowdhFJSSqnFGDsIpaTUWoy1dhBKSam1GGsNpaQWW6y11hpKSa3FGGuttaTUWoy15pxzSam1GGutNecCAMATHACACmxYHeGkaCyw0JCVAEAGAABhDEIIIYQQQgghhJRCCCklAABgwAEAIMCEMlBoyEoAIBUAADCGMcacg1BKoxSEEEIoJaVGKQchhFBSS5mDUkpJJbUWMwillFJKajFm0ElJKbUWY80glJJSajHG2EEoKbXWYoyxg1BSSq3FWGsopaUWY6wxxlBKSq3FGmONJaUWa6251lpLSq3FGGutuRYAgNDgAAB2YMPqCCdFY4GFhqwEAPIAABCElGKMMcaQUowxxphzSCmlGGPMOaUYY44555xijDHGnHOOMcaYc845xxhjzjnnnGOMOeecc84xxpxzzjnnmHPOOeecc8w555xzzjkBAEAFDgAAATaKbE4wElRoyEoAIBwAAECIMecYc05CSo1SzkkIHYRSWm0UcxBK6CCU1lLmnJRSQiglxdgy5yClEkIqLaXaQUglpVJSiq22DkJqKZXSUmutZs5BKKWklmKsLXMQQikppdZqrZ2EklJKtbVYawwhlJRSa622GmsppaWWaqyx1lhDKaml2GKstcZaYmwttRprrK3GklJLrdVaY621FgBg8uAAAJVg4wwrSWeFo8GFhqwEAHIDAAiEGHPOOQgllBBCKaVESjHmHIQQSiillFJSiZRizDkHoZRSSimllJIx5hx0EEoopZRSUkklY8w5ByGUUEoppZRSSucchBBKKKWUUkoqJZXOOQchhFJKKaWUklIpHYQQQiillFJSSSWVVDoIIYRSSimllFJSKqWEEkIpJZVSSimlpJRSCiGUUEoppaSSSkoplRJKKKWUVEopJZVUUikplFJKKaWUVEpKJaWUUgillFJSKamUVEpKKaVQSimllFRSSSWllFJJpZRSSiklpZRSSimVlEoppaRSSioppVRaSqmUUkpJpZSUWkoppZRSKqWkklJKKaWUUkoppVRKSSWVklJKKaWUUkqllFJKSamkVFIqKaWSUgEAQAcOAAABRlRaiJ1mXHkEjihkmIAKDVkJAIQDAABSSimllFJKiYyUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSGimllFJKKaVUCkkpJYQQQgghQgJAujIcAAACrElXL1JdxuhgdOnKLmh0eJGjQwAKAJCukdWEJTRkJQCQFgAAWGmllZZaa6211iIEpaXUWmuttdZaayWEFFJqqbXWWmuttc5JCi211lprrbXWWugktdRSa6211lprrYOUSmuttdZaa621FkpqqaXWWmuttdZaCyG11lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaaymllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSihyEjkJKKaWUUkoRMs45J6GUlFJKKaXICABAjHAAAAiwhNhVuZmkXj0bEsPkJH2K4WoM3wIAMWGMCQ1ZBQDEAAAAhBjGmGOMMeecY84555xzjkHoIITOOeecc845Z62kAgAAExwAAAKsYFdmadVGcVMnedEHgU/oiM3IkEupmMmJoEdqqMVKsEMruMELwEJDVgIAZAAAEJNSUopFWQgp5qAl5SFjFIOYlIeMQcpZUBpCxiBmxXiMKYSUFCNC6BRSUIyKMXaMQS8yGJ9CCMHoYoyOsRYjAAAAQQCAgJAAAAMEBTMAwOAAYeRAoCOAwKENADAQ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</CustomObjectData>
  </SourceCode>
  <SourceCode Name="Pickup.cs" IsCustomObject="true" DependsOn="fmodbase.cs">
    <Text>namespace CustomObjects
{
   public class Pickup : FMODBase
   {
      private static Pickup m_instance = null;

      public Pickup()
      {
      }

      public static Pickup Value
      {
         get
         {
            if (m_instance == null)
               m_instance = new Pickup();
            return m_instance;
         }
      }

      protected override float Volume
      {
         get
         {
            return 0.75f;
         }
      }
   }
}
</Text>
    <CustomObjectData>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QikppdZaCCGEUEopJaXWYuwghFBCKaWk1FqMIYQQSiklpdRaizGEEEIppaTUUmsxllJKSSml1FprMdZSSikppdRSa7HFmFJKqbXWWosxxlpTSim11lprscVYa2qttdZijDHGWmtNrbXWWowx1lhrrQUAABw4AAAEGEEnGVUWYaMJFx6AQkNWBABRAACAMYgxxBiCjknIJEQOMigZlAZCSKmjlFEqJZYaM0olphJrBKGjFFLKKJUaS6sZpRJjiaUAALADBwCwAwuh0JCVAEAeAACBkFKMOeccQogxxpxzDiHFGGPOOacYY8w555xTjDHmnHPOMcaccw5CCBljzjkHIYTOOecghBBC55xzEEIIoXPOOQghhNA55xyEEEIoAACowAEAIMBGkc0JRoIKDVkJAKQCAADGMOaccxBKaZRyDkIIpbTUKOUchBBKSS1zDkIppbQWW+YchFJKSa21DkIpKaXUWowdhFJSSqnFGDsIpaTUWoy1dhBKSam1GGsNpaQWW6y11hpKSa3FGGuttaTUWoy15pxzSam1GGutNecCAMATHACACmxYHeGkaCyw0JCVAEAGAABhDEIIIYQQQgghhJRCCCklAABgwAEAIMCEMlBoyEoAIBUAADCGMcacg1BKoxSEEEIoJaVGKQchhFBSS5mDUkpJJbUWMwillFJKajFm0ElJKbUWY80glJJSajHG2EEoKbXWYoyxg1BSSq3FWGsopaUWY6wxxlBKSq3FGmONJaUWa6251lpLSq3FGGutuRYAgNDgAAB2YMPqCCdFY4GFhqwEAPIAABCElGKMMcaQUowxxphzSCmlGGPMOaUYY44555xijDHGnHOOMcaYc845xxhjzjnnnGOMOeecc84xxpxzzjnnmHPOOeecc8w555xzzjkBAEAFDgAAATaKbE4wElRoyEoAIBwAAECIMecYc05CSo1SzkkIHYRSWm0UcxBK6CCU1lLmnJRSQiglxdgy5yClEkIqLaXaQUglpVJSiq22DkJqKZXSUmutZs5BKKWklmKsLXMQQikppdZqrZ2EklJKtbVYawwhlJRSa622GmsppaWWaqyx1lhDKaml2GKstcZaYmwttRprrK3GklJLrdVaY621FgBg8uAAAJVg4wwrSWeFo8GFhqwEAHIDAAiEGHPOOQgllBBCKaVESjHmHIQQSiillFJSiZRizDkHoZRSSimllJIx5hx0EEoopZRSUkklY8w5ByGUUEoppZRSSucchBBKKKWUUkoqJZXOOQchhFJKKaWUklIpHYQQQiillFJSSSWVVDoIIYRSSimllFJSKqWEEkIpJZVSSimlpJRSCiGUUEoppaSSSkoplRJKKKWUVEopJZVUUikplFJKKaWUVEpKJaWUUgillFJSKamUVEpKKaVQSimllFRSSSWllFJJpZRSSiklpZRSSimVlEoppaRSSioppVRaSqmUUkpJpZSUWkoppZRSKqWkklJKKaWUUkoppVRKSSWVklJKKaWUUkqllFJKSamkVFIqKaWSUgEAQAcOAAABRlRaiJ1mXHkEjihkmIAKDVkJAIQDAABSSimllFJKiYyUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSGimllFJKKaVUCkkpJYQQQgghQgJAujIcAAACrElXL1JdxuhgdOnKLmh0eJGjQwAKAJCukdWEJTRkJQCQFgAAWGmllZZaa6211iIEpaXUWmuttdZaayWEFFJqqbXWWmuttc5JCi211lprrbXWWugktdRSa6211lprrYOUSmuttdZaa621FkpqqaXWWmuttdZaCyG11lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaaymllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSihyEjkJKKaWUUkoRMs45J6GUlFJKKaXICABAjHAAAAiwhNhVuZmkXj0bEsPkJH2K4WoM3wIAMWGMCQ1ZBQDEAAAAhBjGmGOMMeecY84555xzjkHoIITOOeecc845Z62kAgAAExwAAAKsYFdmadVGcVMnedEHgU/oiM3IkEupmMmJoEdqqMVKsEMruMELwEJDVgIAZAAAEJNSUopFWQgp5qAl5SFjFIOYlIeMQcpZUBpCxiBmxXiMKYSUFCNC6BRSUIyKMXaMQS8yGJ9CCMHoYoyOsRYjAAAAQQCAgJAAAAMEBTMAwOAAYeRAoCOAwKENADAQ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</CustomObjectData>
  </SourceCode>
  <SourceCode Name="Explode.cs" IsCustomObject="true" DependsOn="fmodbase.cs">
    <Text>namespace CustomObjects
{
   public class Explode : FMODBase
   {
      private static Explode m_instance = null;

      public Explode()
      {
      }

      public static Explode Value
      {
         get
         {
            if (m_instance == null)
               m_instance = new Explode();
            return m_instance;
         }
      }

      protected override float Volume
      {
         get
         {
            return 0.35f;
         }
      }
   }
}
</Text>
    <CustomObjectData>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</CustomObjectData>
  </SourceCode>
  <SourceCode Name="PlanCustom.cs" IsCustomObject="true" DependsOn="">
    <Text>using System;
using System.ComponentModel;

public abstract partial class PlanBase
{
   /// &lt;summary&gt;
   /// Determines if the specified sprite's specified input was pressed before the.
   /// current inputs were acquired.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose inputs will be examined&lt;/param&gt;
   /// &lt;param name="Input"&gt;Specifies which input will be examined&lt;/param&gt;
   /// &lt;returns&gt;True if the input was pressed before the current inputs were acquired,
   /// false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;The &lt;see cref="SpriteBase.WasInputPressed"/&gt; function for sprite definitions is
   /// more commonly used, but this allows you to test a specific sprite's inputs on a specific
   /// layer.&lt;/remarks&gt;
   [Description("Determine if the specified sprite's specified input was pressed before the current inputs were acquired.")]
   public virtual bool WasInputPressed(SpriteBase Sprite, SpriteBase.InputBits Input)
   {
      return Sprite.WasInputPressed(Input);
   }

   [Description("Move the inventory selector layer into view (visible = true) or out (visible = false)")]
   public virtual void MoveSelectorLayer(bool visible)
   {
      if (visible) {
         if (ParentLayer.CurrentPosition.X &lt; 80)
         {
            ParentLayer.CurrentPosition = new System.Drawing.Point(ParentLayer.CurrentPosition.X + 32, ParentLayer.CurrentPosition.Y);
         }
      } else if (ParentLayer.CurrentPosition.X &gt; -512) {
         ParentLayer.CurrentPosition = new System.Drawing.Point(ParentLayer.CurrentPosition.X - 32, ParentLayer.CurrentPosition.Y);
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="OpenTK.dll" IsCustomObject="true">
    <Text>/*
   Because this is a binary file, this text only
   serves as a comment and will not be compiled.
*/</Text>
  </SourceCode>
  <SourceCode Name="OpenTK.GLControl.dll" IsCustomObject="true">
    <Text>/*
   Because this is a binary file, this text only
   serves as a comment and will not be compiled.
*/</Text>
  </SourceCode>
  <SourceCode Name="SpriteCustom.js" IsCustomObject="true" DependsOn="">
    <Text>// Begin SpriteCustom.js
Sprite.prototype.getPolarStateByVector = function(firstState, stateCount) {
   var useDX;
   if (this.localDX == null)
      useDX = this.dx;
   else
      useDX = this.localDX;
   return firstState + Math.round(stateCount + Math.atan2(-this.dy, useDX) * stateCount / Math.PI / 2) % stateCount;
};

Sprite.prototype.tileCategoryTouched = function(category, initialOnly) {
   if (this.touchedTiles == null)
      return false;

   for (i = 0; i &lt; this.touchedTiles.length; i++) {
      var tt = this.touchedTiles[i];
      if (!tt.processed &amp;&amp; category.isTileMember(this.layer.tileset, this.layer.getTile(tt.x, tt.y))
         &amp;&amp; (!initialOnly || tt.initial))
      {
         this.TouchIndex = i;
         tt.processed = true;
         return true;
      }
   }
   return false;
};

Sprite.prototype.isCollisionRectWith = function(targetSprite) {
   if (!this.isActive)
      return false;
   if (targetSprite == null)
      return false;
   if (!targetSprite.isActive)
      return false;
   if (targetSprite == this)
      return false;

   var x1 = Math.floor(this.x);
   var w1 = this.getSolidWidth();
   var x2 = Math.floor(targetSprite.x);
   var w2 = targetSprite.getSolidWidth();
   var y1 = Math.floor(this.y);
   var h1 = this.getSolidHeight();
   var y2 = Math.floor(targetSprite.y);
   var h2 = targetSprite.getSolidHeight();

   return ((x1 + w1 &gt; x2) &amp;&amp; (x2 + w2 &gt; x1) &amp;&amp; (y1 + h1 &gt; y2) &amp;&amp; (y2 + h2 &gt; y1));
};

Sprite.prototype.reactToPush = function(pushers) {
   if (!this.isActive)
      return false;
   var result = false;
   for (var idx = 0; idx &lt; pushers.length; idx++)
   {
      var targetSprite = pushers[idx];
      if ((targetSprite == this) || (!targetSprite.isActive))
         continue;
      if (targetSprite.processed)
         result |= targetSprite.pushSprite(this);
   }
   return result;
};


Sprite.prototype.reactToPushback = function(pushers) {
   if (!this.isActive)
      return false;
   if (pushers == null)
      return false;
   var result = false;
   for (var idx = 0; idx &lt; pushers.length; idx++) {
      var targetSprite = pushers[idx];
      if (!targetSprite.isActive || targetSprite.processed || targetSprite == this)
         continue;
      if (this.isCollisionRectWith(targetSprite)) {
         targetSprite.processRules();
         result |= targetSprite.pushSprite(this);
      }
   }

   return result;
};

Sprite.prototype.pushSprite = function(targetSprite) {
   var x1 = Math.floor(this.x + this.dx);
   var w1 = this.getSolidWidth();
   var x2 = Math.floor(targetSprite.x + targetSprite.dx);
   var w2 = targetSprite.getSolidWidth();
   var y1 = Math.floor(this.y + this.dy);
   var h1 = this.getSolidHeight();
   var y2 = Math.floor(targetSprite.y + targetSprite.dy);
   var h2 = targetSprite.getSolidHeight();

   var pushright = x1 + w1 - x2;
   var pushleft = x2 + w2 - x1;
   if ((pushright &gt; 0) &amp;&amp; (pushleft &gt; 0)) {
      var pushx;
      pushx = (pushright &lt; pushleft) ? pushright : -pushleft;
      var pushdown = y1 + h1 - y2;
      var pushup = y2 + h2 - y1;
      if ((pushup &gt; 0) &amp;&amp; (pushdown &gt; 0)) {
         var pushy = (pushdown &lt; pushup) ? pushdown : -pushup;
         if (Math.abs(pushx) &gt; Math.abs(pushy)) {
            targetSprite.dy += pushy;
         } else {
            if (targetSprite.localDX != null)
               targetSprite.localDX += pushx;
            targetSprite.dx += pushx;
         }
         return true;
      }
   }
   return false;
}


Sprite.prototype.findNearestFreeBot = function(target, attachments, maxDistance) {
   var minDist = maxDistance * maxDistance;
   var index = -1;
   for (var i = 0; i &lt; target.length; i++)
   {
      if ((!target[i].isActive) || (target[i] == this))
         continue;
      var xOff = target[i].x - this.x;
      var yOff = target[i].y - this.y;
      var dist = xOff * xOff + yOff * yOff;
      if ((dist &lt; minDist) &amp;&amp; (this.getTargetAttachment(target, i, attachments) &lt; 0))
      {
         minDist = dist;
         index = i;
      }
   }

   return index;
};

Sprite.prototype.getTargetAttachment = function(targets, index, attachments) {
   if (index &lt; 0)
      index = this.getNearestSpriteIndex(targets);
   if (index &lt; 0)
      return -1;
   for(var i = 0; i &lt; attachments.length; i++)
      if (attachments[i].ridingOn == targets[index])
         return i;
   return -1;
};

Sprite.prototype.landOnConveyor = function(speed) {
   // If on rightward conveyor
   if (this.isAgainstTile(tileCategories.ConveyorRight, "BottomLeft", "Down") ||
       this.isAgainstTile(tileCategories.ConveyorRight, "BottomRight", "Down")) {
      // If not already on a conveyor belt (right)
      if ((this.onConveyorBelt == 0) || (this.onConveyorBelt == null)) {
         // Set rightward conveyor local velocity
         this.localDX = this.dx - speed;
         // Set rightward conveyor belt
         this.onConveyorBelt = 1;
      }
   } else {
      // Else if on leftward conveyor
      if (this.isAgainstTile(tileCategories.ConveyorLeft, "BottomLeft", "Down") ||
          this.isAgainstTile(tileCategories.ConveyorLeft, "BottomRight", "Down")) {
         // If not already on a conveyor (left)
         if ((this.onConveyorBelt == 0) || (this.onConveyorBelt == null)) {
            // Set local leftward conveyor local velocity
            this.localDX = this.dx + speed;
            // Set leftward conveyor belt
            this.onConveyorBelt = 2;
         }
      } else {
         // Else if was on a conveyor (and no longer is)
         if (this.onConveyorBelt != 0) {
            // Stop riding conveyor
            this.stopRiding();
            this.onConveyorBelt = 0;
         }
      }
   }
};

Sprite.prototype.isAgainstTile = function(category, relativePosition, direction) {
   var rp = this.getRelativePosition(relativePosition);
   switch(direction)
   {
      case "Up":
         rp.y -= 1;
         break;
      case "Right":
         rp.x += 1;
         break;
      case "Down":
         rp.y += 1;
         break;
      case "Left":
         rp.x -= 1;
         break;
      }
   return category.isTileMember(this.layer.tileset, this.layer.getTile(Math.floor(rp.x / this.layer.tileset.tileWidth),
      Math.floor(rp.y / this.layer.tileset.tileHeight)));
};

Sprite.prototype.reactToConveyor = function(speed) {
   // If riding rightward conveyor
   if (this.onConveyorBelt == 1) {
      // React to rightward conveyor
      this.dx = this.localDX + speed;
   } else {
      // Else if riding leftward conveyor
      if (this.onConveyorBelt == 2) {
         // React to leftward conveyor
         this.dx = this.localDX - speed;
      }
   }
};

Sprite.prototype.isOnTileValue = function(tileValue, relativePosition) {
   var rp = this.getRelativePosition(relativePosition);
   return this.layer.getTile(Math.floor(rp.x / this.layer.tileset.tileWidth),
      Math.floor(rp.y / this.layer.tileset.tileHeight)) == tileValue;
};

Sprite.prototype.tileGetValue = function(relativePosition) {
   var rp = this.getRelativePosition(relativePosition);
   return this.layer.getTile(Math.floor(rp.x / this.layer.tileset.tileWidth),
      Math.floor(rp.y / this.layer.tileset.tileHeight));
};

Sprite.prototype.attachToNearest = function(parentList) {
   if (this.ridingOn != null)
      return true;
   var nearest = this.getNearestSpriteIndex(parentList);
   if (nearest &gt;= 0)
      this.ridingOn = parentList[nearest];
   else
      return false;
   return true;
};

Sprite.prototype.stickToAttached = function(parentPoint, myPoint) {
   if (this.ridingOn == null)
      return;
   if (!this.ridingOn.processed)
      this.ridingOn.processRules();
   if (this.ridingOn.isActive == false)
   {
      this.ridingOn = null;
      return;
   }
   var ptParent = this.ridingOn.getRelativePosition(parentPoint);
   var ptSelf = this.getRelativePosition(myPoint);
   this.oldX = this.x;
   this.oldY = this.y;
   this.x += ptParent.x - ptSelf.x;
   this.y += ptParent.y - ptSelf.y;      
};

Sprite.prototype.isVisible = function() {
   return this.isActive &amp;&amp; this.layer.isSpriteVisible(this);
};

Sprite.prototype.unCrouch = function() {
   // If crouching left
   if (this.isInState(spriteDefinitions.Player.statesEnum.Crouch_left, spriteDefinitions.Player.statesEnum.Crouch_left)) {
      // Stand left
      return this.switchToState(spriteDefinitions.Player.statesEnum.Left, "BottomCenter");
   }
   // If crouching right
   if (this.isInState(spriteDefinitions.Player.statesEnum.Crouch_right, spriteDefinitions.Player.statesEnum.Crouch_right)) {
      // Stand right
      return this.switchToState(spriteDefinitions.Player.statesEnum.Right, "BottomCenter");
   }

   return this.isInState(spriteDefinitions.Player.statesEnum.Right, spriteDefinitions.Player.statesEnum.Left);
};

Sprite.prototype.tileSetValue = function(newTileValue, relativePosition) {
   var rp = this.getRelativePosition(relativePosition);
   this.layer.setTile(Math.floor(rp.x / this.layer.tileset.tileWidth), Math.floor(rp.y / this.layer.tileset.tileHeight), newTileValue);
};

Sprite.prototype.moveOverTiles = function(direction, count) {
   switch(direction)
   {
      case "Up":
         this.y -= this.layer.tileset.tileHeight * count;
         break;
      case "Right":
         this.x += this.layer.tileset.tileWidth * count;
         break;
      case "Down":
         this.y += this.layer.tileset.tileHeight * count;
         break;
      case "Left":
         this.x -= this.layer.tileset.tileWidth * count;
         break;
   }
};

Sprite.prototype.wasInputPressed = function(input) {
   return (0 != (this.oldInputs &amp; input));
}

Sprite.prototype.testCollisionRectMargin = function(targets, margin) {
   if (!this.isActive)
      return -1;
   if (targets == null)
      return -1;
   for(var idx = 0; idx &lt; targets.length; idx++) {
      var targetSprite = targets[idx];
      if ((targetSprite == this) || (!targetSprite.isActive))
         continue;
      var x1 = Math.floor(this.x);
      var w1 = this.getSolidWidth();
      var x2 = Math.floor(targetSprite.x);
      var w2 = targetSprite.getSolidWidth();
      var y1 = Math.floor(this.y);
      var h1 = this.getSolidHeight();
      var y2 = Math.floor(targetSprite.y);
      var h2 = targetSprite.getSolidHeight();

      if ((x1 + w1 &gt; x2 + margin) &amp;&amp; (x2 + w2 &gt; x1 + margin) &amp;&amp; (y1 + h1 &gt; y2 + margin) &amp;&amp; (y2 + h2 &gt; y1 + margin))
         return idx;
   }
   return -1;
};

Sprite.prototype.snapToTile = function() {
   this.x = Math.floor((this.x + this.layer.tileset.tileWidth / 2) / this.layer.tileset.tileWidth) * this.layer.tileset.tileWidth;
   this.y = Math.floor((this.y + this.layer.tileset.tileHeight / 2) / this.layer.tileset.tileHeight) * this.layer.tileset.tileHeight;
};

Sprite.prototype.removeDigit = function(value) {
   return Math.floor(value / 10);
};

Sprite.prototype.isTargetDirection = function(direction) {
   var target = this.getSelectedTargetFor("");
   if (target == null)
      return false;

   switch(direction)
   {
      case "Up":
         return target.y &lt; this.y;
      case "Left":
         return target.x &lt; this.x;
      case "Right":
         return target.x &gt; this.x;
      case "Down":
         return target.y &gt; this.y;
   }
   return false;
}
</Text>
  </SourceCode>
  <SourceCode Name="PlanCustom.js" IsCustomObject="true" DependsOn="PlanCustom.cs">
    <Text>// Begin PlanCustom.js
PlanBase.prototype.transportToPoint = function(sprite, target) {
   sprite.oldX = sprite.x;
   sprite.oldY = sprite.y;
   sprite.x = target.x;
   sprite.y = target.y;
}


PlanBase.prototype.moveSelectorLayer = function(visible) {
   if (visible) {
      if (this.layer.currentX &lt; 80) {
         this.layer.currentX += 32;
      }
   } else if (this.layer.currentX &gt; -512) {
      this.layer.currentX -= 32;
   }
}

PlanBase.prototype.wasInputPressed = function(sprite, input) {
   return sprite.wasInputPressed(input);
}
</Text>
  </SourceCode>
  <SourceCode Name="GeneralRulesCustom.js" IsCustomObject="true" DependsOn="">
    <Text>// Begin GeneralRulesCustom.js
GeneralRules.selectedSprites = {};

GeneralRules.prototype.getSelectedTargetFor = function(targetName) {
   return GeneralRules.selectedSprites[targetName];
}


GeneralRules.prototype.selectLastCreatedSprite = function() {
   this.selectLastCreatedSpriteFor("");
};

GeneralRules.prototype.selectLastCreatedSpriteFor = function(targetName) {
   GeneralRules.selectedSprites[targetName] = GeneralRules.lastCreatedSprite;
};

GeneralRules.prototype.setTargetParameter = function(parameterName, value) {
   this.setTargetParameterFor(parameterName, value, "");
};

GeneralRules.prototype.setTargetParameterFor = function(parameterName, value, targetName) {
   GeneralRules.selectedSprites[targetName][parameterName] = value;
};

GeneralRules.prototype.selectTargetSpriteFor = function(sprites, index, targetName) {
   if ((index &gt;= 0) &amp;&amp; (sprites.length &gt; index))
   {
      GeneralRules.selectedSprites[targetName] = sprites[index];
      return true;
   }
   else
   {
      GeneralRules.selectedSprites[targetName] = null;
      return false;
   }
};

GeneralRules.prototype.selectTargetSprite = function(sprites, index) {
   return this.selectTargetSpriteFor(sprites, index, "");
}

GeneralRules.prototype.isSpriteForTargetOfType = function(targetName, spriteDefinition) {
   if (GeneralRules.selectedSprites[targetName] == null)
      return false;
   return GeneralRules.selectedSprites[targetName] instanceof spriteDefinitions[spriteDefinition];
}

GeneralRules.prototype.deactivateTargetSpriteFor = function(targetName) {
   var s = GeneralRules.selectedSprites[targetName];
   if (s == null)
      return false;
   var result;
   result = s.isActive;
   s.deactivate();
   delete GeneralRules.selectedSprites[targetName];
   return result;
};


</Text>
  </SourceCode>
  <SourceCode Name="MapLayerCustom.js" IsCustomObject="true" DependsOn="">
    <Text>// Begin MapLayerCustom.js

MapLayer.prototype.isSpriteVisible = function(sprite) {
   if (!sprite.isActive)
      return -1;
   var x1 = Math.floor(sprite.x);
   var w1 = sprite.getSolidWidth();
   var x2 = -this.currentX;
   var w2 = viewWidth;
   var y1 = Math.floor(sprite.y);
   var h1 = sprite.getSolidHeight();
   var y2 = -this.currentY;
   var h2 = viewHeight;

   if ((x1 + w1 &gt; x2) &amp;&amp; (x2 + w2 &gt; x1) &amp;&amp; (y1 + h1 &gt; y2) &amp;&amp; (y2 + h2 &gt; y1))
      return true;
   return false;
}</Text>
  </SourceCode>
  <SourceCode Name="Template.html" IsCustomObject="false">
    <Text>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/&gt;
&lt;title&gt;&lt;!--#echo var="Title" --&gt;&lt;/title&gt;
&lt;style&gt;
   .unselectable {
      user-select:none;
      -moz-user-select:-moz-none;
      -khtml-user-select:none;
      -webkit-user-select:none;
      -o-user-select:none;
   }
   canvas { display: block }
   &lt;!--#echo var="BodyCSS" --&gt;
&lt;/style&gt;

&lt;!--#echo var="Scripts" --&gt;
&lt;/head&gt;
&lt;body class="unselectable" unselectable="on"&gt;
&lt;canvas id="gameView" width="&lt;!--#echo var="Width" --&gt;" height="&lt;!--#echo var="Height" --&gt;" unselectable="on" class="unselectable"&gt;
   Your browser does not support HTML5 canvases.
&lt;/canvas&gt;
&lt;!--#echo var="Images" --&gt;
&lt;!--#echo var="MapButtons" --&gt;
&lt;audio id="soundAhh"&gt;
&lt;source src="ahh.ogg" type="audio/ogg" /&gt;
&lt;source src="ahh.mp3" type="audio/mp3" /&gt;
Your browser does not support the HTML5 audio tag.
&lt;/audio&gt;
&lt;audio id="soundBing"&gt;
&lt;source src="bing.ogg" type="audio/ogg" /&gt;
&lt;source src="bing.mp3" type="audio/mp3" /&gt;
Your browser does not support the HTML5 audio tag.
&lt;/audio&gt;
&lt;audio id="soundExplode"&gt;
&lt;source src="explode.ogg" type="audio/ogg" /&gt;
&lt;source src="explode.mp3" type="audio/mp3" /&gt;
Your browser does not support the HTML5 audio tag.
&lt;/audio&gt;
&lt;audio id="soundPickup"&gt;
&lt;source src="pickup.ogg" type="audio/ogg" /&gt;
&lt;source src="pickup.mp3" type="audio/mp3" /&gt;
Your browser does not support the HTML5 audio tag.
&lt;/audio&gt;
&lt;/body&gt;
&lt;/html&gt;
</Text>
  </SourceCode>
  <SourceCode Name="Main.js" IsCustomObject="false">
    <Text>var gameViewContext;
var mouseInfo = {x: 0,y:0,pressed:false,oldX:0,oldY:0,clicked:false};
var currentMap;
var overlayMap;
var mainLoop = {interval:null, milliseconds:20};
var sounds = {};
function startGame() {
   initGraphicSheets();
   initFramesets();
   initTilesets();
   initTileCategories();
   firstMap();
   var gameView = document.getElementById('gameView');

   sounds.initialize();

   gameView.onmousedown = function(e) {
      e = e || window.event;
      mouseInfo.x = e.clientX;
      mouseInfo.y = e.clientY;
      mouseInfo.pressed = true;
      mouseInfo.clicked = true;
   };

   gameView.onmousemove = function(e) {
      e = e || window.event;
      mouseInfo.x = e.clientX;
      mouseInfo.y = e.clientY;
   };

   gameView.onmouseup = function(e) {
      mouseInfo.pressed = false;
   };

   gameView.onmouseout = function(e) {
      mouseInfo.pressed = false;
   };

   gameView.ontouchstart = function(e) {
      e = e || window.event;
      e.preventDefault();
      var touch = e.touches.item(0);
      mouseInfo.x = touch.clientX;
      mouseInfo.y = touch.clientY;
      mouseInfo.pressed = true;
      mouseInfo.clicked = true;
   };

   gameView.ontouchmove = function(e) {
      e = e || window.event;
      e.preventDefault();
      var touch = e.touches.item(0);
      mouseInfo.x = touch.clientX;
      mouseInfo.y = touch.clientY;
      mouseInfo.pressed = true;
   };
   
   gameView.ontouchend = function(e) {
      e = e || window.event;
      e.preventDefault();
      mouseInfo.pressed = false;
   }

   gameViewContext = gameView.getContext('2d');
   mainLoop.interval = setInterval("pulse()", mainLoop.milliseconds);
}

function pulse() {
   if (currentMap != null)
   {
      currentMap.draw(gameViewContext);
      currentMap.executeRules();
   }
   GeneralRules.drawMessages();
   if (overlayMap != null)
   {
      overlayMap.draw(gameViewContext);
      overlayMap.executeRules();
   }
   cycleMouseInfo();
}

function cycleMouseInfo() {
   mouseInfo.oldX = mouseInfo.x;
   mouseInfo.oldY = mouseInfo.y;
   mouseInfo.clicked = false;
}

function resizeView() {
   viewWidth = window.innerWidth;
   viewHeight = window.innerHeight;
   var gameView = document.getElementById('gameView');
   gameView.width = viewWidth;
   gameView.height = viewHeight;
   if ((gameViewContext != null) &amp;&amp; (currentMap != null))
      currentMap.draw(gameViewContext);
}

function truncate(n) {
   return n | 0;
}
</Text>
  </SourceCode>
  <SourceCode Name="Frame.js" IsCustomObject="false">
    <Text>function Frameset(name, frames) {
   this.name = name;
   this.frames = frames;
}
function XFrame(m11, m12, m21, m22, dx, dy, graphicSheet, imageSource, cellIndex) {
   this.m11 = m11;
   this.m12 = m12;
   this.m21 = m21;
   this.m22 = m22;
   this.dx = dx;
   this.dy = dy;
   this.graphicSheet = graphicSheet;
   this.imageSource = imageSource;
   this.cellIndex = cellIndex;
}
function Frame(graphicSheet, imageSource, cellIndex) {
   this.graphicSheet = graphicSheet;
   this.imageSource = imageSource;
   this.cellIndex = cellIndex;
}
Frame.prototype.draw = function(ctx, x, y) {
   if (this.imageSource == null) return;
   ctx.drawImage(this.imageSource, (this.cellIndex % this.graphicSheet.columns) * this.graphicSheet.cellWidth,
   Math.floor(this.cellIndex / this.graphicSheet.columns) * this.graphicSheet.cellHeight,
   this.graphicSheet.cellWidth, this.graphicSheet.cellHeight, x, y, this.graphicSheet.cellWidth, this.graphicSheet.cellHeight);
};
XFrame.prototype.draw = function(ctx, x, y) {
   ctx.save();
   ctx.transform(this.m11, this.m12, this.m21, this.m22, this.dx+x, this.dy+y);
   ctx.drawImage(this.imageSource, (this.cellIndex % this.graphicSheet.columns) * this.graphicSheet.cellWidth,
      Math.floor(this.cellIndex / this.graphicSheet.columns) * this.graphicSheet.cellHeight,
      this.graphicSheet.cellWidth, this.graphicSheet.cellHeight, 0, 0, this.graphicSheet.cellWidth, this.graphicSheet.cellHeight);
   ctx.restore();
};
function ModulateCelColor(target, x, y, width, height, r, g, b, a) {
   var cel;
   try { cel = target.getImageData(x, y, width, height); }
   catch(e) {
      document.write('Failed to process images. This may occur when running from local files; see &lt;a href="http://stackoverflow.com/questions/2704929/uncaught-error-security-err-dom-exception-18"&gt;see details&lt;/a&gt;');
      throw(e);
   }
   var celData = cel.data;
   for (yi = 0; yi &lt; height; yi++) {
      for (xi = 0; xi &lt; width; xi++) {
         var byteIdx = (yi * width + xi) * 4;
         celData[byteIdx] = Math.floor(celData[byteIdx] * r / 255);
         celData[byteIdx+1] = Math.floor(celData[byteIdx+1] * g / 255);
         celData[byteIdx+2] = Math.floor(celData[byteIdx+2] * b / 255);
         celData[byteIdx+3] = Math.floor(celData[byteIdx+3] * a / 255);
      }
   }
   target.putImageData(cel, x, y);
}</Text>
  </SourceCode>
  <SourceCode Name="KeyboardState.js" IsCustomObject="false">
    <Text>var keyboardState;
keyboardState = new Object();
keyboardState.key= { None:0, Enter:13, Shift:16, Ctrl:17, Alt: 18, Pause:19, Escape:27, Space:32, PageUp:33, PageDown:34,
   End:35, Home:36, Left:37, Up:38, Right:39, Down:40, Insert:45, Delete:46,
   Digit0:48, Digit1:49, Digit2:50, Digit3:51, Digit4:52, Digit5:53, Digit6:54, Digit7:55, Digit8:56, Digit9:57,
   A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, L:76, M:77, N:78, O:79,
   P: 80, Q:81, R:82, S:83, T:84, U:85, V:86, W:87, X:88, Y:89, Z:90,
   LWindow:91, RWindow:92, ContextMenu:93,
   NumPad0:96, NumPad1:97, NumPad2:98, NumPad3:99, NumPad4:100, NumPad5:101, NumPad6:102, NumPad7:103, NumPad8:104, NumPad9:105,
   NumPadMultiply:106, NumPadAdd:107, NumPadEnter:108, NumPadSubtract:109, NumPadDecimal:110, NumPadDivide:111,
   F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123,
   NumLock:144, ScrollLock:145,
   SemiColon:186, Equal:187, Comma:188, Minus:189, Period:190, Slash:191, Backtick:192,
   LeftBracket:219, BackSlash:220, RightBracket:221, Quote:222 };

keyboardState.keyState = new Array();
keyboardState.handleKeyDown = function(e) {
   e = e || window.event;
   keyboardState.keyState[e.keyCode] = true;
};

keyboardState.handleKeyUp = function(e) {
   e = e || window.event;
   keyboardState.keyState[e.keyCode] = false;
};

keyboardState.isKeyPressed = function(key) { return keyboardState.keyState[key]; };

document.onkeydown = keyboardState.handleKeyDown;
document.onkeyup = keyboardState.handleKeyUp;
</Text>
  </SourceCode>
  <SourceCode Name="Player.js" IsCustomObject="false">
    <Text>function KeyboardPlayer(defaultSet) {
   switch(defaultSet)
   {
      case 0:
         this.initializeKeys(
            keyboardState.key.Up,     // Up
            keyboardState.key.Left,   // Left
            keyboardState.key.Right,  // Right
            keyboardState.key.Down,   // Down
            keyboardState.key.Ctrl,   // Button 1
            keyboardState.key.Space,  // Button 2
            keyboardState.key.Enter,  // Button 3
            keyboardState.key.Shift); // Button 4
         break;
      case 1:
         this.initializeKeys(
            keyboardState.key.W,     // Up
            keyboardState.key.A,     // Left
            keyboardState.key.D,     // Right
            keyboardState.key.S,     // Down
            keyboardState.key.Z,     // Button 1
            keyboardState.key.C,     // Button 2
            keyboardState.key.Q,     // Button 3
            keyboardState.key.E);    // Button 4
         break;
      case 2:
         this.initializeKeys(
            keyboardState.key.NumPad8,      // Up
            keyboardState.key.NumPad4,      // Right
            keyboardState.key.NumPad6,      // Left
            keyboardState.key.NumPad2,      // Down
            keyboardState.key.NumPad5,      // Button 1
            keyboardState.key.NumPad0,      // Button 2
            keyboardState.key.NumPadEnter,  // Button 3
            keyboardState.key.NumPad7);     // Button 4
         break;
      default:
         this.initializeKeys(
            keyboardState.key.I,            // Up
            keyboardState.key.J,            // Right
            keyboardState.key.L,            // Left
            keyboardState.key.K,            // Down
            keyboardState.key.U,            // Button 1
            keyboardState.key.O,            // Button 2
            keyboardState.key.M,            // Button 3
            keyboardState.key.Comma);       // Button 4
         break;
   }
}

KeyboardPlayer.prototype.initializeKeys = function(up, left, right, down, button1, button2, button3, button4) {
   this.upKey = up;
   this.leftKey = left;
   this.rightKey = right;
   this.downKey = down;
   this.button1Key = button1;
   this.button2Key = button2;
   this.button3Key = button3;
   this.button4Key = button4;
};

KeyboardPlayer.prototype.up = function() { return keyboardState.keyState[this.upKey]; };
KeyboardPlayer.prototype.left = function() { return keyboardState.keyState[this.leftKey]; };
KeyboardPlayer.prototype.right = function() { return keyboardState.keyState[this.rightKey]; };
KeyboardPlayer.prototype.down = function() { return keyboardState.keyState[this.downKey]; };
KeyboardPlayer.prototype.button1 = function() { return keyboardState.keyState[this.button1Key]; };
KeyboardPlayer.prototype.button2 = function() { return keyboardState.keyState[this.button2Key]; };
KeyboardPlayer.prototype.button3 = function() { return keyboardState.keyState[this.button3Key]; };
KeyboardPlayer.prototype.button4 = function() { return keyboardState.keyState[this.button4Key]; };

var players = [ new KeyboardPlayer(0), new KeyboardPlayer(1), new KeyboardPlayer(2), new KeyboardPlayer(3) ];</Text>
  </SourceCode>
  <SourceCode Name="GeneralRules.js" IsCustomObject="false">
    <Text>function GeneralRules() {
}

GeneralRules.buttonSpecifier = {first:1, second:2, third:4, fourth:8, freezeInputs:16};
GeneralRules.maxMessages = 4;
GeneralRules.messageBackground = "rgba(64, 0, 255, .5)";
GeneralRules.currentPlayer = 0;
GeneralRules.activeMessages = [];
GeneralRules.messageMargin = 6;

GeneralRules.prototype.saveGame = function(slot, temporary) {
   if (GeneralRules.saveUnit == null) {
      this.includeInSaveUnit("AllMaps");
      this.includeInSaveUnit("AllCounters");
      this.includeInSaveUnit("WhichMapIsCurrent");
      this.includeInSaveUnit("WhichMapIsOverlaid");
   }
   if (GeneralRules.saveUnit.allMaps) {
      GeneralRules.saveUnit.maps = {};
      for(var key in maps) {
         GeneralRules.saveUnit.maps[key] = maps[key].getState();
      }
   } else if (GeneralRules.saveUnit.maps !== undefined) {
      for(var key in GeneralRules.saveUnit.maps) {
         GeneralRules.saveUnit.maps[key] = maps[key].getState();
      }
   }
   if (GeneralRules.saveUnit.counters != null) {
      for(var key in GeneralRules.saveUnit.counters) {
         GeneralRules.saveUnit.counters[key] = counters[key];
      }
   }
   if (GeneralRules.saveUnit.currentMap !== undefined)
      GeneralRules.saveUnit.currentMap = getMapName(currentMap);
   if (GeneralRules.saveUnit.overlayMap !== undefined)
      GeneralRules.saveUnit.overlayMap = getMapName(overlayMap);
   if (temporary)
      GeneralRules["save" + slot] = JSON.stringify(GeneralRules.saveUnit);
   else
      localStorage.setItem("save" + slot, JSON.stringify(GeneralRules.saveUnit));
   GeneralRules.saveUnit = null;
};

GeneralRules.prototype.loadGame = function(slot, temporary) {
   var data;
   if (temporary)
      data = GeneralRules["save" + slot];
   else
      data = localStorage.getItem("save" + slot);
   if (data == null) return;
   data = JSON.parse(data);
   for(var key in data.maps)
   {
      if (maps[key] == null)
         mapInitializers[key]();
      maps[key].setState(data.maps[key]);
   }
   if (data.allMaps)
   {
      for(var key in maps)
         if (data.maps[key] == null)
            delete maps[key];
   }
   if (data.counters != null) {
      for(var key in data.counters)
         counters[key].value = data.counters[key].value; // Tile definitions are linked to the original counter instance
   }
   if (data.currentMap !== undefined) {
      if (maps[data.currentMap] === undefined)
         mapInitializers[data.currentMap]();
      currentMap = maps[data.currentMap];
   }
   if (data.overlayMap !== undefined)
      this.setOverlay(data.overlayMap);
};

GeneralRules.prototype.deleteSave = function(slot, temporary) {
   if (temporary)
      delete GeneralRules["save" + slot];
   else
      localStorage.removeItem("save" + slot);
}

GeneralRules.prototype.saveExists = function(slot, temporary) {
   if (temporary)
      return GeneralRules["save" + slot] != null;
   else
      return localStorage.getItem("save" + slot) != null;
};

GeneralRules.prototype.includeMapInSaveUnit = function(mapName) {
   if (GeneralRules.saveUnit == null)
      GeneralRules.saveUnit = {};
   if (GeneralRules.saveUnit.maps == null)
      GeneralRules.saveUnit.maps = {};
   GeneralRules.saveUnit.maps[mapName] = null;
};

GeneralRules.prototype.excludeMapFromSaveUnit = function(mapName) {
   if ((GeneralRules.saveUnit == null) || (GeneralRules.saveUnit.maps == null))
      return;
   if (GeneralRules.saveUnit.maps[mapName] !== undefined)
      delete GeneralRules.saveUnit.maps[mapName];
}

GeneralRules.prototype.includeInSaveUnit = function(include) {
   if (GeneralRules.saveUnit == null)
      GeneralRules.saveUnit = {};

   switch (include) {
      case "AllMaps":
         GeneralRules.saveUnit.allMaps = true;
         break;
      case "AllCounters":
         GeneralRules.saveUnit.counters = {};
         for(key in counters)
            GeneralRules.saveUnit.counters[key] = null;
         break;
      case "WhichMapIsCurrent":
         GeneralRules.saveUnit.currentMap = null;
         break;
      case "WhichMapIsOverlaid":
         GeneralRules.saveUnit.overlayMap = null;
         break;
      case "PlayerOptions":
         // Not implemented
         break;
   }
};

GeneralRules.prototype.includeCounterInSaveUnit = function(counter) {
   if (GeneralRules.saveUnit == null)
      GeneralRules.saveUnit = {};
   if (GeneralTules.saveUnit.counters == null)
      GeneralRules.saveUnit.counters = {};
   GeneralRules.saveUnit.counters[key] = null;
}

GeneralRules.prototype.excludeCounterFromSaveUnit = function(counter) {
   if ((GeneralRules.saveUnit == null) || (GeneralRules.saveUnit.counters == null))
      return;
   for (key in GeneralRules.saveUnit.counters) {
      if (counters[key] === counter)
         delete GeneralRules.saveUnit.counters[key];
   }
};

GeneralRules.prototype.changeCounter = function(counter, operation) {
   switch (operation) {
      case "IncrementAndStop":
         if (counter.value &lt; counter.max)
            counter.value += 1;
         else
            return true;
         return false;
      case "DecrementAndStop":
         if (counter.value &gt; counter.min)
            counter.value -= 1;
         else
            return true;
         return false;
      case "IncrementAndLoop":
         if (counter.value &lt; counter.max)
         {
            counter.value += 1;
            return false;
         }
         counter.value = counter.min;
         return true;
      case "DecrementAndLoop":
         if (counter.value &gt; counter.min) {
            counter.value -= 1;
            return false;
         }
         counter.value = counter.max;
         return true;
      case "SetToMinimum":
         if (counter.value == counter.min)
            return true;
         counter.value = counter.min;
         return false;
      case "SetToMaximum":
         if (counter.value == counter.max)
            return true;
         counter.value = counter.max;
         return false;
   }
   return false;
};

GeneralRules.prototype.setMapFlag = function(flagIndex, value) {
   if (this.layer.map.mapFlags == null)
      this.layer.map.mapFlags = 0;
   if (value)
      this.layer.map.mapFlags |= 1 &lt;&lt; flagIndex;
   else
      this.layer.map.mapFlags &amp;= ~(1 &lt;&lt; flagIndex);
};

GeneralRules.prototype.isMapFlagOn = function(flagIndex) {
   if (this.layer.map.mapFlags == null)
      this.layer.map.mapFlags = 0;
   return ((this.layer.map.mapFlags &amp; (1 &lt;&lt; flagIndex)) != 0);
};

GeneralRules.prototype.setTargetMapFlag = function(mapName, flagIndex, value) {
   if (value)
      maps[mapName].mapFlags |= 1 &lt;&lt; flagIndex;
   else
      maps[mapName].mapFlags &amp;= ~(1 &lt;&lt; flagIndex);
}

GeneralRules.prototype.clearOverlay = function() {
   overlayMap = null;
};

GeneralRules.prototype.clearAllMessages = function() {
   GeneralRules.activeMessages.length = 0;
};

GeneralRules.prototype.canReturnToPreviousMap = function() {
   return currentMap.cameFromMapName != null;
};

GeneralRules.prototype.returnToPreviousMap = function(unloadCurrent) {
   var source = currentMap.cameFromMapName;
   if (source == null)
      source = getMapName(currentMap);
   if (unloadCurrent)
      for(var key in maps)
         if (maps[key] == currentMap)
            delete maps[key];
   if (maps[source] === undefined)
      mapInitializers[source]();
   currentMap = maps[source];
};

GeneralRules.prototype.switchToMap = function(mapName, unloadCurrent) {
   var oldMapName = null;
   if (currentMap != null) {
      for(key in maps) {
         if (maps[key] === currentMap) {
            if (unloadCurrent)
               delete maps[key];
            oldMapName = key;
         }
      }
   }
   if (maps[mapName] === undefined)
      mapInitializers[mapName]();
   currentMap = maps[mapName];
   currentMap.cameFromMapName = oldMapName;
};

GeneralRules.prototype.isKeyPressed = function(key) {
   return keyboardState.isKeyPressed(key);
};

GeneralRules.prototype.setOverlay = function(mapName) {
   if (maps[mapName] === undefined)
      mapInitializers[mapName]();
   overlayMap = maps[mapName];
};

GeneralRules.prototype.unloadBackgroundMaps = function() {
   for(key in maps) {
      if ((maps[key] !== currentMap) &amp;&amp; (maps[key] !== overlayMap))
         delete maps[key];
   }
};

GeneralRules.prototype.unloadMap = function(mapName) {
   delete maps[mapName];
}

GeneralRules.prototype.setMessageFont = function(tileset) {
   GeneralRules.fontTileset = tileset;
};

GeneralRules.colorNameToRgba = function(color, alpha) {
    var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
    "beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887",
    "cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff",
    "darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f",
    "darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1",
    "darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff",
    "firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff",
    "gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f",
    "honeydew":"#f0fff0","hotpink":"#ff69b4",
    "indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c",
    "lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2",
    "lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de",
    "lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6",
    "magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
    "mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5",
    "navajowhite":"#ffdead","navy":"#000080",
    "oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6",
    "palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080",
    "red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
    "saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4",
    "tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0",
    "violet":"#ee82ee",
    "wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5",
    "yellow":"#ffff00","yellowgreen":"#9acd32"};

    return "rgba(" + parseInt(colors[color].substr(1,2), 16) + "," + parseInt(colors[color].substr(3,2), 16) + "," + parseInt(colors[color].substr(5,2), 16) + "," + alpha/255 + ")";
};

GeneralRules.prototype.setMessageBackground = function(color, alpha) {
   GeneralRules.messageBackground = GeneralRules.colorNameToRgba(color, alpha);
};

GeneralRules.prototype.setMessageDismissal = function(dismissButton, player) {
   GeneralRules.dismissButton = dismissButton;
   GeneralRules.currentPlayer = player - 1;
};

GeneralRules.prototype.showMessage = function(message) {
   if (GeneralRules.activeMessages.length &gt;= GeneralRules.maxMessages)
      throw "Maximum number of displayed messages exceeded";
   else
      GeneralRules.activeMessages.push(this.createMessage(message));
};

function MessageLayer(tileset, map, columns, rows, offsetX, offsetY, background, player, dismissButton) {
   MapLayer.call(this, map, tileset, columns, rows, 0, 0, offsetX, offsetY, 0, 0, 0, null);
   this.background = background;
   this.dismissButton = dismissButton;
   this.player = player;
}

MessageLayer.prototype = new MapLayer();
MessageLayer.prototype.constructor = MessageLayer;

GeneralRules.playerPressButton = function(playerNumber) {
   for (var i = 0; i &lt; GeneralRules.activeMessages.length; i++) {
      var msg = GeneralRules.activeMessages[i];
      if (msg.player == playerNumber - 1) {
         var player = players[playerNumber - 1];
         var dismissPressed = false;
         if ((msg.dismissButton &amp; GeneralRules.buttonSpecifier.first) &amp;&amp; player.button1())
            dismissPressed = true;
         if ((msg.dismissButton &amp; GeneralRules.buttonSpecifier.second) &amp;&amp; player.button2())
            dismissPressed = true;
         if ((msg.dismissButton &amp; GeneralRules.buttonSpecifier.third) &amp;&amp; player.button3())
            dismissPressed = true;
         if ((msg.dismissButton &amp; GeneralRules.buttonSpecifier.fourth) &amp;&amp; player.button4())
            dismissPressed = true;

         // dismissPhase[x]:
         // 0 = No frames have passed yet
         // 1 = Frames have passed and the dismiss button was initially pressed
         // 2 = Frames have passed and the dismiss button is not pressed
         // 3 = Dismiss button was not pressed, but now it is.

         if (GeneralRules.dismissPhase == null)
            GeneralRules.dismissPhase = [0,0,0,0];

         if (dismissPressed) {
            if ((GeneralRules.dismissPhase[msg.player] == 0) || (GeneralRules.dismissPhase[msg.player] == 2))
               GeneralRules.dismissPhase[msg.player]++;
         } else {
            if (GeneralRules.dismissPhase[msg.player] &lt; 2)
               GeneralRules.dismissPhase[msg.player] = 2;
            else if (GeneralRules.dismissPhase[msg.player] &gt; 2) {
               GeneralRules.dismissMessage(i);
               GeneralRules.dismissPhase[msg.player] = 0;
            }
         }

         if (msg.dismissButton &amp; GeneralRules.buttonSpecifier.freezeInputs) {
            return false;
         }
      }
   }
   return true;
};

GeneralRules.dismissMessage = function (messageIndex) {
   GeneralRules.activeMessages.splice(messageIndex, 1);
};

GeneralRules.prototype.createMessage = function(message) {
   if (GeneralRules.fontTileset == null) {
      var tilesetKey;
      for (tilesetKey in tilesets)
         break;
      GeneralRules.fontTileset = tilesets[tilesetKey];
   }

   var x = 0, y = 1;
   var maxWidth = 1;
   for (var charIdx = 0; charIdx &lt; message.length; charIdx++) {
      if (message[charIdx] == '\n') {
         x = 0;
         y++;
      } else if (message[charIdx] != '\r') {
         if (++x &gt; maxWidth)
            maxWidth = x;
      }
   }

   var messageSize = {width: maxWidth * GeneralRules.fontTileset.tileWidth, height: y * GeneralRules.fontTileset.tileHeight};
   var messageX = Math.floor((viewWidth - messageSize.width) / 2);
   var messageY = Math.floor((viewHeight - messageSize.height) / 2);

   var result = new MessageLayer(
      GeneralRules.fontTileset, this.layer.map, maxWidth, y, messageX, messageY,
      GeneralRules.messageBackground, GeneralRules.currentPlayer, GeneralRules.dismissButton);

   x = 0;
   y = 0;
   for (var charIdx = 0; charIdx &lt; message.length; charIdx ++) {
      if (message.charAt(charIdx) == '\n') {
         x = 0;
         y++;
      } else if (message.charAt(charIdx) != '\r') {
         result.setTile(x++, y, message.charCodeAt(charIdx));
      }
   }

   return result;
}

GeneralRules.drawMessage = function(msg) {
   var messageRect = {
      x: msg.currentX - GeneralRules.messageMargin,
      y: msg.currentY - GeneralRules.messageMargin,
      width: msg.virtualColumns * msg.tileset.tileWidth + GeneralRules.messageMargin * 2,
      height: msg.virtualRows * msg.tileset.tileHeight + GeneralRules.messageMargin * 2};
   gameViewContext.fillStyle = msg.background;
   gameViewContext.fillRect(messageRect.x, messageRect.y, messageRect.width, messageRect.height);
   gameViewContext.strokeStyle = "#ffffff";
   gameViewContext.lineWidth = 2;
   gameViewContext.strokeRect(messageRect.x, messageRect.y, messageRect.width, messageRect.height);
   msg.draw(gameViewContext);
};

GeneralRules.drawMessages = function() {
   for (var i = 0; i &lt; GeneralRules.activeMessages.length; i++) {
      var msg = GeneralRules.activeMessages[i];
      GeneralRules.drawMessage(msg);
   }
};

GeneralRules.prototype.limitFrameRate = function(fps) {
   if (fps == 0) {
      mainLoop.milliseconds = 0;
      if (mainLoop.interval != null)
         clearInterval(mainLoop.interval);
      mainLoop.interval = null;
      return;
   }

   var milliseconds = Math.ceil(1000 / fps);
   if (milliseconds != mainLoop.milliseconds) {
      if (mainLoop.interval != null)
         clearInterval(mainLoop.interval);
      mainLoop.milliseconds = milliseconds;
      mainLoop.interval = setInterval("pulse()", mainLoop.milliseconds);
   }
};

GeneralRules.prototype.setCategorySpriteState = function(category, spriteIndex, state) {
   category[spriteIndex].state = state;
};

GeneralRules.prototype.quitGame = function() {
   window.close();
};

GeneralRules.prototype.getRandomNumber = function(minimum, maximum) {
   return Math.floor(Math.random() * (maximum - minimum)) + minimum;
};

GeneralRules.prototype.dragMap = function () {
   if (mouseInfo.pressed &amp;&amp; !mouseInfo.clicked)
      currentMap.scroll(currentMap.scrollX + mouseInfo.x - mouseInfo.oldX, currentMap.scrollY + mouseInfo.y - mouseInfo.oldY);
};

GeneralRules.prototype.clicked = function() {
   return mouseInfo.clicked;
};
</Text>
  </SourceCode>
  <SourceCode Name="Sprite.js" IsCustomObject="false">
    <Text>function SpriteState(solidWidth, solidHeight, frameSetName, bounds, frames) {
   this.solidWidth = solidWidth;
   this.solidHeight = solidHeight;
   this.frameSetName = frameSetName;
   this.bounds = bounds;
   this.frames = frames;
   this.totalDuration = frames ? frames[frames.length - 1].accumulatedDuration : 0;
}

function Sprite(layer, x, y, dx, dy, state, frame, active, priority, solidity) {
   this.layer = layer;
   this.x = x;
   this.y = y;
   this.dx = dx;
   this.dy = dy;
   this.state = state;
   this.frame = frame;
   this.isActive = active;
   this.priority = priority;
   this.solidity = solidity;
   this.ridingOn = null;
   this.localDX = null;
   this.inputs = 0;
   this.oldInputs = 0;
}

Sprite.prototype = new GeneralRules();
Sprite.prototype.constructor = Sprite;

Sprite.categorize = function(sprites) {
   var categories = {};
   for(var sprKey in sprites) {
      var spr = sprites[sprKey];
      if (spr.categories == null) continue;
      for(var sprCatKey in spr.categories) {
         var cat = spr.categories[sprCatKey];
         if (categories[cat] == null)
            categories[cat] = [spr];
         else
            categories[cat].push(spr);
      }
   }
   return categories;
}

Sprite.deserialize = function(layer,data) {
   var source = JSON.parse(data);
   return spriteDefinitions[source["~1"]].deserialize(layer, data);
}

Sprite.prototype.getCurFrames = function() {
   var curState = this.states[this.state];
   if (curState.frames == null) return null;
   for(var i = 0; i &lt; curState.frames.length; i++) {
      if((this.frame % curState.totalDuration) &lt; curState.frames[i].accumulatedDuration) return curState.frames[i].subFrames;
   }
   return curState.frames[curState.frames.length - 1].subFrames;
};

Sprite.prototype.getSolidWidth = function() {
   return this.states[this.state].solidWidth;
};

Sprite.prototype.getSolidHeight = function() {
   return this.states[this.state].solidHeight;
};

Sprite.prototype.reactToSolid = function() {
   if (this.solidity == null)
      return;
   var hit = false;
   var dyOrig = this.dy;
   var dxOrig = this.dx;

   var proposedPixelY2 = Math.ceil(this.y + this.dy);
   var pixelX = Math.floor(this.x);
   var pixelY = Math.floor(this.y);
   var solidWidth = this.getSolidWidth();
   var solidHeight = this.getSolidHeight();
   var proposedPixelX = Math.floor(this.x + this.dx);
   var proposedPixelY = Math.floor(this.y + this.dy);
   var solidPixelWidth = solidWidth + Math.ceil(this.x) - pixelX;
   if (this.dy &gt; 0)
   {
      var ground = this.layer.getTopSolidPixel(pixelX, pixelY + solidHeight, solidPixelWidth, proposedPixelY2 - pixelY, this.solidity);
      if (ground != MapLayer.noSolid)
      {
         this.dy = ground - solidHeight - this.y;
         hit = true;
      }
   }
   else if (this.dy &lt; 0)
   {
      var ceiling = this.layer.getBottomSolidPixel(pixelX, proposedPixelY, solidPixelWidth, pixelY - proposedPixelY, this.solidity);
      if (ceiling != MapLayer.noSolid)
      {
         this.dy = ceiling + 1 - this.y;
         hit = true;
      }
   }

   proposedPixelY = Math.floor(this.y + this.dy);

   if (this.dx &gt; 0)
   {
      var proposedPixelX2 = Math.ceil(this.x + this.dx);
      var pixelX2 = Math.ceil(this.x);
      var rightwall = this.layer.getLeftSolidPixel(pixelX2 + solidWidth, proposedPixelY, proposedPixelX2 - pixelX2, solidHeight, this.solidity);
      var hitWall = false;
      if (rightwall != MapLayer.noSolid)
      {
         var maxSlopeProposedY = Math.floor(this.y + this.dy - this.dx);
         var slopedFloor = this.layer.getTopSolidPixel(pixelX2 + solidWidth, maxSlopeProposedY + solidHeight, proposedPixelX2 - pixelX2, proposedPixelY - maxSlopeProposedY, this.solidity);
         if (slopedFloor != MapLayer.noSolid)
         {
            var ceiling = this.layer.getBottomSolidPixel(pixelX2, slopedFloor - solidHeight, solidWidth, proposedPixelY + solidHeight - slopedFloor, this.solidity);
            if ((ceiling == MapLayer.noSolid) &amp;&amp; (this.ridingOn == null))
            {
               var rightwall2 = this.layer.getLeftSolidPixel(pixelX2 + solidWidth, slopedFloor - solidHeight, proposedPixelX2 - pixelX2, solidHeight, this.solidity);
               if (rightwall2 == MapLayer.noSolid)
                  this.dy = dyOrig = slopedFloor - solidHeight - 1 - this.y;
               else
                  hitWall = true;
            }
            else
               hitWall = true;
         }
         else
         {
            maxSlopeProposedY = Math.floor(this.y + this.dy + this.dx);
            var slopedCeiling = this.layer.getBottomSolidPixel(pixelX2 + solidWidth, proposedPixelY, proposedPixelX2 - pixelX2, maxSlopeProposedY - proposedPixelY, this.solidity);
            if (slopedCeiling != MapLayer.noSolid)
            {
               slopedCeiling++;
               var floor = this.layer.getTopSolidPixel(pixelX2, proposedPixelY + solidHeight, solidWidth, slopedCeiling - proposedPixelY, this.solidity);
               if ((floor == MapLayer.noSolid) &amp;&amp; (this.ridingOn == null))
               {
                  var rightwall2 = this.layer.getLeftSolidPixel(pixelX2 + solidWidth, slopedCeiling, proposedPixelX2 - pixelX2, solidHeight, this.solidity);
                  if (rightwall2 == MapLayer.noSolid)
                     this.dy = dyOrig = slopedCeiling - this.y;
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            else
               hitWall = true;
         }
         if (hitWall)
         {
            this.dx = rightwall - solidWidth - this.x;
         }
         hit = true;
      }
   }
   else if (this.dx &lt; 0)
   {
      var leftwall = this.layer.getRightSolidPixel(proposedPixelX, proposedPixelY, pixelX - proposedPixelX, solidHeight, this.solidity);
      var hitWall = false;
      if (leftwall != MapLayer.noSolid)
      {
         var maxSlopeProposedY = Math.floor(this.y + this.dy + this.dx);
         var slopedFloor = this.layer.getTopSolidPixel(proposedPixelX, maxSlopeProposedY + solidHeight, pixelX - proposedPixelX, proposedPixelY - maxSlopeProposedY, this.solidity);
         if (slopedFloor != MapLayer.noSolid)
         {
            var ceiling = this.layer.getBottomSolidPixel(pixelX, slopedFloor - solidHeight, solidWidth, proposedPixelY + solidHeight - slopedFloor, this.solidity);
            if ((ceiling == MapLayer.noSolid) &amp;&amp; (this.ridingOn == null))
            {
               var leftwall2 = this.layer.getRightSolidPixel(proposedPixelX, slopedFloor - solidHeight, pixelX - proposedPixelX, solidHeight, this.solidity);
               if (leftwall2 == MapLayer.noSolid)
                  this.dy = dyOrig = slopedFloor - solidHeight - 1 - this.y;
               else
                  hitWall = true;
            }
            else
               hitWall = true;
         }
         else
         {
            maxSlopeProposedY = Math.floor(this.y + this.dy - this.dx);
            var slopedCeiling = this.layer.getBottomSolidPixel(proposedPixelX, proposedPixelY, pixelX - proposedPixelX, maxSlopeProposedY - proposedPixelY, this.solidity);
            if (slopedCeiling != MapLayer.noSolid)
            {
               slopedCeiling++;
               var floor = this.layer.getTopSolidPixel(pixelX, proposedPixelY + solidHeight, solidWidth, slopedCeiling - proposedPixelY, this.solidity);
               if ((floor == MapLayer.noSolid) &amp;&amp; (this.ridingOn == null))
               {
                  var leftwall2 = this.layer.getRightSolidPixel(proposedPixelX, slopedCeiling, pixelX - proposedPixelX, solidHeight, this.solidity);
                  if (leftwall2 == MapLayer.noSolid)
                     this.dy = dyOrig = slopedCeiling - this.y;
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            else
               hitWall = true;
         }
         if (hitWall)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            this.dx = leftwall + 1 - this.x;
         }
         hit = true;
      }
   }

   this.dy = dyOrig;
   proposedPixelX = Math.floor(this.x + this.dx);
   proposedPixelY = Math.floor(this.y + this.dy);
   var proposedSolidPixelWidth = solidWidth + Math.ceil(this.x + this.dx) - proposedPixelX;
   if (this.dy &gt; 0)
   {
      proposedPixelY2 = Math.ceil(this.y + this.dy);
      var ground = this.layer.getTopSolidPixel(proposedPixelX, pixelY + solidHeight, proposedSolidPixelWidth, proposedPixelY2 - pixelY, this.solidity);
      if (ground != MapLayer.noSolid)
      {
         this.dy = ground - solidHeight - this.y;
         hit = true;
      }
   }
   else if (this.dy &lt; 0)
   {
      var ceiling = this.layer.getBottomSolidPixel(proposedPixelX, proposedPixelY, proposedSolidPixelWidth, pixelY - proposedPixelY, this.solidity);
      if (ceiling != MapLayer.noSolid)
      {
         this.dy = ceiling + 1 - this.y;
         hit = true;
      }
   }

   if (hit &amp;&amp; (this.localDX != null))
      this.localDX += this.dx - dxOrig;

   return hit;
};

Sprite.inputBits = { up:1, right:2, down:4, left:8, button1:16, button2:32, button3:64, button4:128 };
Sprite.prototype.mapPlayerToInputs = function(playerNum) {
   var p = players[playerNum - 1];
   this.oldInputs = this.inputs;
   this.inputs = 0;
   if (GeneralRules.playerPressButton(playerNum)) {
      if (p.up()) this.inputs |= Sprite.inputBits.up;
      if (p.left()) this.inputs |= Sprite.inputBits.left;
      if (p.right()) this.inputs |= Sprite.inputBits.right;
      if (p.down()) this.inputs |= Sprite.inputBits.down;
      if (p.button1()) this.inputs |= Sprite.inputBits.button1;
      if (p.button2()) this.inputs |= Sprite.inputBits.button2;
      if (p.button3()) this.inputs |= Sprite.inputBits.button3;
      if (p.button4()) this.inputs |= Sprite.inputBits.button4;
   }
};

Sprite.prototype.accelerateByInputs = function(acceleration, max, horizontalOnly) {
   if (!horizontalOnly) {
      if (0 != (this.inputs &amp; Sprite.inputBits.up))
         this.dy -= acceleration / 10;
      if (this.dy &lt; -max)
         this.dy = -max;
      if (0 != (this.inputs &amp; Sprite.inputBits.down))
         this.dy += acceleration / 10;
      if (this.dy &gt; max)
         this.dy = max;
   }
   if (this.localDX == null) {
      if (0 != (this.inputs &amp; Sprite.inputBits.left))
         this.dx -= acceleration / 10;
      if (this.dx &lt; -max)
         this.dx = -max;
      if (0 != (this.inputs &amp; Sprite.inputBits.right))
         this.dx += acceleration / 10;
      if (this.dx &gt; max)
         this.dx = max;
   } else {
      if (0 != (this.inputs &amp; Sprite.inputBits.left))
         this.localDX -= acceleration / 10;
      if (this.localDX &lt; -max)
         this.localDX = -max;
      if (0 != (this.inputs &amp; Sprite.inputBits.right))
         this.localDX += acceleration / 10;
      if (this.localDX &gt; max)
         this.localDX = max;
   }
};

Sprite.prototype.isInState = function(firstState, lastState) {
   return (this.state &gt;= firstState) &amp;&amp; (this.state &lt;= lastState);
};

Sprite.prototype.moveByVelocity = function() {
   this.oldX = this.x;
   this.oldY = this.y;
   this.x += this.dx;
   this.y += this.dy;
};

Sprite.prototype.scrollSpriteIntoView = function(useScrollMargins) {
   this.layer.scrollSpriteIntoView(this, useScrollMargins);
};

Sprite.prototype.limitVelocity = function(maximum) {
   var useDX;
   if (this.localDX == null)
      useDX = this.dx;
   else
      useDX = this.localDX;
   var dist = useDX * useDX + this.dy * this.dy;
   if (dist &gt; maximum * maximum) {
      dist = Math.sqrt(dist);
      useDX = useDX * maximum / dist;
      this.dy = this.dy * maximum / dist;
      if (this.localDX == null)
         this.dx = useDX;
      else
         this.localDX = useDX;
   }
}

Sprite.prototype.isOnTile = function(category, relativePosition) {
   var rp = this.getRelativePosition(relativePosition);
   var tile = this.layer.getTile(Math.floor(rp.x / this.layer.tileset.tileWidth), Math.floor(rp.y / this.layer.tileset.tileHeight));
   return category.isTileMember(this.layer.tileset, tile);
}

Sprite.prototype.getRelativePosition = function(relativePosition) {
   var rp = {x:Math.floor(this.x),y:Math.floor(this.y)};

   switch (relativePosition) {
      case "TopCenter":
         rp.x = Math.floor(this.x + this.getSolidWidth() / 2);
         break;
      case "TopRight":
         rp.x = Math.floor(this.x) + this.getSolidWidth() - 1;
         break;
      case "LeftMiddle":
         rp.y = Math.floor(this.y + this.getSolidHeight() / 2);
         break;
      case "CenterMiddle":
         rp.x = Math.floor(this.x + this.getSolidWidth() / 2);
         rp.y = Math.floor(this.y + this.getSolidHeight() / 2);
         break;
      case "RightMiddle":
         rp.x = Math.floor(this.x) + this.getSolidWidth() - 1;
         rp.y = Math.floor(this.y + this.getSolidHeight() / 2);
         break;
      case "BottomLeft":
         rp.y = Math.floor(this.y + this.getSolidHeight() - 1);
         break;
      case "BottomCenter":
         rp.x = Math.floor(this.x + this.getSolidWidth() / 2);
         rp.y = Math.floor(this.y + this.getSolidHeight() - 1);
         break;
      case "BottomRight":
         rp.x = Math.floor(this.x) + this.getSolidWidth() - 1;
         rp.y = Math.floor(this.y + this.getSolidHeight() - 1);
         break;
   }
   return rp;
}

Sprite.prototype.blocked = function(direction) {
   var solidPixelWidth;
   var solidPixelHeight;
   switch (direction)
   {
      case "Up":
         solidPixelWidth = this.getSolidWidth() + Math.ceil(this.x) - Math.floor(this.x);
         return this.layer.getBottomSolidPixel(Math.floor(this.x), Math.floor(this.y) - 1, solidPixelWidth, 1, this.solidity) != MapLayer.noSolid;
      case "Right":
         solidPixelHeight = this.getSolidHeight() + Math.ceil(this.y) - Math.floor(this.y);
         return this.layer.getLeftSolidPixel(Math.floor(this.x) + this.getSolidWidth(), Math.floor(this.y), 1, solidPixelHeight, this.solidity) != MapLayer.noSolid;
      case "Down":
         solidPixelWidth = this.getSolidWidth() + Math.ceil(this.x) - Math.floor(this.x);
         return this.layer.getTopSolidPixel(Math.floor(this.x), Math.floor(this.y) + this.getSolidHeight(), solidPixelWidth, 1, this.solidity) != MapLayer.noSolid;
      case "Left":
         solidPixelHeight = this.getSolidHeight() + Math.ceil(this.y) - Math.floor(this.y);
         return this.layer.getRightSolidPixel(Math.floor(this.x) - 1, Math.floor(this.y), 1, solidPixelHeight, this.solidity) != MapLayer.noSolid;
   }
   return false;
}

Sprite.prototype.isMoving = function(direction) {
   var useDX;
   if (this.localDX == null)
      useDX = this.dx;
   else
      useDX = this.localDX;

   switch (direction) {
      case "Left":
         return useDX &lt; 0;
      case "Right":
         return useDX &gt; 0;
      case "Up":
         return this.dy &lt; 0;
      case "Down":
         return this.dy &gt; 0;
   }
   return false;
}

Sprite.prototype.isInputPressed = function(input, initialOnly) {
   return (this.inputs &amp; input) &amp;&amp;
      (!initialOnly || (0 == (this.oldInputs &amp; input)));
}

Sprite.prototype.alterXVelocity = function(delta) {
   this.dx += delta;
}

Sprite.prototype.alterYVelocity = function(delta) {
   this.dy += delta;
}

Sprite.prototype.reactToInertia = function(retainPercentVertical, retainPercentHorizontal) {
   if (this.localDX == null) {
      if (Math.abs(this.dx) &lt; .01)
         this.dx = 0;
      else
         this.dx *= retainPercentHorizontal / 100.0;
   } else {
      if (Math.abs(this.localDX) &lt; .01)
         this.localDX = 0;
      else
         this.localDX *= retainPercentHorizontal / 100.0;
   }
   if (Math.abs(this.dy) &lt; .01)
      this.dy = 0;
   else
      this.dy *= retainPercentVertical / 100.0;
}

Sprite.prototype.animate = function(correlation) {
   switch (correlation)
   {
      case "ByFrame":
         this.frame++;
         break;
      case "ByHorizontalVelocity":
         if (this.localDX == null)
            this.frame += Math.abs(Math.floor(this.x + this.dx) - Math.floor(this.x));
         else
            this.frame += Math.abs(Math.floor(this.localDX));
         break;
      case "ByVerticalVelocity":
         this.frame += Math.abs(Math.floor(this.y + this.dy) - Math.floor(this.y));
         break;
      case "ByVectorVelocity":
         var tmpDx = Math.abs(Math.floor(this.x + this.dx) - Math.floor(this.x));
         var tmpDy = Math.abs(Math.floor(this.y + this.dy) - Math.floor(this.y));
         this.frame += Math.floor(Math.sqrt(tmpDx * tmpDx + tmpDy * tmpDy));
         break;
   }
}

Sprite.prototype.isRidingPlatform = function() {
   return this.ridingOn != null;
}

Sprite.prototype.processRules = function() {
   if ((!this.processed) &amp;&amp; (this.isActive)) {
      this.processed = true;
      if (this.executeRules != null) this.executeRules();
   }
}

Sprite.prototype.reactToPlatform = function() {
   if (this.ridingOn == null)
      return;

   if (!this.ridingOn.processed)
      this.ridingOn.processRules();

   if ((this.ridingOn.isActive == false) || (this.x + this.getSolidWidth() &lt; this.ridingOn.oldX) || (this.x &gt; this.ridingOn.oldX + this.ridingOn.getSolidWidth()) ||
      (this.y + this.getSolidHeight() &lt; this.ridingOn.oldY - 1) || (this.y + this.getSolidHeight() &gt;= this.ridingOn.oldY + this.ridingOn.getSolidHeight()))
   {
      this.stopRiding();
      return;
   }

   if (this.localDX != null)
      this.dx = this.localDX + this.ridingOn.dx;
   this.dy = this.ridingOn.y - this.getSolidHeight() - this.y;
}

Sprite.prototype.landDownOnPlatform = function(platformList) {
   if (this.ridingOn != null)
      return false;
   for(var sprKey in platformList) {
      var spr = platformList[sprKey];
      if (!spr.isActive)
         continue;
      if ((this.oldY + this.getSolidHeight() &lt;= spr.oldY) &amp;&amp;
         (this.y + this.getSolidHeight() &gt; spr.y) &amp;&amp;
         (this.x + this.getSolidWidth() &gt; spr.x) &amp;&amp;
         (this.x &lt; spr.x + spr.getSolidWidth()))
      {
         this.ridingOn = spr;
         spr.processRules();
         this.localDX = this.dx - spr.dx;
         this.dy = spr.y - this.getSolidHeight() - this.y;
         return true;
      }
   }
   return false;
}

Sprite.prototype.snapToGround = function(threshhold) {
   var proposedPixelX = Math.floor(this.x + this.dx);
   var proposedPixelY = Math.floor(this.y + this.dy);
   var proposedSolidPixelWidth = this.getSolidWidth() + Math.ceil(this.x + this.dx) - proposedPixelX;
   var ground = this.layer.getTopSolidPixel(proposedPixelX, proposedPixelY + this.getSolidHeight(), proposedSolidPixelWidth, threshhold, this.solidity);
   if (ground != MapLayer.noSolid) {
      newDy = ground - this.getSolidHeight() - this.y;
      if (newDy &gt; this.dy)
         this.dy = newDy;
      return true;
   }
   return false;
}

Sprite.prototype.stopRiding = function() {
   this.localDX = null;
   this.ridingOn = null;
}

Sprite.prototype.switchToState = function(state, alignment) {
   var oldRect = {x:Math.floor(this.x), y:Math.floor(this.y), width:this.getSolidWidth(), height:this.getSolidHeight()};
   oldRect.bottom = oldRect.y + oldRect.height;
   oldRect.right = oldRect.x + oldRect.width;
   var newWidth = this.states[state].solidWidth;
   var newHeight = this.states[state].solidHeight;
   var newX, newY;
   switch (alignment) {
      case "TopCenter":
      case "CenterMiddle":
      case "BottomCenter":
         newX = this.x + (oldRect.width - newWidth) / 2;
         break;
      case "TopRight":
      case "RightMiddle":
      case "BottomRight":
         newX = this.x + oldRect.width - newWidth;
         break;
      default:
         newX = this.x;
         break;
   }
   switch (alignment) {
      case "LeftMiddle":
      case "CenterMiddle":
      case "RightMiddle":
         newY = this.y + (oldRect.height - newHeight) / 2;
         break;
      case "BottomLeft":
      case "BottomCenter":
      case "BottomRight":
         newY = this.y + oldRect.height - newHeight;
         break;
      default:
         newY = this.y;
         break;
   }

   if ((Math.ceil(newY + newHeight) &gt; oldRect.bottom) &amp;&amp; (this.layer.getTopSolidPixel(
      Math.floor(newX), oldRect.bottom, newWidth, Math.ceil(newY) + newHeight - oldRect.bottom, this.solidity) != MapLayer.noSolid))
      return false;

   if ((Math.floor(newY) &lt; oldRect.y) &amp;&amp; (this.layer.getBottomSolidPixel(
      Math.floor(newX), Math.floor(newY), newWidth, oldRect.y - Math.floor(newY), this.solidity) != MapLayer.noSolid))
      return false;

   if ((Math.floor(newX) &lt; oldRect.x) &amp;&amp; (this.layer.getRightSolidPixel(
      Math.floor(newX), Math.floor(newY), oldRect.x - Math.floor(newX), newHeight, this.solidity) != MapLayer.noSolid))
      return false;

   if ((Math.ceil(newX + newWidth) &gt; oldRect.right) &amp;&amp; (this.layer.getLeftSolidPixel(
      oldRect.right, Math.floor(newY), Math.ceil(newX) + newWidth - oldRect.right, newHeight, this.solidity) != MapLayer.noSolid))
      return false;

   this.x = newX;
   this.y = newY;
   this.state = state;
   return true;
}

Sprite.prototype.deactivate = function() {
   this.isActive = false;
}

Sprite.prototype.touchTiles = function(category) {
   if (this.touchedTiles != null)
      this.touchedTiles.length = 0;

   var tw = this.layer.tileset.tileWidth;
   var th = this.layer.tileset.tileHeight;
   var minYEdge = Math.floor(Math.floor(this.y) / th);
   var maxY = Math.floor((Math.floor(this.y) + this.getSolidHeight()) / th);
   if (maxY &gt;= this.layer.virtualRows)
      maxY = this.layer.virtualRows - 1;
   var maxYEdge = Math.floor((Math.floor(this.y) + this.getSolidHeight() - 1) / th);
   var minX = Math.floor(Math.floor(this.x - 1) / tw);
   var minXEdge = Math.floor(Math.floor(this.x) / tw);
   var maxX = Math.floor((Math.floor(this.x) + this.getSolidWidth()) / tw);
   if (maxX &gt;= this.layer.virtualColumns)
      maxX = this.layer.virtualColumns - 1;
   var maxXEdge = Math.floor((Math.floor(this.x) + this.getSolidWidth() - 1) / tw);
   for (var yidx = Math.floor((Math.floor(this.y) - 1) / th); yidx &lt;= maxY; yidx++) {
      var isYEdge = !((yidx &gt;= minYEdge) &amp;&amp; (yidx &lt;= maxYEdge));
      for (var xidx = (isYEdge ? minXEdge : minX);
         xidx &lt;= (isYEdge ? maxXEdge : maxX);
         xidx++)
      {
         if (category.isTileMember(this.layer.tileset, this.layer.getTile(xidx, yidx))) {
            var wasTouching;
            var oldPixelX = Math.floor(this.oldX);
            var oldPixelY = Math.floor(this.oldY);

            if ((oldPixelX &lt;= xidx * tw + tw) &amp;&amp;
               (oldPixelX + this.getSolidWidth() &gt;= xidx * tw) &amp;&amp;
               (oldPixelY &lt;= yidx * th + th) &amp;&amp;
               (oldPixelY + this.getSolidHeight() &gt;= yidx * th))
            {
               var edgeX = (oldPixelX + this.getSolidWidth() == xidx * tw) ||
                  (oldPixelX == xidx * tw + tw);
               var edgeY = (oldPixelY + this.getSolidHeight() == yidx * th) ||
                  (oldPixelY == yidx * th + th);
               if (edgeX &amp;&amp; edgeY)
                  wasTouching = false;
               else
                  wasTouching = true;
            }
            else
               wasTouching = false;
            
            if (this.touchedTiles == null)
               this.touchedTiles = [];
            this.touchedTiles.push({x:xidx, y:yidx, tileValue:this.layer.getTile(xidx, yidx), initial:!wasTouching, processed:false});
         }
      }
   }
   if (this.touchedTiles == null)
      return false;
   return this.touchedTiles.length &gt; 0;
};

Sprite.prototype.tileTake = function(tileValue, counter, newValue) {
   if (this.touchedTiles == null)
      return 0;

   var result = 0;

   for (var i = 0; i &lt; this.touchedTiles.length; i++) {
      var tt = this.touchedTiles[i];
      if ((tt.tileValue == tileValue) &amp;&amp; (!tt.processed)) {
         if (counter.value &lt; counter.max) {
            counter.value++;
            this.layer.setTile(tt.x, tt.y, tt.tileValue = newValue);
            tt.processed = true;
            result++;
         }
         else
            break;
      }
   }
   return result;
};

Sprite.prototype.tileAddSprite = function (touchingIndex, spriteDefinition) {
   var tt = this.touchedTiles[touchingIndex];
   var spriteParams = "{\"~1\":\"" + spriteDefinition + "\", \"x\":" +
   tt.x * this.layer.tileset.tileWidth + ",\"y\":" + tt.y * this.layer.tileset.tileHeight +
   ",\"dx\":0,\"dy\":0,\"state\":0,\"frame\":0,\"active\":true,\"priority\":0,\"solidityName\":\"" +
   solidity.getSolidityName(this.solidity) + "\"}";
   GeneralRules.lastCreatedSprite = Sprite.deserialize(this.layer, spriteParams);
   GeneralRules.lastCreatedSprite.isDynamic = true;
   GeneralRules.lastCreatedSprite.clearParameters();

   this.layer.sprites.push(GeneralRules.lastCreatedSprite);
   for(var categoryKey in spriteDefinitions[spriteDefinition].prototype.categories) {
      var category = spriteDefinitions[spriteDefinition].prototype.categories[categoryKey];
      if (this.layer.spriteCategories[category] == null)
         this.layer.spriteCategories[category] = [];
      this.layer.spriteCategories[category].push(GeneralRules.lastCreatedSprite);
   }
};

Sprite.prototype.tileActivateSprite = function(touchingIndex, category, clearParameters) {
   for (var i = 0; i &lt; category.length; i++) {
      if (!category[i].isActive) {
         category[i].isActive = true;
         var tt = this.touchedTiles[touchingIndex];
         category[i].x = tt.x * this.layer.tileset.tileWidth;
         category[i].y = tt.y * this.layer.tileset.tileHeight;
         if (clearParameters) {
            category[i].frame = 0;
            category[i].state = 0;
            category[i].clearParameters();
         }
         category[i].processRules();
         return i;
      }
   }
   return -1;
};

Sprite.prototype.clearParameters = function() {
   if (this.constructor.userParams == null) return;
   for(i in this.constructor.userParams) {
      this[this.constructor.userParams[i]] = 0;
   }
};

Sprite.prototype.setSolidity = function(solidity) {
   this.solidity = solidity;
};

Sprite.prototype.testCollisionRect = function(targets) {
   if (!this.isActive)
      return -1;
   if (targets == null)
      return -1;
   for(var idx = 0; idx &lt; targets.length; idx++) {
      var targetSprite = targets[idx];
      if ((targetSprite == this) || (!targetSprite.isActive))
         continue;
      var x1 = Math.floor(this.x);
      var w1 = this.getSolidWidth();
      var x2 = Math.floor(targetSprite.x);
      var w2 = targetSprite.getSolidWidth();
      var y1 = Math.floor(this.y);
      var h1 = this.getSolidHeight();
      var y2 = Math.floor(targetSprite.y);
      var h2 = targetSprite.getSolidHeight();

      if ((x1 + w1 &gt; x2) &amp;&amp; (x2 + w2 &gt; x1) &amp;&amp; (y1 + h1 &gt; y2) &amp;&amp; (y2 + h2 &gt; y1))
         return idx;
   }
   return -1;
};

Sprite.prototype.getNearestSpriteIndex = function(target) {
   var minDist = 999999999;
   var result = -1;
   if (target == null) return -1;
   for (var i = 0; i &lt; target.length; i++) {
      if ((!target[i].isActive) || (target[i] == this))
         continue;
      var xOff = target[i].x - this.x;
      var yOff = target[i].y - this.y;
      var dist = xOff * xOff + yOff * yOff;
      if (dist &lt; minDist) {
         minDist = dist;
         result = i;
      }
   }
   return result;
};

Sprite.prototype.pushTowardCategory = function(target, index, force) {
   if (index &lt; 0)
      index = this.getNearestSpriteIndex(target);
   if (index &lt; 0)
      return false;

   return this.pushTowardSprite(target[index], force);
};

Sprite.prototype.pushTowardSprite = function (target, force) {
   var vx = target.x - this.x + (target.getSolidWidth() - this.getSolidWidth()) / 2;
   var vy = target.y - this.y + (target.getSolidHeight() - this.getSolidHeight()) / 2;
   var dist = Math.sqrt(vx * vx + vy * vy);
   if (dist &gt;= 1) {
      this.dx += vx * force / dist / 10.0;
      this.dy += vy * force / dist / 10.0;
      return true;
   }
   return false;
};

Sprite.prototype.setInputState = function(input, press) {
   if (press)
      this.inputs |= input;
   else
      this.inputs &amp;= ~input;
};

Sprite.prototype.clearInputs = function(setOldInputs) {
   if (setOldInputs)
      this.oldInputs = this.inputs;
   this.inputs = 0;
};

Sprite.prototype.tileUseUp = function(tileValue, counter, newValue) {
   if (this.touchedTiles == null)
      return 0;

   var result = 0;

   for (var i = 0; i &lt; this.touchedTiles.length; i++) {
      var tt = this.touchedTiles[i];
      if ((tt.tileValue == tileValue) &amp;&amp; (!tt.processed)) {
         if (counter.value &gt; 0) {
            counter.value--;
            this.layer.setTile(tt.x, tt.y, tt.tileValue = newValue);
            tt.processed = true;
            result++;
         }
         else
            break;
      }
   }
   return result;
};

Sprite.prototype.addSpriteHere = function(spriteDefinition, location, hotSpot) {
   var spriteParams = "{\"~1\":\"" + spriteDefinition + "\", \"x\":0,\"y\":0" +
   ",\"dx\":0,\"dy\":0,\"state\":0,\"frame\":0,\"active\":true,\"priority\":0,\"solidityName\":\"" +
   solidity.getSolidityName(this.solidity) + "\"}";
   GeneralRules.lastCreatedSprite = Sprite.deserialize(this.layer, spriteParams);

   ptLocation = this.getRelativePosition(location);
   ptHotSpot = GeneralRules.lastCreatedSprite.getRelativePosition(hotSpot);
   GeneralRules.lastCreatedSprite.x = GeneralRules.lastCreatedSprite.oldX = ptLocation.x - ptHotSpot.x;
   GeneralRules.lastCreatedSprite.y = GeneralRules.lastCreatedSprite.oldY = ptLocation.y - ptHotSpot.y;

   GeneralRules.lastCreatedSprite.isDynamic = true;
   GeneralRules.lastCreatedSprite.clearParameters();

   this.layer.sprites.push(GeneralRules.lastCreatedSprite);
   for(var categoryKey in spriteDefinitions[spriteDefinition].prototype.categories) {
      var category = spriteDefinitions[spriteDefinition].prototype.categories[categoryKey];
      if (this.layer.spriteCategories[category] == null)
         this.layer.spriteCategories[category] = [];
      this.layer.spriteCategories[category].push(GeneralRules.lastCreatedSprite);
   }
};

Sprite.prototype.tileChange = function(oldTileValue, newTileValue, initialOnly) {
   if (this.touchedTiles == null)
      return 0;

   var result = 0;

   for (var i = 0; i &lt; this.touchedTiles.length; i++) {
      var tt = this.touchedTiles[i];
      if ((tt.tileValue == oldTileValue) &amp;&amp; (!tt.processed) &amp;&amp; (!initialOnly || tt.initial)) {
         tt.processed = true;
         this.layer.setTile(tt.x, tt.y, tt.tileValue = newTileValue);
         result++;
      }
   }
   return result;
};

Sprite.prototype.tileChangeTouched = function(touchingIndex, newTileValue) {
   if ((this.touchedTiles == null) || (this.touchedTiles.length &lt;= touchingIndex))
      return;

   var tt = this.touchedTiles[touchingIndex];
   tt.tileValue =  newTileValue;
   this.layer.setTile(tt.x, tt.y, tt.tileValue);
};

Sprite.prototype.tileTouchingIndex = function(tileValue, initialOnly, markAsProcessed) {
   if (this.touchedTiles == null)
      return -1;

   for (var i = 0; i &lt; this.touchedTiles.length; i++) {
      var tt = this.touchedTiles[i];
      if ((tt.tileValue == tileValue) &amp;&amp; (!tt.processed) &amp;&amp; (!initialOnly || tt.initial)) {
         tt.processed = markAsProcessed;
         return i;
      }
   }

   return -1;
};

Sprite.prototype.mapMouseToSprite = function(instantMove, hotSpot) {
   var pos = {x:mouseInfo.x - this.layer.currentX, y:mouseInfo.y - this.layer.currentY};
   var rp = this.getRelativePosition(hotSpot);
   if (instantMove) {
      this.oldX = this.x;
      this.oldY = this.y;
      this.x = pos.x + this.x - rp.x;
      this.y = pos.y + this.y - rp.y;
   } else {
      this.dx = pos.x - rp.x;
      this.dy = pos.y - rp.y;
   }
   this.oldinputs = this.inputs;
   this.inputs = 0;
   if (mouseInfo.pressed)
      this.inputs |= Sprite.inputBits.button1;
};

Sprite.prototype.setInputsTowardSprite = function(target) {
   var targetCenter = target.x + target.getSolidWidth() / 2;
   var myCenter = this.x + this.getSolidWidth() / 2;

   if (targetCenter &lt; myCenter)
      this.inputs |= Sprite.inputBits.left;
   else if (targetCenter &gt; myCenter)
      this.inputs |= Sprite.inputBits.right;
   else
      this.inputs &amp;= ~(Sprite.inputBits.left | Sprite.inputBits.right);

   targetCenter = target.y + target.getSolidHeight() / 2;
   myCenter = this.y + this.getSolidHeight() / 2;
   if (targetCenter &lt; myCenter)
      this.inputs |= Sprite.inputBits.up;
   else if (targetCenter &gt; myCenter)
      this.inputs |= Sprite.inputBits.down;
   else
      this.inputs &amp;= ~(Sprite.inputBits.up | Sprite.inputBits.down);
};

Sprite.prototype.setInputsTowardCategory = function(target, index) {
   if (index &lt; 0)
      index = this.getNearestSpriteIndex(target);
   if (index &lt; 0)
   {
      this.inputs &amp;= ~(Sprite.inputBits.left | Sprite.inputBits.right | Sprite.inputBits.up | Sprite.inputBits.down);
      return;
   }

   this.setInputsTowardSprite(target[index]);
};
</Text>
  </SourceCode>
  <SourceCode Name="Tile.js" IsCustomObject="false">
    <Text>function TileShape()
{
}

TileShape.maxValue = 32767;
TileShape.minValue = -32768;

TileShape.empty = new TileShape();
TileShape.empty.getTopSolidPixel = function(width, height, min, max) { return TileShape.maxValue; };
TileShape.empty.getLeftSolidPixel = function(width, height, min, max) { return TileShape.maxValue; };
TileShape.empty.getRightSolidPixel = function(width, height, min, max) { return TileShape.minValue; };
TileShape.empty.getBottomSolidPixel = function(width, height, min, max) { return TileShape.minValue; };

TileShape.solid = new TileShape();
TileShape.prototype.getTopSolidPixel = function(width, height, min, max) { return 0; };
TileShape.prototype.getLeftSolidPixel = function(width, height, min, max) { return 0; };
TileShape.prototype.getRightSolidPixel = function(width, height, min, max) { return width - 1; };
TileShape.prototype.getBottomSolidPixel = function(width, height, min, max) { return height - 1; };

TileShape.uphill = new TileShape();
TileShape.uphill.getTopSolidPixel = function(width, height, min, max) { return Math.floor(height * (width-max-1) / width); };
TileShape.uphill.getLeftSolidPixel = function(width, height, min, max) { return Math.floor(width * (height-max-1) / height); };

TileShape.downhill = new TileShape();
TileShape.downhill.getTopSolidPixel = function(width, height, min, max) { return Math.floor(min * height / width); };
TileShape.downhill.getRightSolidPixel = function(width, height, min, max) { return Math.floor(width - (height - max - 1) * width / height - 1); };

TileShape.upCeiling = new TileShape();
TileShape.upCeiling.getRightSolidPixel = function(width, height, min, max) { return Math.floor(((height - min) * width - 1) / height); };
TileShape.upCeiling.getBottomSolidPixel = function(width, height, min, max) { return Math.floor(((width - min) * height - 1) / width); };

TileShape.downCeiling = new TileShape();
TileShape.downCeiling.getLeftSolidPixel = function(width, height, min, max) { return Math.floor(min * width / height); };
TileShape.downCeiling.getBottomSolidPixel = function(width, height, min, max) { return Math.floor(height - (width - max - 1) * height / width - 1); };

TileShape.uphillRight = new TileShape();
TileShape.uphillRight.getTopSolidPixel = function(width, height, min, max) { return Math.floor(height * (width - max - 1) / width / 2); };
TileShape.uphillRight.getLeftSolidPixel = function(width, height, min, max) { return Math.floor((max * 2 &gt;= height - 2) ? 0 : width * (height - max * 2 - 2) / height); };

TileShape.uphillLeft = new TileShape();
TileShape.uphillLeft.getTopSolidPixel = function(width, height, min, max) { return Math.floor(height * (width - max - 1) / width / 2 + height / 2); };
TileShape.uphillLeft.getLeftSolidPixel = function(width, height, min, max) { return Math.floor(((max + 1) * 2 &lt;= height)?TileShape.maxValue:width * (height - max - 1) * 2 / height); };
TileShape.uphillLeft.getRightSolidPixel = function(width, height, min, max) { return Math.floor(((max + 1) * 2 &lt;= height)?TileShape.minValue:width - 1); };

TileShape.downhillLeft = new TileShape();
TileShape.downhillLeft.getTopSolidPixel = function(width, height, min, max) { return Math.floor(min * height / width / 2); };
TileShape.downhillLeft.getRightSolidPixel = function(width, height, min, max) { return Math.floor(((max + 1) * 2 &gt; height) ? width - 1 : width * 2 - (height - max - 1) * width * 2 / height - 1); };

TileShape.downhillRight = new TileShape();
TileShape.downhillRight.getTopSolidPixel = function(width, height, min, max) { return Math.floor((height + min * height / width) / 2); };
TileShape.downhillRight.getLeftSolidPixel = function(width, height, min, max) { return Math.floor(((min + 1) * 2 &lt;= height) ? TileShape.maxValue : 0); };
TileShape.downhillRight.getRightSolidPixel = function(width, height, min, max) { return Math.floor(((max + 1) * 2 &lt;= height) ? TileShape.minValue : width - (height - max - 1) * 2 * width / height - 1); };

TileShape.topSolid = new TileShape();
TileShape.topSolid.getLeftSolidPixel = TileShape.empty.getLeftSolidPixel;
TileShape.topSolid.getRightSolidPixel = TileShape.empty.getRightSolidPixel;
TileShape.topSolid.getBottomSolidPixel = TileShape.empty.getBottomSolidPixel;

function TileCategory(tilesetMembership) {
   this.membership = new Object();
   for(var tsIndex = 0; tsIndex &lt; tilesetMembership.length; tsIndex++) {
      var tsMemberLookup = new Array();
      var tsMemberList = tilesetMembership[tsIndex].membership;
      this.membership[tilesetMembership[tsIndex].tileset.name] = tsMemberLookup;
      for(var tileIndex = 0; tileIndex &lt; tsMemberList.length; tileIndex++) {
         if (typeof tsMemberList[tileIndex] == 'number')
            tsMemberLookup[tsMemberList[tileIndex]] = true;
         else
            tsMemberLookup[tsMemberList[tileIndex].tileIndex] = tsMemberList[tileIndex].frames;
      }
   }
}

TileCategory.prototype.isTileMember = function(tileset, tileIndex) {
   var membership = this.membership[tileset.name];
   if (membership == null)
      return false;
   var member = membership[tileIndex];
   if (member == true) return true;
   if (member == null) return false;
   return member.indexOf(tileset.tiles[tileIndex].getCurFrameIndex()) &gt; -1;
};

function Solidity(mapping) {
   this.mapping = mapping;
};

Solidity.prototype.getCurrentTileShape = function(tileset, tileIndex) {
   for(var i = 0; i &lt; this.mapping.length; i++) {
      if (this.mapping[i].tileCategory.isTileMember(tileset, tileIndex))
         return this.mapping[i].tileShape;
   }
   return TileShape.empty;
};
</Text>
  </SourceCode>
  <SourceCode Name="Map.js" IsCustomObject="false">
    <Text>function Map(scrollWidth, scrollHeight, scrollMarginLeft, scrollMarginTop, scrollMarginRight, scrollMarginBottom) {
   this.scrollX = 0;
   this.scrollY = 0;
   this.scrollWidth = scrollWidth;
   this.scrollHeight = scrollHeight;
   this.scrollMarginLeft = scrollMarginLeft;
   this.scrollMarginTop = scrollMarginTop;
   this.scrollMarginRight = scrollMarginRight;
   this.scrollMarginBottom = scrollMarginBottom;
   this.layers = {};
}

function getMapName(map) {
   for(var key in maps) {
      if (maps[key] === map)
         return key;
   }
   return null;
}

Map.prototype.scroll = function(x, y) {
   if(x &lt; viewWidth - this.scrollWidth) x = viewWidth - this.scrollWidth;
   if(x &gt; 0) x = 0;
   if(y &lt; viewHeight - this.scrollHeight) y = viewHeight - this.scrollHeight;
   if(y &gt; 0) y = 0;
   this.scrollX = x;
   this.scrollY = y;
   for(var key in this.layers) {
      this.layers[key].currentX = this.layers[key].offsetX + Math.floor(x * this.layers[key].scrollRateX);
      this.layers[key].currentY = this.layers[key].offsetY + Math.floor(y * this.layers[key].scrollRateY);
   }
};

Map.prototype.draw = function(ctx) {
   for(var key in this.layers)
      this.layers[key].draw(ctx);
};

Map.prototype.getState = function() {
   var result = {layers:{},cameFromMapName:this.cameFromMapName,mapFlags:this.mapFlags};
   for(var key in this.layers)
      result.layers[key] = this.layers[key].getState();
   return result;
};

Map.prototype.setState = function(data) {
   for(var key in this.layers)
      this.layers[key].setState(data.layers[key]);
   // These are probably correct, but the C# implementation doesn't do this
   // this.cameFromMapName = data.cameFromMapName;
   // this.mapFlags = data.mapFlags;
};

Map.prototype.executeRules = function() {
   for(var key in this.layers)
      this.layers[key].executeRules();
};</Text>
  </SourceCode>
  <SourceCode Name="MapLayer.js" IsCustomObject="false">
    <Text>function decodeData1(data) {
   var result = new Array();
   for(var i = 0; i &lt; data.length; i++) {
      result[i] = dataDigits.indexOf(data[i]);
   }
   return result;
}

function decodeData2(data) {
   var result = new Array();
   for(var i = 0; i &lt; data.length/2; i++) {
      result[i] = dataDigits.indexOf(data[i*2]) * dataDigits.length + dataDigits.indexOf(data[i*2+1]);
   }
   return result;
}

function MapLayer(map, tileset, columns, rows, virtualColumns, virtualRows, offsetX, offsetY, scrollRateX, scrollRateY, priority, tileData) {
   this.map = map;
   this.tileset = tileset;
   this.columns = columns;
   this.rows = rows;
   this.offsetX = offsetX;
   this.offsetY = offsetY;
   this.currentX = offsetX;
   this.currentY = offsetY;
   this.scrollRateX = scrollRateX;
   this.scrollRateY = scrollRateY;
   this.priority = priority;
   if (tileData != null)
   {
      if(tileData.length &lt; columns * rows * 2)
         this.tiles = decodeData1(tileData);
      else
         this.tiles = decodeData2(tileData);
   } else {
      this.tiles = [];
   }
   this.virtualColumns = virtualColumns ? virtualColumns : columns;
   this.virtualRows = virtualRows ? virtualRows : rows;
   this.sprites = [];
}

MapLayer.prototype.encodeTileData2 = function() {
   var result = '';
   for(var i = 0; i &lt; this.tiles.length; i++) {
      result += dataDigits[Math.floor(this.tiles[i] / dataDigits.length)] + dataDigits[this.tiles[i] % dataDigits.length];
   }
   return result;
};

MapLayer.prototype.getState = function() {
   var result = {currentX:this.currentX,currentY:this.currentY,tiles:this.encodeTileData2()};
   var staticSpriteIndices = [];
   for(var key in this)
   {
      if(this[key] instanceof Sprite)
      {
         result["~1" + key] = this[key].serialize();
         var staticIndex = this.sprites.indexOf(this[key]);
         if (staticIndex &gt;= 0)
            staticSpriteIndices[staticIndex] = true;
      }
   }
   var dynamicSprites = [];
   for(spriteIndex = 0; spriteIndex &lt; this.sprites.length; spriteIndex++)
   {
      if (staticSpriteIndices[spriteIndex] !== true)
      {
         dynamicSprites.push("\"" + this.sprites[spriteIndex].serialize().replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"");
      }
   }
   result.dynamicSprites = "[" + dynamicSprites.join(",") + "]";
   return result;
};

MapLayer.prototype.setState = function(source) {
   this.tiles = decodeData2(source.tiles);
   this.sprites.length = 0;
   for(var key in source) {
      if (key.substr(0,2) == "~1") {
         var s = Sprite.deserialize(this,source[key]);
         this[key.substr(2)] = s;
         this.sprites.push(s);
      }
   }
   if (source["dynamicSprites"] != null) {
      var dynamicSprites = JSON.parse(source["dynamicSprites"]);
      for(s in dynamicSprites) {
         this.sprites.push(Sprite.deserialize(this,dynamicSprites[s]));
      }
   }
   this.spriteCategories = Sprite.categorize(this.sprites);
   this.currentX = source.currentX;
   this.currentY = source.currentY;
};

MapLayer.prototype.getTile = function(x, y) {
   return this.tiles[(y % this.rows) * this.columns + (x % this.columns)];
};

MapLayer.prototype.setTile = function(x, y, value) {
   this.tiles[(y % this.rows) * this.columns + (x % this.columns)] = value;
}

MapLayer.prototype.draw = function(ctx) {
   var tileWidth = this.tileset.tileWidth;
   var tileHeight = this.tileset.tileHeight;
   var lastRow = Math.floor((viewHeight - this.currentY - 1) / tileHeight);
   if (lastRow &gt;= this.virtualRows) lastRow = this.virtualRows - 1;
   var lastCol = Math.floor((viewWidth - this.currentX - 1) / tileWidth);
   if (lastCol &gt;= this.virtualColumns) lastCol = this.virtualColumns - 1;
   for(y = Math.floor(-this.currentY / tileHeight), y = y &lt; 0 ? 0 : y; y &lt;= lastRow; y++) {
      for(x = Math.floor(-this.currentX / tileWidth), x = x &lt; 0 ? 0 : x; x &lt;= lastCol; x++) {
         var tile = this.tileset.tiles[this.getTile(x, y)];
         if (tile == null) continue;
         var drx = x * tileWidth + this.currentX;
         var dry = y * tileHeight + this.currentY;
         if (typeof tile == 'number')
            this.tileset.frameSet.frames[tile % this.tileset.frameSet.frames.length].draw(ctx, drx, dry);
         else {
            var frames;
            if (tile instanceof AnimTile)
               frames = tile.getCurFrames();
            else
               frames = tile;
            if (typeof frames == 'number')
               this.tileset.frameSet.frames[frames % this.tileset.frameSet.frames.length].draw(ctx, drx, dry);
            else
               for(var fi = 0; fi &lt; frames.length; fi++)
                  this.tileset.frameSet.frames[frames[fi] % this.tileset.frameSet.frames.length].draw(ctx, drx, dry);
         }
      }
   }
   for(si = 0; si &lt; this.sprites.length; si++) {
      var curSprite = this.sprites[si];
      if (!curSprite.isActive) continue;
      var frames = curSprite.getCurFrames();
      if (frames == null) continue;
      var frameSet = frameSets[curSprite.states[curSprite.state].frameSetName];
      if (typeof frames == 'number')
         frameSet.frames[frames % frameSet.frames.length].draw(ctx, curSprite.x + this.currentX, curSprite.y + this.currentY);
      else
         for(var fi = 0; fi &lt; frames.length; fi++)
            frameSet.frames[frames[fi] % frameSet.frames.length].draw(ctx, curSprite.x + this.currentX, curSprite.y + this.currentY);
   }
};

MapLayer.noSolid = -2000000000;

MapLayer.prototype.getTopSolidPixel = function(areaX, areaY, areaWidth, areaHeight, solidity) {
   var topTile = Math.floor(areaY / this.tileset.tileHeight);
   var bottomTile = Math.floor((areaY + areaHeight - 1) / this.tileset.tileHeight);
   var leftTile = Math.floor(areaX / this.tileset.tileWidth);
   var rightTile = Math.floor((areaX + areaWidth - 1) / this.tileset.tileWidth);
   var outOfBounds = false;
   if ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= this.virtualRows)
      || (leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= this.virtualColumns))
      outOfBounds = true;
   var minTileTop = (areaY+this.tileset.tileHeight) % this.tileset.tileHeight;
   var tileLeft = leftTile * this.tileset.tileWidth;
   for (var y = topTile; y &lt;= bottomTile; y++) {
      if (rightTile == leftTile) {
         var topMost;
         if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
            topMost = 0;
         else
            topMost = solidity.getCurrentTileShape(this.tileset, this.getTile(leftTile,y)).getTopSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, areaX - tileLeft,
               areaX + areaWidth - 1 - tileLeft);
         if ((topMost != TileShape.maxValue) &amp;&amp; ((y &gt; topTile) || (topMost &gt;= minTileTop))) {
            var result = topMost + y * this.tileset.tileHeight;
            if (result &lt; areaY + areaHeight)
               return result;
            else
               return MapLayer.noSolid;
         }
      } else {
         var topMost;
         if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
            topMost = 0;
         else
            topMost = solidity.getCurrentTileShape(this.tileset, this.getTile(leftTile, y)).getTopSolidPixel(
                this.tileset.tileWidth, this.tileset.tileHeight, areaX - tileLeft, this.tileset.tileWidth - 1);
         if ((y == topTile) &amp;&amp; (topMost &lt; minTileTop))
            topMost = TileShape.maxValue;
         var top;
         for (var x = leftTile + 1; x &lt; rightTile; x++) {
            if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
               top = 0;
            else
               top = solidity.getCurrentTileShape(this.tileset, this.getTile(x,y)).getTopSolidPixel(
                  this.tileset.tileWidth, this.tileset.tileHeight, 0, this.tileset.tileWidth - 1);
            if ((top &lt; topMost) &amp;&amp; ((y &gt; topTile) || (top &gt;= minTileTop)))
               topMost = top;
         }
         if (outOfBounds &amp;&amp; ((rightTile &lt; 0) || (rightTile &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
            top = 0;
         else
            top = solidity.getCurrentTileShape(this.tileset, this.getTile(rightTile,y)).getTopSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, 0, (areaX + areaWidth - 1) % this.tileset.tileWidth);
         if ((top &lt; topMost) &amp;&amp; ((y &gt; topTile) || (top &gt;= minTileTop)))
            topMost = top;
         if (topMost != TileShape.maxValue) {
            var result = topMost + y * this.tileset.tileHeight;
            if (result &lt; areaY + areaHeight)
               return result;
            else
               return MapLayer.noSolid;
         }
      }
   }
   return MapLayer.noSolid;
};

MapLayer.prototype.getBottomSolidPixel = function(areaX, areaY, areaWidth, areaHeight, solidity) {
   var topTile = Math.floor(areaY / this.tileset.tileHeight);
   var bottomTile = Math.floor((areaY + areaHeight - 1) / this.tileset.tileHeight);
   var leftTile = Math.floor(areaX / this.tileset.tileWidth);
   var rightTile = Math.floor((areaX + areaWidth - 1) / this.tileset.tileWidth);
   var outOfBounds = false;
   if ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= this.virtualRows)
      || (leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= this.virtualColumns))
      outOfBounds = true;
   var maxTileBottom = (areaY + areaHeight - 1 + this.tileset.tileHeight) % this.tileset.tileHeight;
   var tileLeft = leftTile * this.tileset.tileWidth;
   for (var y = bottomTile; y &gt;= topTile; y--) {
      if (rightTile == leftTile) {
         var bottomMost;
         if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
            bottomMost = this.tileset.tileHeight - 1;
         else
            bottomMost = solidity.getCurrentTileShape(this.tileset, this.getTile(leftTile,y)).getBottomSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, areaX - tileLeft,
               areaX + areaWidth - 1 - tileLeft);
         if ((bottomMost != TileShape.minValue) &amp;&amp; ((y &lt; bottomTile) || (bottomMost &lt;= maxTileBottom))) {
            var result = bottomMost + y * this.tileset.tileHeight;
            if (result &gt;= areaY)
               return result;
            else
               return MapLayer.noSolid;
         }
      } else {
         var bottomMost;
         if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
            bottomMost = this.tileset.tileHeight - 1;
         else
            bottomMost = solidity.getCurrentTileShape(this.tileset, this.getTile(leftTile, y)).getBottomSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, areaX - tileLeft, this.tileset.tileWidth - 1);
         if ((y == bottomTile) &amp;&amp; (bottomMost &gt; maxTileBottom))
            bottomMost = TileShape.minValue;
         var bottom;
         for (var x = leftTile + 1; x &lt; rightTile; x++) {
            if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
               bottom = this.tileset.tileHeight - 1;
            else
               bottom = solidity.getCurrentTileShape(this.tileset, this.getTile(x,y)).getBottomSolidPixel(
                  this.tileset.tileWidth, this.tileset.tileHeight, 0, this.tileset.tileWidth - 1);
            if ((bottom &gt; bottomMost) &amp;&amp; ((y &lt; bottomTile) || (bottom &lt;= maxTileBottom)))
               bottomMost = bottom;
         }
         if (outOfBounds &amp;&amp; ((rightTile &lt; 0) || (rightTile &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
            bottom = this.tileset.tileHeight - 1;
         else
            bottom = solidity.getCurrentTileShape(this.tileset, this.getTile(rightTile,y)).getBottomSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, 0, (areaX + areaWidth - 1) % this.tileset.tileWidth);
         if ((bottom &gt; bottomMost) &amp;&amp; ((y &lt; bottomTile) || (bottom &lt;= maxTileBottom)))
            bottomMost = bottom;
         if (bottomMost != TileShape.minValue) {
            var result = bottomMost + y * this.tileset.tileHeight;
            if (result &gt;= areaY)
               return result;
            else
               return MapLayer.noSolid;
         }
      }
   }
   return MapLayer.noSolid;
};

MapLayer.prototype.getLeftSolidPixel = function(areaX, areaY, areaWidth, areaHeight, solidity) {
   var topTile = Math.floor(areaY / this.tileset.tileHeight);
   var bottomTile = Math.floor((areaY + areaHeight - 1) / this.tileset.tileHeight);
   var leftTile = Math.floor(areaX / this.tileset.tileWidth);
   var rightTile = Math.floor((areaX + areaWidth - 1) / this.tileset.tileWidth);
   var outOfBounds = false;
   if ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= this.virtualRows)
      || (leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= this.virtualColumns))
      outOfBounds = true;
   var minTileLeft = (areaX + this.tileset.tileWidth) % this.tileset.tileWidth;
   var tileTop = topTile * this.tileset.tileHeight;
   for (var x = leftTile; x &lt;= rightTile; x++) {
      if (bottomTile == topTile){
         var leftMost;
         if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (x &lt; 0) || (x &gt;= this.virtualColumns)))
            leftMost = 0;
         else
            leftMost = solidity.getCurrentTileShape(this.tileset, this.getTile(x, topTile)).getLeftSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, areaY - tileTop,
               areaY + areaHeight - 1 - tileTop);
         if ((leftMost != TileShape.maxValue) &amp;&amp; ((x &gt; leftTile) || (leftMost &gt;= minTileLeft))) {
            var result = leftMost + x * this.tileset.tileWidth;
            if (result &lt; areaX + areaWidth)
               return result;
            else
               return MapLayer.noSolid;
         }
      } else {
         var leftMost;
         if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (x &lt; 0) || (x &gt;= this.virtualColumns)))
            leftMost = 0;
         else
            leftMost = solidity.getCurrentTileShape(this.tileset, this.getTile(x, topTile)).getLeftSolidPixel(
                this.tileset.tileWidth, this.tileset.tileHeight, areaY - tileTop, this.tileset.tileHeight - 1);
         if ((x == leftTile) &amp;&amp; (leftMost &lt; minTileLeft))
            leftMost = TileShape.maxValue;
         var left;
         for (var y = topTile + 1; y &lt; bottomTile; y++) {
            if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
               left = 0;
            else
               left = solidity.getCurrentTileShape(this.tileset, this.getTile(x,y)).getLeftSolidPixel(
                  this.tileset.tileWidth, this.tileset.tileHeight, 0, this.tileset.tileHeight - 1);
            if ((left &lt; leftMost) &amp;&amp; ((x &gt; leftTile) || (left &gt;= minTileLeft)))
               leftMost = left;
         }
         if (outOfBounds &amp;&amp; ((bottomTile &lt; 0) || (bottomTile &gt;= this.virtualRows) || (x &lt; 0) || (x &gt;= this.virtualColumns)))
            left = 0;
         else
            left = solidity.getCurrentTileShape(this.tileset, this.getTile(x, bottomTile)).getLeftSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, 0, (areaY + areaHeight - 1) % this.tileset.tileHeight);
         if ((left &lt; leftMost) &amp;&amp; ((x &gt; leftTile) || (left &gt;= minTileLeft)))
            leftMost = left;
         if (leftMost != TileShape.maxValue) {
            var result = leftMost + x * this.tileset.tileWidth;
            if (result &lt; areaX + areaWidth)
               return result;
            else
               return MapLayer.noSolid;
         }
      }
   }
   return MapLayer.noSolid;
};

MapLayer.prototype.getRightSolidPixel = function(areaX, areaY, areaWidth, areaHeight, solidity) {
   var topTile = Math.floor(areaY / this.tileset.tileHeight);
   var bottomTile = Math.floor((areaY + areaHeight - 1) / this.tileset.tileHeight);
   var leftTile = Math.floor(areaX / this.tileset.tileWidth);
   var rightTile = Math.floor((areaX + areaWidth - 1) / this.tileset.tileWidth);
   var outOfBounds = false;
   if ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= this.virtualRows)
      || (leftTile &lt; 0) || (leftTile &gt;= this.virtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= this.virtualColumns))
      outOfBounds = true;
   var maxTileRight = (areaX + areaWidth - 1 + this.tileset.tileWidth) % this.tileset.tileWidth;
   var tileTop = topTile * this.tileset.tileHeight;
   for (var x = rightTile; x &gt;= leftTile; x--) {
      if (bottomTile == topTile){
         var rightMost;
         if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (x &lt; 0) || (x &gt;= this.virtualColumns)))
            rightMost = this.tileset.tileWidth - 1;
         else
            rightMost = solidity.getCurrentTileShape(this.tileset, this.getTile(x, topTile)).getRightSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, areaY - tileTop,
               areaY + areaHeight - 1 - tileTop);
         if ((rightMost != TileShape.minValue) &amp;&amp; ((x &lt; rightTile) || (rightMost &lt;= maxTileRight))) {
            var result = rightMost + x * this.tileset.tileWidth;
            if (result &gt;= areaX)
               return result;
            else
               return MapLayer.noSolid;
         }
      } else {
         var rightMost;
         if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= this.virtualRows) || (x &lt; 0) || (x &gt;= this.virtualColumns)))
            rightMost = this.tileset.tileWidth - 1;
         else
            rightMost = solidity.getCurrentTileShape(this.tileset, this.getTile(x, topTile)).getRightSolidPixel(
                this.tileset.tileWidth, this.tileset.tileHeight, areaY - tileTop, this.tileset.tileHeight - 1);
         if ((x == rightTile) &amp;&amp; (rightMost &gt; maxTileRight))
            rightMost = TileShape.minValue;
         var right;
         for (var y = topTile + 1; y &lt; bottomTile; y++) {
            if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= this.virtualColumns) || (y &lt; 0) || (y &gt;= this.virtualRows)))
               right = this.tileset.tileWidth - 1;
            else
               right = solidity.getCurrentTileShape(this.tileset, this.getTile(x,y)).getRightSolidPixel(
                  this.tileset.tileWidth, this.tileset.tileHeight, 0, this.tileset.tileHeight - 1);
            if ((right &gt; rightMost) &amp;&amp; ((x &lt; rightTile) || (right &lt;= maxTileRight)))
               rightMost = right;
         }
         if (outOfBounds &amp;&amp; ((bottomTile &lt; 0) || (bottomTile &gt;= this.virtualRows) || (x &lt; 0) || (x &gt;= this.virtualColumns)))
            right = this.tileset.tileWidth - 1;
         else
            right = solidity.getCurrentTileShape(this.tileset, this.getTile(x, bottomTile)).getRightSolidPixel(
               this.tileset.tileWidth, this.tileset.tileHeight, 0, (areaY + areaHeight - 1) % this.tileset.tileHeight);
         if ((right &gt; rightMost) &amp;&amp; ((x &lt; rightTile) || (right &lt;= maxTileRight)))
            rightMost = right;
         if (rightMost != TileShape.minValue) {
            var result = rightMost + x * this.tileset.tileWidth;
            if (result &gt;= areaX)
               return result;
            else
               return MapLayer.noSolid;
         }
      }
   }
   return MapLayer.noSolid;
};

MapLayer.prototype.scrollSpriteIntoView = function(sprite, useScrollMargins)
{
   var newX = null;
   var newY = null;
   var marginLeft;
   var marginTop;
   var marginRight;
   var marginBottom;
   if (useScrollMargins)
   {
      marginLeft = this.map.scrollMarginLeft;
      marginTop = this.map.scrollMarginTop;
      marginRight = this.map.scrollMarginRight;
      marginBottom = this.map.scrollMarginBottom;
   }
   else
   {
      marginLeft = 0;
      marginTop = 0;
      marginRight = 0;
      marginBottom = 0;
   }
   if (sprite.x + this.currentX &lt; marginLeft)
   {
      if (this.scrollRateX &gt; 0)
         newX = Math.floor((-sprite.x + marginLeft - this.offsetX) / this.scrollRateX);
      else
         this.currentX = -sprite.x + marginLeft;
   }
   else if (sprite.x + sprite.getSolidWidth() - 1 + this.currentX &gt; viewWidth - marginRight)
   {
      if (this.scrollRateX &gt; 0)
         newX = Math.floor((-sprite.x - sprite.getSolidWidth() + 1 + viewWidth - marginRight - this.offsetX) / this.scrollRateX);
      else
         this.currentX = -sprite.x - sprite.getSolidWidth() + 1 + viewWidth - marginRight;
   }

   if (sprite.y + this.currentY &lt; marginTop)
   {
      if (this.scrollRateY &gt; 0)
         newY = Math.floor((-sprite.y + marginTop - this.offsetY) / this.scrollRateY);
      else
         this.currentY = -sprite.y + marginTop;
   }
   else if (sprite.y + sprite.getSolidHeight() - 1 + this.currentY &gt; viewHeight - marginBottom)
   {
      if (this.scrollRateY &gt; 0)
         newY = Math.floor((-sprite.y - sprite.getSolidHeight() + 1 + viewHeight - marginBottom - this.offsetY) / this.scrollRateY);
      else
         this.currentY = -sprite.Y - sprite.getSolidHeight() + 1 + viewHeight - marginBottom;
   }
   if ((newX != null) || (newY != null))
   {
      if (newX == null) newX = this.currentX;
      if (newY == null) newY = this.currentY;
      this.map.scroll(newX, newY);
   }
}

MapLayer.prototype.processSprites = function() {
   for(var si = 0; si &lt; this.sprites.length; si++)
      this.sprites[si].processed = false;
   for(var si = 0; si &lt; this.sprites.length; si++)
      if (this.sprites[si].isActive)
         this.sprites[si].processRules();
   for(var si = 0; si &lt; this.sprites.length; si++) {
      var sprite = this.sprites[si];
      if (sprite.isDynamic &amp;&amp; !sprite.isActive) {
         for(var categoryKey in sprite.categories) {
            for(var spriteKey in this.spriteCategories[categoryKey]) {
               if (this.spriteCategories[categoryKey][spriteKey] === sprite)
                  this.spriteCategories[categoryKey].splice(spriteKey, 1);
            }
         }
         this.sprites.splice(si, 1);
      }
   }   
}
</Text>
  </SourceCode>
  <SourceCode Name="Plan.js" IsCustomObject="false">
    <Text>function PlanBase() {
   this.targetDistance = 5;
}

PlanBase.prototype = new GeneralRules();
PlanBase.prototype.constructor = PlanBase;

PlanBase.prototype.isSpriteActive = function(sprite) {
   return sprite.isActive;
};

PlanBase.prototype.mapPlayerToInputs = function(playerNumber, target)
{
   target.mapPlayerToInputs(playerNumber);
};

PlanBase.prototype.followPath = function(sprite, coordinateIndexMember, waitCounterMember) {
   if (sprite.isActive) {
      if (sprite[waitCounterMember] == 0)
         this.pushSpriteTowardCoordinate(sprite, sprite[coordinateIndexMember], 10);
      else
         this.stopSprite(sprite);
      sprite[coordinateIndexMember] = this.checkNextCoordinate(sprite, sprite[coordinateIndexMember], waitCounterMember);
   }
};

PlanBase.prototype.pushSpriteTowardCoordinate = function(sprite, coordinateIndex, force) {
   this.pushSpriteTowardPoint(sprite, this[coordinateIndex], force);
};

PlanBase.prototype.pushSpriteTowardPoint = function(sprite, target, force) {
   var dx = target.x - sprite.x;
   var dy = target.y - sprite.y;

   // Normalize target vector to magnitude of Force parameter
   var dist = Math.sqrt(dx * dx + dy * dy);
   if (dist &gt; 0) {
      dx = dx * force / dist / 10;
      dy = dy * force / dist / 10;

      // Push sprite
      sprite.dx += dx;
      sprite.dy += dy;
   }
};

PlanBase.prototype.checkNextCoordinate = function(sprite, coordinateIndex, waitCounterMember) {
   if (sprite[waitCounterMember] &gt; 0)
   {
      if (++sprite[waitCounterMember] &gt; this[coordinateIndex].weight)
      {
         sprite[waitCounterMember] = 0;
         return (coordinateIndex + 1) % this.m_Coords.length;
      }
      else
         return coordinateIndex;
   }
   var dx = this[coordinateIndex].x - sprite.x;
   var dy = this[coordinateIndex].y - sprite.y;
   if (Math.sqrt(dx * dx + dy * dy) &lt;= this.targetDistance)
   {
      if (this[coordinateIndex].weight &gt; 0)
         sprite[waitCounterMember]++;
      else
         return (coordinateIndex + 1) % this.m_Coords.length;
   }
   return coordinateIndex;
};

PlanBase.prototype.isSpriteTouching = function(sprite) {
   if (!sprite.isActive)
      return false;

   if ((Math.floor(sprite.x) &lt;= this.left + this.width) &amp;&amp; (Math.floor(sprite.x) + sprite.getSolidWidth() &gt;= this.left) &amp;&amp;
      (Math.floor(sprite.y) &lt; this.top + this.height) &amp;&amp; (Math.floor(sprite.y) + sprite.getSolidHeight() &gt; this.top))
      return true;
   if ((Math.floor(sprite.x) &lt; this.left + this.width) &amp;&amp; (Math.floor(sprite.x) + sprite.getSolidWidth() &gt; this.left) &amp;&amp;
      (Math.floor(sprite.y) &lt;= this.top + this.height) &amp;&amp; (Math.floor(sprite.y) + sprite.getSolidHeight() &gt;= this.top))
      return true;
   return false;
};

PlanBase.prototype.wasSpriteTouching = function(sprite) {
   if ((Math.floor(sprite.oldX) &lt;= this.left + this.width) &amp;&amp; (Math.floor(sprite.oldX) + sprite.getSolidWidth() &gt;= this.left) &amp;&amp;
      (Math.floor(sprite.oldY) &lt; this.top + this.height) &amp;&amp; (Math.floor(sprite.oldY) + sprite.getSolidHeight() &gt; this.top))
      return true;
   if ((Math.floor(sprite.oldX) &lt; this.left + this.width) &amp;&amp; (Math.floor(sprite.oldX) + sprite.getSolidWidth() &gt; this.left) &amp;&amp;
      (Math.floor(sprite.oldY) &lt;= this.top + this.height) &amp;&amp; (Math.floor(sprite.oldY) + sprite.getSolidHeight() &gt;= this.top))
      return true;
   return false;
};

PlanBase.prototype.stopSprite = function(sprite) {
   sprite.dx = sprite.dy = 0;
};

PlanBase.prototype.isInputPressed = function(sprite, input, initialOnly)
{
   return sprite.isInputPressed(input, initialOnly);
};

PlanBase.prototype.drawCounterAsTile = function(tileIndex, counter, style) {
   if (this.left == null)
      return;
   if (counter.currentValue == 0)
      return;
   var map = this.layer.map;
   ts = this.layer.tileset;
   fr = ts.frameSet;
   var disp = gameViewContext;

   var frames = ts.tiles[tileIndex];
   if (typeof frames == "number") {
      frames = [frames];
   } else {
      if (frames instanceof AnimTile)
         frames = frames.getCurFrames();
      if (typeof frames == "number") {
         frames = [frames];
      }
   }

   switch(style)
   {
      case "ClipRightToCounter":
         disp.save();
         disp.beginPath();
         disp.rect(this.left + this.layer.currentX,
            this.top + this.layer.currentY,
            this.width * counter.value / counter.max,
            this.height);
         disp.clip();
         for(var frameIndex in frames)
            fr.frames[frameIndex % fr.frames.length].draw(disp, this.left, this.top);
         disp.restore();
         break;
      case "StretchRightToCounter":
         throw "Not Implemented";
         break;
      case "RepeatRightToCounter":
         for(var i in frames) {
            var frameIndex = frames[i];
            var fillWidth = this.width * counter.value / counter.max;
            for (var repeat = 0; repeat &lt; Math.ceil(fillWidth / ts.tileWidth); repeat++)
               fr.frames[frameIndex % fr.frames.length].draw(disp, this.left + repeat * ts.tileWidth, this.top);
         }
         break;
      case "ClipTopToCounter":
         throw "Not Implemented";
         break;
      case "StretchTopToCounter":
         throw "Not Implemented";
         break;
      case "RepeatUpToCounter":
         for(var i in frames) {
            var frameIndex = frames[i];
            var fillHeight = this.height * counter.value / counter.max;
            for (var repeat = 0; repeat &lt; Math.ceil(fillHeight / ts.tileHeight); repeat++)
               fr.frames[frameIndex % fr.frames.length].draw(disp, this.left + repeat * ts.tileWidth, this.top - repeat * ts.tileHeight - ts.tileHeight);
         }
         break;
   }
};

function drawText(text, x, y) {
   var charWidth = 13;
   var charHeight = 18;
   var font = graphicSheets.CoolFont;
   if (font == null)
      throw "In order to use DrawText, the project must have a Graphic Sheet named \"CoolFont\"";
   var origX = x;
   for (var charIdx = 0; charIdx &lt; text.length; charIdx++) {
      var curChar = text.charCodeAt(charIdx);
      if (curChar &gt; 32) {
         var col = (curChar - 33) % 24;
         var row = Math.floor((curChar - 33) / 24);
         gameViewContext.drawImage(font.image, col * font.cellWidth, row * font.cellHeight,
            font.cellWidth, font.cellHeight, x, y, font.cellWidth, font.cellHeight);
         x += charWidth;
      }
      else if (curChar == 10)
      {
         x = origX;
         y += charHeight;
      }
   }
}

PlanBase.prototype.drawCounterWithLabel = function(label, counter) {
   if (this.left == null)
      return;   
   drawText(label.toString() + counter.value.toString(), this.left, this.top);
};

PlanBase.prototype.isSpriteWithin = function(sprite, relativePosition) {
   var rp = sprite.getRelativePosition(relativePosition);
   return ((rp.x &gt;= this.left) &amp;&amp; (rp.y &gt;= this.top) &amp;&amp; (rp.x &lt; this.left + this.width) &amp;&amp; (rp.y &lt; this.top + this.height));
};

PlanBase.prototype.copyInputsToOld = function(sprite) {
   sprite.oldInputs = sprite.inputs;
};

PlanBase.prototype.transportToPlan = function(sprite, plan, alignment) {
   if (plan.left == null)
      return;

   switch(alignment) {
      case "TopLeft":
      case "TopCenter":
      case "TopRight":
         sprite.y = plan.top;
         break;
      case "LeftMiddle":
      case "CenterMiddle":
      case "RightMiddle":
         sprite.y = plan.top + Math.floor((plan.height - sprite.getSolidHeight())/2);
         break;
      default:
         sprite.y = plan.top + plan.height - sprite.getSolidHeight();
         break;
   }
   switch(alignment)
   {
      case "TopLeft":
      case "LeftMiddle":
      case "BottomLeft":
         sprite.x = plan.left;
         break;
      case "TopCenter":
      case "CenterMiddle":
      case "BottomCenter":
         sprite.x = plan.left + Math.floor((plan.width - sprite.getSolidWidth())/2);
         break;
      default:
         sprite.x = plan.left + plan.width - sprite.getSolidWidth();
         break;
   }
};

PlanBase.prototype.door = function(target, sprites, trigger) {
   var result = -1;
   for (var i=0; i&lt;sprites.length; i++) {
      if (sprites[i].isActive) {
         var outDoor;
         if (this.isSpriteWithin(sprites[i], "CenterMiddle"))
            outDoor = target;
         else if (target.isSpriteWithin(sprites[i], "CenterMiddle"))
            outDoor = this;
         else
            continue;
         if (((trigger &amp; sprites[i].inputs) == trigger) &amp;&amp;
            ((sprites[i].inputs &amp; trigger) != (sprites[i].oldInputs &amp; trigger)))
         {
            result = i;
            this.transportToPlan(sprites[i], outDoor, "BottomCenter");
         }
      }
   }
   return result;
};

PlanBase.prototype.activateSprite = function(target) {
   target.isActive = true;
};


PlanBase.prototype.copyTiles = function(source, target, relativePosition) {
   var src_left = Math.floor(source.left / source.layer.tileset.tileWidth);
   var src_top = Math.floor(source.top / source.layer.tileset.tileHeight);
   var src_right = Math.floor((source.left + source.width - 1) / source.layer.tileset.tileWidth);
   var src_bottom = Math.floor((source.top + source.height - 1) / source.layer.tileset.tileHeight);

   var dst_left = Math.floor(target.left / target.layer.tileset.tileWidth);
   var dst_top = Math.floor(target.top / target.layer.tileset.tileHeight);
   var dst_right = Math.floor((target.left + target.width - 1) / target.layer.tileset.tileWidth);
   var dst_bottom = Math.floor((target.top + target.height - 1) / target.layer.tileset.tileHeight);

   for (var y = src_top; y &lt;= src_bottom; y++) {
      var targety;
      switch(relativePosition) {
         case "TopLeft":
         case "TopCenter":
         case "TopRight":
            targety = dst_top + y - src_top;
            break;
         case "LeftMiddle":
         case "CenterMiddle":
         case "RightMiddle":
            targety = y + Math.floor((dst_top + dst_bottom - src_top - src_bottom) / 2);
            break;
         default:
            targety = dst_bottom + y - src_bottom;
            break;
      }
      if (targety &lt; 0)
         continue;
      if (targety &gt;= target.layer.virtualRows)
         break;
      for (var x = src_left; x &lt;= src_right; x++) {
         var targetx;
         switch(relativePosition) {
            case "TopLeft":
            case "LeftMiddle":
            case "BottomLeft":
               targetx = dst_left + x - src_left;
               break;
            case "TopCenter":
            case "CenterMiddle":
            case "BottomCenter":
               targetx = x + Math.floor((dst_left + dst_right - src_left - src_right) / 2);
               break;
            default:
               targetx = dst_right + x - src_right;
               break;
         }
         if (targetx &lt; 0)
            continue;
         if (targetx &gt;= target.layer.virtualColumns)
            break;
            
         target.layer.setTile(targetx,targety,source.layer.getTile(x,y));
      }
   }
};

PlanBase.prototype.copyTo = function(target, relativePosition) {
   this.copyTiles(this, target, relativePosition);
};

PlanBase.prototype.copyFrom = function(source, relativePosition) {
   this.copyTiles(source, this, relativePosition);
};

PlanBase.prototype.deactivateSprite = function(target) {
   target.isActive = false;
};

PlanBase.prototype.matchSpritePosition = function(target, source) {
   target.oldX = target.x;
   target.oldY = target.y;
   target.x = source.x;
   target.y = source.y;
};

PlanBase.prototype.isSpriteWithin = function(sprite, relativePosition) {
   var rp = sprite.getRelativePosition(relativePosition);
   if ((rp.x &gt;= this.left) &amp;&amp; (rp.y &gt;= this.top) &amp;&amp; (rp.x &lt; this.left + this.width) &amp;&amp; (rp.y &lt; this.top + this.height)) {
      return true;
   }
   return false;
};

PlanBase.prototype.scrollSpriteIntoView = function(sprite, useScrollMargins) {
   this.layer.scrollSpriteIntoView(sprite, useScrollMargins);
};

PlanBase.prototype.testCollisionRect = function(sourceSprite, targets) {
   sourceSprite.testCollisionRect(targets);
};

PlanBase.prototype.addSpriteAtPlan = function(spriteDefinition, relativePosition) {
   var spriteParams = "{\"~1\":\"" + spriteDefinition + "\", \"x\":0,\"y\":0" +
   ",\"dx\":0,\"dy\":0,\"state\":0,\"frame\":0,\"active\":true,\"priority\":0,\"solidityName\":\"\"}";
   
   GeneralRules.lastCreatedSprite = Sprite.deserialize(this.layer, spriteParams);

   if ((this.m_Coords != null) &amp;&amp; (this.m_Coords.length &gt; 0))
   {
      offset = lastCreatedSprite.getRelativePosition(relativePosition);
      GeneralRules.lastCreatedSprite.x = this[0].x - offset.x;
      GeneralRules.lastCreatedSprite.y = this[0].y - offset.y ;
   }

   this.layer.sprites.push(GeneralRules.lastCreatedSprite);
   for(var categoryKey in spriteDefinitions[spriteDefinition].prototype.categories) {
      var category = spriteDefinitions[spriteDefinition].prototype.categories[categoryKey];
      if (this.layer.spriteCategories[category] == null)
         this.layer.spriteCategories[category] = [];
      this.layer.spriteCategories[category].push(GeneralRules.lastCreatedSprite);
   }
}

PlanBase.prototype.mapMouseToSprite = function(target, instantMove, hotSpot) {
   target.mapMouseToSprite(instantMove, hotSpot);
}</Text>
  </SourceCode>
  <SourceCode Name="TileCustom.js" IsCustomObject="true" DependsOn="">
    <Text>// Begin TileCustom.js

TileShape.topSolidMid = new TileShape();
TileShape.topSolidMid.getTopSolidPixel = function(width, height, min, max) { return Math.floor(height /2); };
TileShape.topSolidMid.getLeftSolidPixel = TileShape.empty.getLeftSolidPixel;
TileShape.topSolidMid.getRightSolidPixel = TileShape.empty.getRightSolidPixel;
TileShape.topSolidMid.getBottomSolidPixel = TileShape.empty.getBottomSolidPixel;
</Text>
  </SourceCode>
  <SourceCode Name="Sounds.cs" IsCustomObject="true" DependsOn="">
    <Text>using System.ComponentModel;

public class Sounds
{
   [Description("Play a sound effect")]
   public static void Play(string Name)
   {
      switch(Name)
      {
         case "bing":
            CustomObjects.FMODBase.PlaySound(CustomObjects.Bing.Value, CustomObjects.SoundReplay.Restart);
            break;
         case "ahh":
            CustomObjects.FMODBase.PlaySound(CustomObjects.Ahh.Value, CustomObjects.SoundReplay.Restart);
            break;
         case "explode":
            CustomObjects.FMODBase.PlaySound(CustomObjects.Explode.Value, CustomObjects.SoundReplay.Restart);
            break;
         case "pickup":
            CustomObjects.FMODBase.PlaySound(CustomObjects.Pickup.Value, CustomObjects.SoundReplay.Restart);
            break;
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="Sound.js" IsCustomObject="true" DependsOn="Sounds.cs">
    <Text>// Begin Sound.js
sounds.initialize = function() {
   sounds.ahh = document.getElementById('soundAhh');
   sounds.bing = document.getElementById('soundBing');
   sounds.explode = document.getElementById('soundExplode');
   sounds.pickup = document.getElementById('soundPickup');
   sounds.ahh.volume = .75;
   sounds.bing.volume = .75;
   sounds.explode.volume = .35;
   sounds.pickup.volume = .75;
};

sounds.Play = function(name) {
   sounds[name].play();
};</Text>
  </SourceCode>
  <Project DisplayMode="m640x480x24" Windowed="true" TitleText="iotaBuiltIt" StartMap="Tutorial 1" OverlayMap="Overlay" MaxPlayers="1" MaxViews="1" Credits="SGDK2 Engine: http://sgdk2.sf.net&#xD;&#xA;Sound/Music support provided by FMOD: http://www.fmod.org/&#xD;&#xA;Sound Effects: Edward Dassmesser (durnurd@hotmail.com)">
    <Comments />
  </Project>
  <TileCategory Name="Solid">
    <CategorizedTileset Tileset="MainTiles" Name="Solid">
      <CategoryTile TileValue="1" />
      <CategoryTile TileValue="9" />
      <CategoryTile TileValue="19" />
      <CategoryTile TileValue="53" />
      <CategoryTile TileValue="54" />
      <CategoryTile TileValue="27" />
      <CategoryTile TileValue="57" />
      <CategoryTile TileValue="59" />
      <CategoryTile TileValue="60" />
      <CategoryTile TileValue="63" />
      <CategoryTile TileValue="64" />
      <CategoryTile TileValue="65" />
      <CategoryTile TileValue="67" />
      <CategoryTile TileValue="89" />
    </CategorizedTileset>
    <CategorizedTileset Tileset="WorldMapTiles" Name="Solid">
      <CategoryTile TileValue="1" />
      <CategoryTile TileValue="2" />
      <CategoryTile TileValue="3" />
      <CategoryTile TileValue="72" />
      <CategoryTile TileValue="73" />
      <CategoryTile TileValue="74" />
      <CategoryTile TileValue="75" />
      <CategoryTile TileValue="76" />
      <CategoryTile TileValue="77" />
      <CategoryTile TileValue="78" />
      <CategoryTile TileValue="79" />
      <CategoryTile TileValue="80" />
      <CategoryTile TileValue="81" />
      <CategoryTile TileValue="82" />
      <CategoryTile TileValue="83" />
      <CategoryTile TileValue="84" />
      <CategoryTile TileValue="85" />
      <CategoryTile TileValue="86" />
      <CategoryTile TileValue="24" />
      <CategoryTile TileValue="25" />
      <CategoryTile TileValue="26" />
      <CategoryTile TileValue="27" />
      <CategoryTile TileValue="28" />
      <CategoryTile TileValue="29" />
      <CategoryTile TileValue="30" />
      <CategoryTile TileValue="31" />
      <CategoryTile TileValue="32" />
      <CategoryTile TileValue="33" />
      <CategoryTile TileValue="34" />
      <CategoryTile TileValue="35" />
      <CategoryTile TileValue="36" />
      <CategoryTile TileValue="37" />
      <CategoryTile TileValue="58" />
      <CategoryTile TileValue="59" />
      <CategoryTile TileValue="60" />
      <CategoryTile TileValue="61" />
      <CategoryTile TileValue="62" />
      <CategoryTile TileValue="63" />
      <CategoryTile TileValue="64" />
      <CategoryTile TileValue="65" />
      <CategoryTile TileValue="66" />
      <CategoryTile TileValue="67" />
      <CategoryTile TileValue="68" />
      <CategoryTile TileValue="69" />
      <CategoryTile TileValue="70" />
      <CategoryTile TileValue="71" />
    </CategorizedTileset>
    <CategorizedTileset Tileset="UsableInventory" Name="Solid">
      <CategoryTile TileValue="101" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Uphill">
    <CategorizedTileset Tileset="MainTiles" Name="Uphill">
      <CategoryTile TileValue="2" />
      <CategoryTile TileValue="10" />
      <CategoryTile TileValue="20" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Downhill">
    <CategorizedTileset Tileset="MainTiles" Name="Downhill">
      <CategoryTile TileValue="3" />
      <CategoryTile TileValue="11" />
      <CategoryTile TileValue="21" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="HalfUpLeft">
    <CategorizedTileset Tileset="MainTiles" Name="HalfUpLeft">
      <CategoryTile TileValue="4" />
      <CategoryTile TileValue="12" />
      <CategoryTile TileValue="22" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="HalfUpRight">
    <CategorizedTileset Tileset="MainTiles" Name="HalfUpRight">
      <CategoryTile TileValue="5" />
      <CategoryTile TileValue="13" />
      <CategoryTile TileValue="23" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="HalfDownLeft">
    <CategorizedTileset Tileset="MainTiles" Name="HalfDownLeft">
      <CategoryTile TileValue="6" />
      <CategoryTile TileValue="14" />
      <CategoryTile TileValue="24" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="HalfDownRight">
    <CategorizedTileset Tileset="MainTiles" Name="HalfDownRight">
      <CategoryTile TileValue="7" />
      <CategoryTile TileValue="15" />
      <CategoryTile TileValue="25" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="TopSolid">
    <CategorizedTileset Tileset="MainTiles" Name="TopSolid">
      <CategoryTile TileValue="8" />
      <CategoryTile TileValue="16" />
      <CategoryTile TileValue="26" />
      <CategoryTile TileValue="62" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Touchable">
    <CategorizedTileset Tileset="MainTiles" Name="Touchable">
      <CategoryTile TileValue="52" />
      <CategoryTile TileValue="50" />
      <CategoryTile TileValue="51" />
      <CategoryTile TileValue="29" />
      <CategoryTile TileValue="31" />
      <CategoryTile TileValue="58" />
      <CategoryTile TileValue="59" />
      <CategoryTile TileValue="60" />
      <CategoryTile TileValue="63" />
      <CategoryTile TileValue="64" />
      <CategoryTile TileValue="65" />
      <CategoryTile TileValue="56" />
      <CategoryTile TileValue="55" />
      <CategoryTile TileValue="77" />
      <CategoryTile TileValue="78" />
      <CategoryTile TileValue="85" />
      <CategoryTile TileValue="89" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="ConveyorRight">
    <CategorizedTileset Tileset="MainTiles" Name="ConveyorRight">
      <CategoryTile TileValue="53" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="ConveyorLeft">
    <CategorizedTileset Tileset="MainTiles" Name="ConveyorLeft">
      <CategoryTile TileValue="54" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Igniting">
    <CategorizedTileset Tileset="MainTiles" Name="Igniting">
      <CategoryTile TileValue="32" />
      <CategoryTile TileValue="33" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Ignitable">
    <CategorizedTileset Tileset="MainTiles" Name="Ignitable">
      <CategoryTile TileValue="28" />
      <CategoryTile TileValue="30" />
      <CategoryTile TileValue="27" />
      <CategoryTile TileValue="57" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Climbable">
    <CategorizedTileset Tileset="MainTiles" Name="Climbable">
      <CategoryTile TileValue="35" />
      <CategoryTile TileValue="36" />
      <CategoryTile TileValue="37" />
      <CategoryTile TileValue="39" />
      <CategoryTile TileValue="41" />
      <CategoryTile TileValue="61" />
      <CategoryTile TileValue="62" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="TopSolidMid">
    <CategorizedTileset Tileset="MainTiles" Name="TopSolidMid">
      <CategoryTile TileValue="39" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Perilous">
    <CategorizedTileset Tileset="MainTiles" Name="Perilous">
      <CategoryTile TileValue="29" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="TopSolidClimbing">
    <CategorizedTileset Tileset="MainTiles" Name="TopSolidClimbing">
      <CategoryTile TileValue="8" />
      <CategoryTile TileValue="16" />
      <CategoryTile TileValue="26" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Faucet">
    <CategorizedTileset Tileset="MainTiles" Name="Faucet">
      <CategoryTile TileValue="59" />
      <CategoryTile TileValue="60" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="PlayerMeltable">
    <CategorizedTileset Tileset="MainTiles" Name="PlayerMeltable">
      <CategoryTile TileValue="58" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="InstantDeath">
    <CategorizedTileset Tileset="MainTiles" Name="InstantDeath">
      <CategoryTile TileValue="63" />
      <CategoryTile TileValue="64" />
      <CategoryTile TileValue="65" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Biohazard">
    <CategorizedTileset Tileset="MainTiles" Name="Biohazard">
      <CategoryTile TileValue="66" />
      <CategoryTile TileValue="67" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="AffectBots">
    <CategorizedTileset Tileset="MainTiles" Name="AffectBots">
      <CategoryTile TileValue="66" />
      <CategoryTile TileValue="67" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="UpCeiling">
    <CategorizedTileset Tileset="MainTiles" Name="UpCeiling">
      <CategoryTile TileValue="80" />
      <CategoryTile TileValue="82" />
      <CategoryTile TileValue="84" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="DownCeiling">
    <CategorizedTileset Tileset="MainTiles" Name="DownCeiling">
      <CategoryTile TileValue="79" />
      <CategoryTile TileValue="81" />
      <CategoryTile TileValue="83" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Checkpoint">
    <CategorizedTileset Tileset="MainTiles" Name="Checkpoint">
      <CategoryTile TileValue="85" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="WormDiggable">
    <CategorizedTileset Tileset="MainTiles" Name="WormDiggable">
      <CategoryTile TileValue="9" />
    </CategorizedTileset>
  </TileCategory>
  <TileCategory Name="Burning">
    <CategorizedTileset Tileset="MainTiles" Name="Burning">
      <CategoryTile TileValue="29" />
      <CategoryTile TileValue="31" />
    </CategorizedTileset>
  </TileCategory>
</ProjectDataset>